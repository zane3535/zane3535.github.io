var wisp_full;(()=>{var t={640:function(t){!function(e){"use strict";const s="(0?\\d+|0x[a-f0-9]+)",i={fourOctet:new RegExp(`^${s}\\.${s}\\.${s}\\.${s}$`,"i"),threeOctet:new RegExp(`^${s}\\.${s}\\.${s}$`,"i"),twoOctet:new RegExp(`^${s}\\.${s}$`,"i"),longValue:new RegExp(`^${s}$`,"i")},n=new RegExp("^0[0-7]+$","i"),r=new RegExp("^0x[a-f0-9]+$","i"),o="%[0-9a-z]{1,}",a="(?:[0-9a-f]+::?)+",c={zoneIndex:new RegExp(o,"i"),native:new RegExp(`^(::)?(${a})?([0-9a-f]+)?(::)?(${o})?$`,"i"),deprecatedTransitional:new RegExp(`^(?:::)(${s}\\.${s}\\.${s}\\.${s}(${o})?)$`,"i"),transitional:new RegExp(`^((?:${a})|(?:::)(?:${a})?)${s}\\.${s}\\.${s}\\.${s}(${o})?$`,"i")};function h(t,e){if(t.indexOf("::")!==t.lastIndexOf("::"))return null;let s,i,n=0,r=-1,o=(t.match(c.zoneIndex)||[])[0];for(o&&(o=o.substring(1),t=t.replace(/%.+$/,""));(r=t.indexOf(":",r+1))>=0;)n++;if("::"===t.substr(0,2)&&n--,"::"===t.substr(-2,2)&&n--,n>e)return null;for(i=e-n,s=":";i--;)s+="0:";return":"===(t=t.replace("::",s))[0]&&(t=t.slice(1)),":"===t[t.length-1]&&(t=t.slice(0,-1)),{parts:e=function(){const e=t.split(":"),s=[];for(let t=0;t<e.length;t++)s.push(parseInt(e[t],16));return s}(),zoneId:o}}function l(t,e,s,i){if(t.length!==e.length)throw new Error("ipaddr: cannot match CIDR for objects with different lengths");let n,r=0;for(;i>0;){if(n=s-i,n<0&&(n=0),t[r]>>n!==e[r]>>n)return!1;i-=s,r+=1}return!0}function p(t){if(r.test(t))return parseInt(t,16);if("0"===t[0]&&!isNaN(parseInt(t[1],10))){if(n.test(t))return parseInt(t,8);throw new Error(`ipaddr: cannot parse ${t} as octal`)}return parseInt(t,10)}function u(t,e){for(;t.length<e;)t=`0${t}`;return t}const d={};d.IPv4=function(){function t(t){if(4!==t.length)throw new Error("ipaddr: ipv4 octet count should be 4");let e,s;for(e=0;e<t.length;e++)if(s=t[e],!(0<=s&&s<=255))throw new Error("ipaddr: ipv4 octet should fit in 8 bits");this.octets=t}return t.prototype.SpecialRanges={unspecified:[[new t([0,0,0,0]),8]],broadcast:[[new t([255,255,255,255]),32]],multicast:[[new t([224,0,0,0]),4]],linkLocal:[[new t([169,254,0,0]),16]],loopback:[[new t([127,0,0,0]),8]],carrierGradeNat:[[new t([100,64,0,0]),10]],private:[[new t([10,0,0,0]),8],[new t([172,16,0,0]),12],[new t([192,168,0,0]),16]],reserved:[[new t([192,0,0,0]),24],[new t([192,0,2,0]),24],[new t([192,88,99,0]),24],[new t([198,18,0,0]),15],[new t([198,51,100,0]),24],[new t([203,0,113,0]),24],[new t([240,0,0,0]),4]],as112:[[new t([192,175,48,0]),24],[new t([192,31,196,0]),24]],amt:[[new t([192,52,193,0]),24]]},t.prototype.kind=function(){return"ipv4"},t.prototype.match=function(t,e){let s;if(void 0===e&&(s=t,t=s[0],e=s[1]),"ipv4"!==t.kind())throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");return l(this.octets,t.octets,8,e)},t.prototype.prefixLengthFromSubnetMask=function(){let t=0,e=!1;const s={0:8,128:7,192:6,224:5,240:4,248:3,252:2,254:1,255:0};let i,n,r;for(i=3;i>=0;i-=1){if(n=this.octets[i],!(n in s))return null;if(r=s[n],e&&0!==r)return null;8!==r&&(e=!0),t+=r}return 32-t},t.prototype.range=function(){return d.subnetMatch(this,this.SpecialRanges)},t.prototype.toByteArray=function(){return this.octets.slice(0)},t.prototype.toIPv4MappedAddress=function(){return d.IPv6.parse(`::ffff:${this.toString()}`)},t.prototype.toNormalizedString=function(){return this.toString()},t.prototype.toString=function(){return this.octets.join(".")},t}(),d.IPv4.broadcastAddressFromCIDR=function(t){try{const e=this.parseCIDR(t),s=e[0].toByteArray(),i=this.subnetMaskFromPrefixLength(e[1]).toByteArray(),n=[];let r=0;for(;r<4;)n.push(parseInt(s[r],10)|255^parseInt(i[r],10)),r++;return new this(n)}catch(t){throw new Error("ipaddr: the address does not have IPv4 CIDR format")}},d.IPv4.isIPv4=function(t){return null!==this.parser(t)},d.IPv4.isValid=function(t){try{return new this(this.parser(t)),!0}catch(t){return!1}},d.IPv4.isValidCIDR=function(t){try{return this.parseCIDR(t),!0}catch(t){return!1}},d.IPv4.isValidFourPartDecimal=function(t){return!(!d.IPv4.isValid(t)||!t.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/))},d.IPv4.isValidCIDRFourPartDecimal=function(t){const e=t.match(/^(.+)\/(\d+)$/);return!(!d.IPv4.isValidCIDR(t)||!e)&&d.IPv4.isValidFourPartDecimal(e[1])},d.IPv4.networkAddressFromCIDR=function(t){let e,s,i,n,r;try{for(e=this.parseCIDR(t),i=e[0].toByteArray(),r=this.subnetMaskFromPrefixLength(e[1]).toByteArray(),n=[],s=0;s<4;)n.push(parseInt(i[s],10)&parseInt(r[s],10)),s++;return new this(n)}catch(t){throw new Error("ipaddr: the address does not have IPv4 CIDR format")}},d.IPv4.parse=function(t){const e=this.parser(t);if(null===e)throw new Error("ipaddr: string is not formatted like an IPv4 Address");return new this(e)},d.IPv4.parseCIDR=function(t){let e;if(e=t.match(/^(.+)\/(\d+)$/)){const t=parseInt(e[2]);if(t>=0&&t<=32){const s=[this.parse(e[1]),t];return Object.defineProperty(s,"toString",{value:function(){return this.join("/")}}),s}}throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range")},d.IPv4.parser=function(t){let e,s,n;if(e=t.match(i.fourOctet))return function(){const t=e.slice(1,6),i=[];for(let e=0;e<t.length;e++)s=t[e],i.push(p(s));return i}();if(e=t.match(i.longValue)){if(n=p(e[1]),n>4294967295||n<0)throw new Error("ipaddr: address outside defined range");return function(){const t=[];let e;for(e=0;e<=24;e+=8)t.push(n>>e&255);return t}().reverse()}return(e=t.match(i.twoOctet))?function(){const t=e.slice(1,4),s=[];if(n=p(t[1]),n>16777215||n<0)throw new Error("ipaddr: address outside defined range");return s.push(p(t[0])),s.push(n>>16&255),s.push(n>>8&255),s.push(255&n),s}():(e=t.match(i.threeOctet))?function(){const t=e.slice(1,5),s=[];if(n=p(t[2]),n>65535||n<0)throw new Error("ipaddr: address outside defined range");return s.push(p(t[0])),s.push(p(t[1])),s.push(n>>8&255),s.push(255&n),s}():null},d.IPv4.subnetMaskFromPrefixLength=function(t){if((t=parseInt(t))<0||t>32)throw new Error("ipaddr: invalid IPv4 prefix length");const e=[0,0,0,0];let s=0;const i=Math.floor(t/8);for(;s<i;)e[s]=255,s++;return i<4&&(e[i]=Math.pow(2,t%8)-1<<8-t%8),new this(e)},d.IPv6=function(){function t(t,e){let s,i;if(16===t.length)for(this.parts=[],s=0;s<=14;s+=2)this.parts.push(t[s]<<8|t[s+1]);else{if(8!==t.length)throw new Error("ipaddr: ipv6 part count should be 8 or 16");this.parts=t}for(s=0;s<this.parts.length;s++)if(i=this.parts[s],!(0<=i&&i<=65535))throw new Error("ipaddr: ipv6 part should fit in 16 bits");e&&(this.zoneId=e)}return t.prototype.SpecialRanges={unspecified:[new t([0,0,0,0,0,0,0,0]),128],linkLocal:[new t([65152,0,0,0,0,0,0,0]),10],multicast:[new t([65280,0,0,0,0,0,0,0]),8],loopback:[new t([0,0,0,0,0,0,0,1]),128],uniqueLocal:[new t([64512,0,0,0,0,0,0,0]),7],ipv4Mapped:[new t([0,0,0,0,0,65535,0,0]),96],discard:[new t([256,0,0,0,0,0,0,0]),64],rfc6145:[new t([0,0,0,0,65535,0,0,0]),96],rfc6052:[new t([100,65435,0,0,0,0,0,0]),96],"6to4":[new t([8194,0,0,0,0,0,0,0]),16],teredo:[new t([8193,0,0,0,0,0,0,0]),32],benchmarking:[new t([8193,2,0,0,0,0,0,0]),48],amt:[new t([8193,3,0,0,0,0,0,0]),32],as112v6:[[new t([8193,4,274,0,0,0,0,0]),48],[new t([9760,79,32768,0,0,0,0,0]),48]],deprecated:[new t([8193,16,0,0,0,0,0,0]),28],orchid2:[new t([8193,32,0,0,0,0,0,0]),28],droneRemoteIdProtocolEntityTags:[new t([8193,48,0,0,0,0,0,0]),28],reserved:[[new t([8193,0,0,0,0,0,0,0]),23],[new t([8193,3512,0,0,0,0,0,0]),32]]},t.prototype.isIPv4MappedAddress=function(){return"ipv4Mapped"===this.range()},t.prototype.kind=function(){return"ipv6"},t.prototype.match=function(t,e){let s;if(void 0===e&&(s=t,t=s[0],e=s[1]),"ipv6"!==t.kind())throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");return l(this.parts,t.parts,16,e)},t.prototype.prefixLengthFromSubnetMask=function(){let t=0,e=!1;const s={0:16,32768:15,49152:14,57344:13,61440:12,63488:11,64512:10,65024:9,65280:8,65408:7,65472:6,65504:5,65520:4,65528:3,65532:2,65534:1,65535:0};let i,n;for(let r=7;r>=0;r-=1){if(i=this.parts[r],!(i in s))return null;if(n=s[i],e&&0!==n)return null;16!==n&&(e=!0),t+=n}return 128-t},t.prototype.range=function(){return d.subnetMatch(this,this.SpecialRanges)},t.prototype.toByteArray=function(){let t;const e=[],s=this.parts;for(let i=0;i<s.length;i++)t=s[i],e.push(t>>8),e.push(255&t);return e},t.prototype.toFixedLengthString=function(){const t=function(){const t=[];for(let e=0;e<this.parts.length;e++)t.push(u(this.parts[e].toString(16),4));return t}.call(this).join(":");let e="";return this.zoneId&&(e=`%${this.zoneId}`),t+e},t.prototype.toIPv4Address=function(){if(!this.isIPv4MappedAddress())throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");const t=this.parts.slice(-2),e=t[0],s=t[1];return new d.IPv4([e>>8,255&e,s>>8,255&s])},t.prototype.toNormalizedString=function(){const t=function(){const t=[];for(let e=0;e<this.parts.length;e++)t.push(this.parts[e].toString(16));return t}.call(this).join(":");let e="";return this.zoneId&&(e=`%${this.zoneId}`),t+e},t.prototype.toRFC5952String=function(){const t=/((^|:)(0(:|$)){2,})/g,e=this.toNormalizedString();let s,i=0,n=-1;for(;s=t.exec(e);)s[0].length>n&&(i=s.index,n=s[0].length);return n<0?e:`${e.substring(0,i)}::${e.substring(i+n)}`},t.prototype.toString=function(){return this.toRFC5952String()},t}(),d.IPv6.broadcastAddressFromCIDR=function(t){try{const e=this.parseCIDR(t),s=e[0].toByteArray(),i=this.subnetMaskFromPrefixLength(e[1]).toByteArray(),n=[];let r=0;for(;r<16;)n.push(parseInt(s[r],10)|255^parseInt(i[r],10)),r++;return new this(n)}catch(t){throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${t})`)}},d.IPv6.isIPv6=function(t){return null!==this.parser(t)},d.IPv6.isValid=function(t){if("string"==typeof t&&-1===t.indexOf(":"))return!1;try{const e=this.parser(t);return new this(e.parts,e.zoneId),!0}catch(t){return!1}},d.IPv6.isValidCIDR=function(t){if("string"==typeof t&&-1===t.indexOf(":"))return!1;try{return this.parseCIDR(t),!0}catch(t){return!1}},d.IPv6.networkAddressFromCIDR=function(t){let e,s,i,n,r;try{for(e=this.parseCIDR(t),i=e[0].toByteArray(),r=this.subnetMaskFromPrefixLength(e[1]).toByteArray(),n=[],s=0;s<16;)n.push(parseInt(i[s],10)&parseInt(r[s],10)),s++;return new this(n)}catch(t){throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${t})`)}},d.IPv6.parse=function(t){const e=this.parser(t);if(null===e.parts)throw new Error("ipaddr: string is not formatted like an IPv6 Address");return new this(e.parts,e.zoneId)},d.IPv6.parseCIDR=function(t){let e,s,i;if((s=t.match(/^(.+)\/(\d+)$/))&&(e=parseInt(s[2]),e>=0&&e<=128))return i=[this.parse(s[1]),e],Object.defineProperty(i,"toString",{value:function(){return this.join("/")}}),i;throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range")},d.IPv6.parser=function(t){let e,s,i,n,r,o;if(i=t.match(c.deprecatedTransitional))return this.parser(`::ffff:${i[1]}`);if(c.native.test(t))return h(t,8);if((i=t.match(c.transitional))&&(o=i[6]||"",e=i[1],i[1].endsWith("::")||(e=e.slice(0,-1)),e=h(e+o,6),e.parts)){for(r=[parseInt(i[2]),parseInt(i[3]),parseInt(i[4]),parseInt(i[5])],s=0;s<r.length;s++)if(n=r[s],!(0<=n&&n<=255))return null;return e.parts.push(r[0]<<8|r[1]),e.parts.push(r[2]<<8|r[3]),{parts:e.parts,zoneId:e.zoneId}}return null},d.IPv6.subnetMaskFromPrefixLength=function(t){if((t=parseInt(t))<0||t>128)throw new Error("ipaddr: invalid IPv6 prefix length");const e=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];let s=0;const i=Math.floor(t/8);for(;s<i;)e[s]=255,s++;return i<16&&(e[i]=Math.pow(2,t%8)-1<<8-t%8),new this(e)},d.fromByteArray=function(t){const e=t.length;if(4===e)return new d.IPv4(t);if(16===e)return new d.IPv6(t);throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address")},d.isValid=function(t){return d.IPv6.isValid(t)||d.IPv4.isValid(t)},d.isValidCIDR=function(t){return d.IPv6.isValidCIDR(t)||d.IPv4.isValidCIDR(t)},d.parse=function(t){if(d.IPv6.isValid(t))return d.IPv6.parse(t);if(d.IPv4.isValid(t))return d.IPv4.parse(t);throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format")},d.parseCIDR=function(t){try{return d.IPv6.parseCIDR(t)}catch(e){try{return d.IPv4.parseCIDR(t)}catch(t){throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format")}}},d.process=function(t){const e=this.parse(t);return"ipv6"===e.kind()&&e.isIPv4MappedAddress()?e.toIPv4Address():e},d.subnetMatch=function(t,e,s){let i,n,r,o;for(n in null==s&&(s="unicast"),e)if(Object.prototype.hasOwnProperty.call(e,n))for(r=e[n],!r[0]||r[0]instanceof Array||(r=[r]),i=0;i<r.length;i++)if(o=r[i],t.kind()===o[0].kind()&&t.match.apply(t,o))return n;return s},t.exports?t.exports=d:e.ipaddr=d}(this)}},e={};function s(i){var n=e[i];if(void 0!==n)return n.exports;var r=e[i]={exports:{}};return t[i].call(r.exports,r,r.exports,s),r.exports}s.d=(t,e)=>{for(var i in e)s.o(e,i)&&!s.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),s.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var i={};(()=>{"use strict";s.r(i),s.d(i,{client:()=>n,extensions:()=>e,packet:()=>t,server:()=>r});var t={};s.r(t),s.d(t,{ClosePayload:()=>g,ConnectPayload:()=>m,ContinuePayload:()=>v,DataPayload:()=>y,InfoPayload:()=>b,WispBuffer:()=>w,WispPacket:()=>_,close_reasons:()=>x,packet_classes:()=>k,packet_types:()=>I,stream_types:()=>P});var e={};s.r(e),s.d(e,{BaseExtension:()=>E,MOTDExtension:()=>D,PasswordAuthExtension:()=>z,UDPExtension:()=>C,extensions_map:()=>U,parse_extensions:()=>S,serialize_extensions:()=>T});var n={};s.r(n),s.d(n,{ClientConnection:()=>R,WispWebSocket:()=>B,_wisp_connections:()=>N});var r={};s.r(r),s.d(r,{ServerConnection:()=>_t,ServerStream:()=>wt,options:()=>G,parse_real_ip:()=>vt,routeRequest:()=>gt});const o="undefined"==typeof globalThis?window:globalThis,a=o.WebSocket,c=o.crypto,h=null,l=null,p=new TextEncoder,u=p.encode.bind(p),d=new TextDecoder,f=d.decode.bind(d);class w{constructor(t){if(t instanceof Uint8Array)this.from_array(t);else if("number"==typeof t)this.from_array(new Uint8Array(t));else{if("string"!=typeof t)throw console.trace(),"invalid data type passed to wisp buffer constructor";this.from_array(u(t))}}from_array(t){this.size=t.length,this.bytes=t,this.view=new DataView(t.buffer)}concat(t){let e=new w(this.size+t.size);return e.bytes.set(this.bytes,0),e.bytes.set(t.bytes,this.size),e}slice(t,e){let s=this.bytes.slice(t,e);return new w(s)}get_string(){return d.decode(this.bytes)}}class _{static min_size=5;constructor({type:t,stream_id:e,payload:s,payload_bytes:i}){this.type=t,this.stream_id=e,this.payload_bytes=i,this.payload=s}static parse(t){return new _({type:t.view.getUint8(0),stream_id:t.view.getUint32(1,!0),payload_bytes:t.slice(5)})}static parse_all(t){if(t.size<_.min_size)throw TypeError("packet too small");let e=_.parse(t),s=k[e.type];if(void 0===s)throw TypeError("invalid packet type");if(e.payload_bytes.size<s.size)throw TypeError("payload too small");return e.payload=s.parse(e.payload_bytes),e}serialize(){let t=new w(5);return t.view.setUint8(0,this.type),t.view.setUint32(1,this.stream_id,!0),t=t.concat(this.payload.serialize()),t}}class m{static min_size=3;static type=1;static name="CONNECT";constructor({stream_type:t,port:e,hostname:s}){this.stream_type=t,this.port=e,this.hostname=s}static parse(t){return new m({stream_type:t.view.getUint8(0),port:t.view.getUint16(1,!0),hostname:f(t.slice(3).bytes)})}serialize(){let t=new w(3);return t.view.setUint8(0,this.stream_type),t.view.setUint16(1,this.port,!0),t=t.concat(new w(this.hostname)),t}}class y{static min_size=0;static type=2;static name="DATA";constructor({data:t}){this.data=t}static parse(t){return new y({data:t})}serialize(){return this.data}}class v{static type=3;static name="CONTINUE";constructor({buffer_remaining:t}){this.buffer_remaining=t}static parse(t){return new v({buffer_remaining:t.view.getUint32(0,!0)})}serialize(){let t=new w(4);return t.view.setUint32(0,this.buffer_remaining,!0),t}}class g{static min_size=1;static type=4;static name="CLOSE";constructor({reason:t}){this.reason=t}static parse(t){return new g({reason:t.view.getUint8(0)})}serialize(){let t=new w(1);return t.view.setUint8(0,this.reason),t}}class b{static min_size=2;static type=5;static name="INFO";constructor({major_ver:t,minor_ver:e,extensions:s}){this.major_ver=t,this.minor_ver=e,this.extensions=s}static parse(t){return new b({major_ver:t.view.getUint8(0),minor_ver:t.view.getUint8(1),extensions:t.slice(2)})}serialize(){let t=new w(2);return t.view.setUint8(0,this.major_ver),t.view.setUint8(1,this.minor_ver),t.concat(this.extensions)}}const k={1:m,2:y,3:v,4:g,5:b},I={CONNECT:1,DATA:2,CONTINUE:3,CLOSE:4,INFO:5},P={TCP:1,UDP:2},x={Unknown:1,Voluntary:2,NetworkError:3,IncompatibleExtensions:4,InvalidInfo:65,UnreachableHost:66,NoResponse:67,ConnRefused:68,TransferTimeout:71,HostBlocked:72,ConnThrottled:73,ClientError:129,AuthBadPassword:192,AuthBadSignature:193,AuthMissingCredentials:194};class ${constructor(){}static parse(){return new $}serialize(){return new w(0)}}class E{static id=0;static name="";static Server=$;static Client=$;constructor({server_config:t,client_config:e}={}){this.id=this.constructor.id,this.name=this.constructor.name,t?this.payload=new this.constructor.Server(t):e&&(this.payload=new this.constructor.Client(e))}static parse(t,e,s){let i=new t({});if("client"===s)i.payload=t.Client.parse(e.slice(5));else{if("server"!==s)throw TypeError("invalid role");i.payload=t.Server.parse(e.slice(5))}return i}serialize(){let t=new w(5),e=this.payload.serialize();return t.view.setInt8(0,this.constructor.id),t.view.setUint32(1,e.size,!0),t.concat(e)}}class C extends E{static id=1;static name="UDP"}class z extends E{static id=2;static name="Password Authentication";static Server=class{constructor({required:t=1}){this.required=t?1:0}static parse(t){return new z.Server({required:t.view.getUint8(0)})}serialize(){let t=new w(1);return t.view.setUint8(0,this.required),t}};static Client=class{constructor({username:t,password:e}){this.username=t,this.password=e}static parse(t){let e=t.view.getUint8(0),s=t.view.getUint16(1,!0),i=e+3;return new z.Client({username:t.slice(3,e).get_string(),password:t.slice(i,s).get_string()})}serialize(){let t=new w(this.username),e=new w(this.password),s=new w(3);return s.view.setUint8(0,t.size),s.view.setUint16(1,e.size,!0),s.concat(t).concat(e)}}}class D extends E{static id=4;static name="Server MOTD";static Server=class{constructor({message:t}){this.message=t}static parse(t){return new D.Server({message:t.get_string()})}serialize(){return new w(this.message)}};static Client=$}function S(t,e,s){let i=[];for(;t.size;){let n,r=t.view.getUint8(0),o=t.view.getUint32(1,!0),a=t.slice(0,5+o);for(let t of e)if(t.id===r){n=t.constructor;break}if(n){let t=E.parse(n,a,s);i.push(t)}t=t.slice(5+o)}return i}function T(t){{let e=new w(0);for(let s of t)e=e.concat(s.serialize());return e}}const U={1:C,2:z,4:D};class A{constructor(t,e,s,i,n,r,o){this.hostname=t,this.port=e,this.ws=s,this.buffer_size=i,this.stream_id=n,this.connection=r,this.stream_type=o,this.send_buffer=[],this.open=!0,this.onopen=()=>{},this.onclose=()=>{},this.onmessage=()=>{}}send(t){if(this.buffer_size>0||!this.open||this.stream_type===P.UDP){let e=new _({type:I.DATA,stream_id:this.stream_id,payload:new y({data:new w(t)})});this.ws.send(e.serialize().bytes),this.buffer_size--}else this.send_buffer.push(t)}continue_received(t){for(this.buffer_size=t;this.buffer_size>0&&this.send_buffer.length>0;)this.send(this.send_buffer.shift())}close(t=1){if(!this.open)return;let e=new _({type:I.CLOSE,stream_id:this.stream_id,payload:new g({reason:t})});this.ws.send(e.serialize().bytes),this.open=!1,delete this.connection.active_streams[this.stream_id]}}class R{constructor(t,{wisp_version:e,wisp_extensions:s}={}){if(!t.endsWith("/"))throw new TypeError("wisp endpoints must end with a trailing forward slash");this.wisp_url=t,this.wisp_version=e||2,this.wisp_extensions=s||null,this.max_buffer_size=null,this.active_streams={},this.connected=!1,this.connecting=!1,this.next_stream_id=1,this.server_exts={},this.client_exts={},this.info_received=!1,this.server_motd=null,this.udp_enabled=!0,this.onopen=()=>{},this.onclose=()=>{},this.onerror=()=>{},this.onmessage=()=>{},2===this.wisp_version&&null===this.wisp_extensions&&this.add_extensions(),this.connect_ws()}add_extensions(){this.wisp_extensions=[],this.wisp_extensions.push(new C({client_config:{}})),this.wisp_extensions.push(new D({client_config:{}}))}connect_ws(){let t=2===this.wisp_version?"wisp-v2":void 0;this.ws=new a(this.wisp_url,t),this.ws.binaryType="arraybuffer",this.connecting=!0,this.ws.onerror=()=>{if(2===this.wisp_version)return this.ws.onclose=null,this.cleanup(),this.wisp_version=1,void this.connect_ws();this.cleanup(),this.onerror()},this.ws.onclose=()=>{this.cleanup(),this.onclose()},this.ws.onmessage=t=>{this.on_ws_msg(t),this.connected&&this.connecting&&(this.connecting=!1,this.onopen())}}close(){this.ws.close()}create_stream(t,e,s=1){let i=s;if("string"==typeof i&&(i="udp"===s?P.UDP:P.TCP),i==P.UDP&&!this.udp_enabled)throw new Error("udp is not enabled for this wisp connection");let n=this.next_stream_id++,r=new A(t,e,this.ws,this.max_buffer_size,n,this,i);this.active_streams[n]=r,r.open=this.connected;let o=new _({type:I.CONNECT,stream_id:n,payload:new m({stream_type:i,port:e,hostname:t})});return this.ws.send(o.serialize().bytes),r}close_stream(t,e){t.onclose(e),delete this.active_streams[t.stream_id]}on_ws_msg(t){let e=new w(new Uint8Array(t.data));if(e.size<_.min_size)return void console.warn("wisp client warning: received a packet which is too short");let s=_.parse_all(e),i=this.active_streams[s.stream_id];if(0===s.stream_id&&this.connecting){if(s.type===I.CONTINUE&&(this.max_buffer_size=s.payload.buffer_remaining,this.connected=!0,this.info_received||(this.wisp_version=1)),s.type===I.INFO&&2===this.wisp_version){let t=S(s.payload.extensions,this.wisp_extensions,"server");for(let e of t)for(let t of this.wisp_extensions)e.id===t.id&&(this.server_exts[e.id]=e,this.client_exts[t.id]=t);this.info_received=!0,this.server_motd=this.server_exts[D.id]?.payload?.message,this.udp_enabled=!!this.server_exts[C.id];let e=T(this.wisp_extensions),i=new _({type:b.type,stream_id:0,payload:new b({major_ver:this.wisp_version,minor_ver:0,extensions:e})});this.ws.send(i.serialize().bytes)}}else void 0!==i?s.type===I.DATA?i.onmessage(s.payload_bytes.bytes):s.type===I.CONTINUE?i.continue_received(s.payload.buffer_remaining):s.type===I.CLOSE?this.close_stream(i,s.payload.reason):console.warn(`wisp client warning: received an invalid packet of type ${s.type}`):console.warn(`wisp client warning: received a ${k[s.type].name} packet for a stream which doesn't exist`)}cleanup(){this.connected=!1,this.connecting=!1;for(let t of Object.keys(this.active_streams))this.close_stream(this.active_streams[t],3)}}const O=o.CloseEvent||Event,N={};class B extends EventTarget{constructor(t,e=null,s={}){super(),this.url=t,this.protocols=e,this.options=s,this.binaryType="blob",this.stream=null,this.connection=null,this.onopen=()=>{},this.onerror=()=>{},this.onmessage=()=>{},this.onclose=()=>{},this.CONNECTING=0,this.OPEN=1,this.CLOSING=2,this.CLOSED=3,this._ready_state=this.CONNECTING;let i=this.url.split("/"),n=i.pop().split(":");this.host=n[0],this.port=parseInt(n[1]),this.real_url=i.join("/")+"/",this.init_connection()}on_conn_close(){this._ready_state=this.CLOSED,N[this.real_url]&&(this.onerror(new Event("error")),this.dispatchEvent(new Event("error"))),delete N[this.real_url]}init_connection(){if(this.connection=N[this.real_url],this.connection)if(this.connection.connected)this.connection=N[this.real_url],this.init_stream();else{let t=this.connection.onopen;this.connection.onopen=()=>{t(),this.init_stream()}}else this.connection=new R(this.real_url,this.options),this.connection.onopen=()=>{this.init_stream()},this.connection.onclose=()=>{this.on_conn_close()},this.connection.onerror=()=>{this.on_conn_close()},N[this.real_url]=this.connection}init_stream(){this._ready_state=this.OPEN,this.stream=this.connection.create_stream(this.host,this.port),this.stream.onmessage=t=>{let e;if("blob"==this.binaryType)e=new Blob(t);else{if("arraybuffer"!=this.binaryType)throw"invalid binaryType string";e=t.buffer}let s=new MessageEvent("message",{data:e});this.onmessage(s),this.dispatchEvent(s)},this.stream.onclose=t=>{this._ready_state=this.CLOSED;let e=new O("close",{code:t});this.onclose(e),this.dispatchEvent(e)};let t=new Event("open");this.onopen(t),this.dispatchEvent(t)}send(t){let e;if(t instanceof Uint8Array)e=t;else if("string"==typeof t)e=(new TextEncoder).encode(t);else{if(t instanceof Blob)return void t.arrayBuffer().then(t=>{this.send(t)});if(t instanceof ArrayBuffer)e=new Uint8Array(t);else{if(!ArrayBuffer.isView(t))throw"invalid data type to be sent";e=new Uint8Array(t.buffer)}}if(!this.stream)throw"websocket is not ready";this.stream.send(e)}close(){this.stream.close(2)}get bufferedAmount(){let t=0;for(let e of this.stream.send_buffer)t+=e.length;return t}get extensions(){return""}get protocol(){return"binary"}get readyState(){return this._ready_state}}const M=1,q=3;let j=M;function V(){let[t,e]=(new Date).toJSON().split("T");return t=t.replaceAll("-","/"),e=e.split(".")[0],`[${t} - ${e}]`}function F(...t){j>0||console.debug(V()+" debug:",...t)}function L(...t){j>M||console.info(V()+" info:",...t)}function H(...t){j>2||console.warn(V()+" warn:",...t)}function W(...t){j>q||console.error(V()+" error:",...t)}const G={hostname_blacklist:null,hostname_whitelist:null,port_blacklist:null,port_whitelist:null,allow_direct_ip:!0,allow_private_ips:!1,allow_loopback_ips:!1,client_ip_blacklist:null,client_ip_whitelist:null,stream_limit_per_host:-1,stream_limit_total:-1,allow_udp_streams:!0,allow_tcp_streams:!0,dns_ttl:120,dns_method:"lookup",dns_servers:null,dns_result_order:"verbatim",parse_real_ip:!0,parse_real_ip_from:["127.0.0.1"],wisp_version:2,wisp_motd:null};class J{send_buffer_size=33554432;constructor(t){this.ws=t,this.connected=!1,this.data_queue=new K(1)}async connect(){await new Promise((t,e)=>{this.ws.onopen=()=>{this.connected=!0,t()},this.ws.onmessage=t=>{this.data_queue.put(t.data)},this.ws.onclose=()=>{this.connected?this.data_queue.close():e()},this.ws.readyState===this.ws.OPEN&&(this.connected=!0,t())})}async recv(){return await this.data_queue.get()}async send(t){if(t instanceof _&&(t=t.serialize().bytes),this.ws.send(t),!(this.ws.bufferedAmount<=this.send_buffer_size))for(;!(this.ws.bufferedAmount<=this.send_buffer_size/2);)await new Promise(t=>{setTimeout(t,10)})}close(t,e){this.ws.close(t,e),this.data_queue.close()}get buffered_amount(){return this.ws.bufferedAmount}}class K{constructor(t){this.max_size=t,this.queue=[],this.put_callbacks=[],this.get_callbacks=[]}put_now(t){this.queue.push(t),this.get_callbacks.shift()?.()}async put(t){this.size<=this.max_size||await new Promise(t=>{this.put_callbacks.push(t)}),this.put_now(t)}get_now(){return this.put_callbacks.shift()?.(),this.queue.shift()}async get(){return this.size>0||await new Promise(t=>{this.get_callbacks.push(t)}),this.get_now()}close(){let t;for(this.queue=[];t=this.get_callbacks.shift();)t();for(;t=this.put_callbacks.shift();)t()}get size(){return this.queue.length}}const Q="undefined"!=typeof process,X=new Map;let Y=null,Z=null;function tt(){if(!Q)throw new Error("not running on node.js")}function et(t){return Z.resolve4(t)}function st(t){return Z.resolve6(t)}async function it(t,e,s){try{return(await t(s))[0]}catch{return(await e(s))[0]}}async function nt(t){if(!Q)return t;let e=h.isIP(t);if(4===e||6===e)return t;let s=Date.now();for(let[t,e]of X)s-e.time>G.dns_ttl&&X.delete(t);let i,n=X.get(t);if(n){if(n.error)throw n.error;return n.address}try{i=await async function(t){if("lookup"===G.dns_method)return(await null.lookup(t,{order:G.dns_result_order})).address;if("resolve"===G.dns_method){if(Z||(Z=new null.Resolver),G.dns_servers!==Y&&(F("Setting custom DNS servers to: "+G.dns_servers.join(", ")),Z.setServers(G.dns_servers),Y=G.dns_servers),"verbatim"===G.dns_result_order||"ipv6first"===G.dns_result_order)return await it(st,et,t);if("ipv4first"===G.dns_result_order)return await it(et,st,t);throw new Error("Invalid result order. options.dns_result_order must be either 'ipv6first', 'ipv4first', or 'verbatim'.")}if("function"==typeof G.dns_method)return await G.dns_method(t);throw new Error("Invalid DNS method. options.dns_method must either be 'lookup' or 'resolve'.")}(t),F(`Domain resolved: ${t} -> ${i}`),X.set(t,{time:Date.now(),address:i})}catch(e){throw X.set(t,{time:Date.now(),error:e}),e}return i}class rt{constructor(t,e){tt(),this.hostname=t,this.port=e,this.recv_buffer_size=128,this.socket=null,this.paused=!1,this.connected=!1,this.data_queue=new K(this.recv_buffer_size)}async connect(){let t=await nt(this.hostname);await new Promise((e,s)=>{this.socket=new h.Socket,this.socket.setNoDelay(!0),this.socket.on("connect",()=>{this.connected=!0,e()}),this.socket.on("data",t=>{this.data_queue.put(t)}),this.socket.on("close",t=>{t&&!this.connected?s():this.data_queue.close(),this.socket=null}),this.socket.on("error",t=>{H(`tcp stream to ${this.hostname} ended with error - ${t}`)}),this.socket.on("end",()=>{this.socket&&(this.socket.destroy(),this.socket=null)}),this.socket.connect({host:t,port:this.port})})}async recv(){return await this.data_queue.get()}async send(t){await new Promise(e=>{this.socket.write(t,e)})}async close(){this.socket&&(this.socket.end(),this.socket=null)}pause(){this.data_queue.size>=this.data_queue.max_size&&(this.socket.pause(),this.paused=!0)}resume(){this.socket&&this.paused&&(this.socket.resume(),this.paused=!1)}}class ot{constructor(t,e){tt(),this.hostname=t,this.port=e,this.connected=!1,this.recv_buffer_size=128,this.data_queue=new K(this.recv_buffer_size)}async connect(){let t=await nt(this.hostname),e=h.isIP(t);await new Promise((s,i)=>{this.socket=null.createSocket(6===e?"udp6":"udp4"),this.socket.on("connect",()=>{s()}),this.socket.on("message",t=>{this.data_queue.put(t)}),this.socket.on("error",()=>{this.connected||i(),this.data_queue.close(),this.socket=null}),this.socket.connect(this.port,t)})}async recv(){return await this.data_queue.get()}async send(t){this.socket.send(t)}async close(){this.socket&&(this.socket.close(),this.socket=null)}pause(){}resume(){}}var at=s(640);class ct extends Error{}function ht(t,e){return t===e||t[0]<=e&&t[1]>=e}function lt(t,e){let s=!1;for(let i of t)if(e(i)){s=!0;break}return!s}function pt(t,e){for(let s of t)if(e(s))return!0;return!1}function ut(t,e){return e.includes(t.range())}async function dt(t,e,s,i){if(!G.allow_tcp_streams&&e===P.TCP)return x.HostBlocked;if(!G.allow_udp_streams&&e===P.UDP)return x.HostBlocked;if(G.hostname_whitelist){if(lt(G.hostname_whitelist,t=>t.test(s)))return x.HostBlocked}else if(G.hostname_blacklist&&pt(G.hostname_blacklist,t=>t.test(s)))return x.HostBlocked;if(G.port_whitelist){if(lt(G.port_whitelist,t=>ht(t,i)))return x.HostBlocked}else if(G.port_blacklist&&pt(G.port_blacklist,t=>ht(t,i)))return x.HostBlocked;let n=s;if(at.isValid(s)){if(!G.allow_direct_ip)return x.HostBlocked}else try{n=await nt(s)}catch{}if(function(t){if(!at.isValid(t))return!1;let e=at.parse(t);return!(G.allow_loopback_ips||!ut(e,["loopback","unspecified"]))||!(G.allow_private_ips||!ut(e,["broadcast","linkLocal","carrierGradeNat","private","reserved"]))}(n))return x.HostBlocked;if(!t)return 0;if(-1!==G.stream_limit_total&&Object.keys(t.streams).length>=G.stream_limit_total)return x.ConnThrottled;if(-1!==G.stream_limit_per_host){let e=0;for(let i of t.streams)i.socket.hostname===s&&e++;if(e>=G.stream_limit_per_host)return x.ConnThrottled}return 0}class ft extends Error{}class wt{static buffer_size=128;constructor(t,e,s){this.stream_id=t,this.conn=e,this.socket=s,this.send_buffer=new K(wt.buffer_size),this.packets_sent=0}async setup(){await this.socket.connect(),this.tcp_to_ws().catch(t=>{W(`(${this.conn.conn_id}) a tcp/udp to ws task encountered an error - ${t}`),this.close()}),this.ws_to_tcp().catch(t=>{W(`(${this.conn.conn_id}) a ws to tcp/udp task encountered an error - ${t}`),this.close()})}async tcp_to_ws(){for(;;){let t=await this.socket.recv();if(null==t)break;this.socket.pause();let e=new _({type:y.type,stream_id:this.stream_id,payload:new y({data:new w(new Uint8Array(t))})});await this.conn.ws.send(e),this.socket.resume()}await this.conn.close_stream(this.stream_id,x.Voluntary)}async ws_to_tcp(){for(;;){let t=await this.send_buffer.get();if(null==t)break;if(await this.socket.send(t),this.packets_sent++,this.packets_sent%(wt.buffer_size/2)!=0)continue;let e=new _({type:v.type,stream_id:this.stream_id,payload:new v({buffer_remaining:wt.buffer_size-this.send_buffer.size})});this.conn.ws.send(e)}await this.close()}async close(t=null){if(this.send_buffer.close(),this.socket.close(),null==t)return;let e=new _({type:g.type,stream_id:this.stream_id,payload:new g({reason:t})});await this.conn.ws.send(e)}async put_data(t){await this.send_buffer.put(t)}}class _t{constructor(t,e,{TCPSocket:s,UDPSocket:i,ping_interval:n,wisp_version:r,wisp_extensions:o}={}){this.ws=new J(t),this.path=e,this.TCPSocket=s||rt,this.UDPSocket=i||ot,this.ping_interval=n||30,this.wisp_version=r||G.wisp_version,this.wisp_extensions=o||null,this.ping_task=null,this.streams={},this.conn_id=c.randomUUID().split("-")[0],this.server_exts={},this.client_exts={},2===this.wisp_version&&null===this.wisp_extensions&&this.add_extensions()}add_extensions(){this.wisp_extensions=[],G.allow_udp_streams&&this.wisp_extensions.push(new C({server_config:{}})),G.wisp_motd&&this.wisp_extensions.push(new D({server_config:{message:G.wisp_motd}}))}async setup(){L(`setting up new wisp v${this.wisp_version} connection with id ${this.conn_id}`),await this.ws.connect(),2==this.wisp_version&&await this.setup_wisp_v2();let t=new _({type:v.type,stream_id:0,payload:new v({buffer_remaining:wt.buffer_size})});this.ws.send(t),"function"==typeof this.ws.ws.ping&&(this.ping_task=setInterval(()=>{F(`(${this.conn_id}) sending websocket ping`),this.ws.ws.ping()},1e3*this.ping_interval))}async setup_wisp_v2(){let t=T(this.wisp_extensions),e=new _({type:b.type,stream_id:0,payload:new b({major_ver:this.wisp_version,minor_ver:0,extensions:t})});this.ws.send(e);let s=await this.ws.recv();if(null==s)throw H(`(${this.conn_id}) handshake error: ws closed before handshake complete`),await this.cleanup(),new ft;let i=new w(new Uint8Array(s)),n=_.parse_all(i);if(n.type!==b.type)throw H(`(${this.conn_id}) handshake error: unexpected packet of type ${n.type}`),await this.cleanup(),new ft;let r=S(n.payload.extensions,this.wisp_extensions,"client");for(let t of r)for(let e of this.wisp_extensions)e.id===t.id&&(this.server_exts[e.id]=e,this.client_exts[t.id]=t)}create_stream(t,e,s,i){let n=new(e===P.TCP?this.TCPSocket:this.UDPSocket)(s,i),r=new wt(t,this,n);this.streams[t]=r,(async()=>{let n=await dt(this,e,s,i);if(n)return H(`(${this.conn_id}) refusing to create a stream to ${s}:${i}`),void await this.close_stream(t,n,!0);try{await r.setup()}catch(e){H(`(${this.conn_id}) creating a stream to ${s}:${i} failed - ${e}`),await this.close_stream(t,x.NetworkError)}})()}async close_stream(t,e=null,s=!1){let i=this.streams[t];null!=i&&(e&&!s&&L(`(${this.conn_id}) closing stream to ${i.socket.hostname} for reason ${e}`),await i.close(e),delete this.streams[t])}route_packet(t){let e=_.parse_all(t),s=this.streams[e.stream_id];if(null!=s||e.type!=y.type)if(e.type===m.type){let t=e.payload.stream_type===P.TCP?"TCP":"UDP";L(`(${this.conn_id}) opening new ${t} stream to ${e.payload.hostname}:${e.payload.port}`),this.create_stream(e.stream_id,e.payload.stream_type,e.payload.hostname.trim(),e.payload.port)}else e.type===y.type?s.put_data(e.payload.data.bytes):e.type==v.type?H(`(${this.conn_id}) client sent a CONTINUE packet, this should never be possible`):e.type==g.type&&this.close_stream(e.stream_id,e.reason);else H(`(${this.conn_id}) received a DATA packet for a stream which doesn't exist`)}async run(){for(;;){let t;if(t=await this.ws.recv(),null==t)break;if("string"!=typeof t)try{this.route_packet(new w(new Uint8Array(t)))}catch(t){H(`(${this.conn_id}) routing a packet failed - ${t}`)}else H(`(${this.conn_id}) routing a packet failed - unexpected ws text frame`)}await this.cleanup()}async cleanup(){for(let t of Object.keys(this.streams))await this.close_stream(t);clearInterval(this.ping_task),L(`(${this.conn_id}) wisp connection closed`),this.ws.close()}}class mt{constructor(t,e){let[s,i]=e.split("/").pop().split(":");this.hostname=s.trim(),this.port=parseInt(i),this.ws=new J(t)}async setup(){if(await this.ws.connect(),0!==await dt(null,P.TCP,this.hostname,this.port))throw L(`Refusing to create a wsproxy connection to ${this.hostname}:${this.port}`),this.ws.close(),new ct;this.socket=new rt(this.hostname,this.port),await this.socket.connect(),this.tcp_to_ws().catch(t=>{W(`a tcp to ws task (wsproxy) encountered an error - ${t}`)}),this.ws_to_tcp().catch(t=>{W(`a ws to tcp task (wsproxy) encountered an error - ${t}`)})}async tcp_to_ws(){for(;;){let t=await this.socket.recv();if(null==t)break;this.socket.pause(),await this.ws.send(t),this.socket.resume()}await this.ws.close()}async ws_to_tcp(){for(;;){let t;if(t=await this.ws.recv(),null==t)break;await this.socket.send(t)}await this.socket.close()}}let yt=null;function vt(t,e){if(G.parse_real_ip&&G.parse_real_ip_from.includes(e)){if(t["x-forwarded-for"])return t["x-forwarded-for"].split(",")[0].trim();if(t["x-real-ip"])return t["x-real-ip"]}return e}function gt(t,e,s,i={}){tt(),t.headers["sec-websocket-protocol"]&&2===G.wisp_version?i.wisp_version=2:i.wisp_version=1,t instanceof l.IncomingMessage?yt.handleUpgrade(t,e,s,e=>{bt(e,t.url,t,i)}):t instanceof a&&bt(ws,"/",{})}async function bt(t,e,s,i){t.binaryType="arraybuffer";let n=s.socket.address().address;L(`new connection on ${e} from ${vt(s.headers,n)} (origin: ${s.headers.origin})`);try{if(e.endsWith("/")){let s=new _t(t,e,i);await s.setup(),await s.run()}else{let s=new mt(t,e,i);await s.setup()}}catch(e){if(t.close(),e instanceof ft)return;if(e instanceof ct)return;W("Uncaught server error:\n"+(e.stack||e))}}Q&&(yt=new null({noServer:!0}))})(),wisp_full=i})();
//# sourceMappingURL=wisp-full.js.map