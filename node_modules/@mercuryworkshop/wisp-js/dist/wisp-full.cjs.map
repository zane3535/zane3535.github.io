{"version":3,"file":"wisp-full.cjs","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA,MAAM,2BAA4B,iB;;ACAlC,MAAM,+BAA4B,qB;;ACAlC,MAAM,kCAA4B,wB;;ACAlC,MAAM,iCAA4B,uB;;ACAlC,MAAM,mCAA4B,yB;;ACAlC,MAAM,wBAA4B,gC;;ACAlC;AACA;;AAEO;;AAEyC;AACf;;AAEC;AACF;AACI;;;ACVpC;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA,eAAe,yCAAyC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;ACzO0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA,eAAe,8BAA8B,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,gCAAgC,UAAU;AAC1C,gCAAgC,UAAU;AAC1C,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,C;;ACxJwC;;AAYjB;;AAEiF;;AAExG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,YAAY;AAC/E;AACA,uBAAuB,UAAU;AACjC,cAAc,YAAY;AAC1B;AACA,qBAAqB,WAAW;AAChC,oBAAoB,UAAU;AAC9B,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,YAAY,YAAY;AACxB;AACA,mBAAmB,YAAY;AAC/B;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP,yBAAyB,+BAA+B,IAAI;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC,YAAY,EAAE,kBAAkB;AAClE,kCAAkC,aAAa,EAAE,kBAAkB;AACnE;;AAEA;AACA;AACA,kBAAkB,qCAAgB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,YAAY,OAAO,YAAY;;AAEpE,uBAAuB,YAAY;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B,YAAY,YAAY;AACxB;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B,sBAAsB,UAAU;AAChC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,aAAa;AACzD,8CAA8C,YAAY;;AAE1D,yBAAyB,oBAAoB;AAC7C,8BAA8B,UAAU;AACxC,gBAAgB,WAAW;AAC3B;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,cAAc,oBAAoB;AACxF;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;;AAEA,6BAA6B,YAAY,aAAa;AACtD;AACA;;AAEA,6BAA6B,YAAY;AACzC;AACA;;AAEA;AACA,8EAA8E,YAAY;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpQ4C;AACQ;;AAEpD;;AAEA,wBAAwB,WAAW;AAC5B;;AAEA;AACP,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;ACtKoD;;;ACA7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACP;AACA;AACA;AACA,aAAa,MAAM,IAAI,KAAK;AAC5B;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO,SAAS,aAAK;AACrB;AACA;AACA;;;;ACzCO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AC/BA;;AAEuC;AACG;;AAEnC;AACP,SAAS,0CAAwB;AACjC;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,UAAU;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wBAAwB;AAC9D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;ACjI0C;AACI;AACN;AACQ;;AAEhD;AACA;;AAEO;;AAEP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,OAAO;AACb,uBAAuB,+BAAU,YAAY,OAAO,OAAO,kBAAkB;AAC7E;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA,kCAAkC,iCAAY;;AAE9C;AACA,QAAQ,OAAO;AACf,MAAM,KAAa,qCAAqC,OAAO;AAC/D,0BAA0B,OAAO;AACjC,oBAAoB,OAAO;AAC3B;;AAEA,QAAQ,OAAO,oCAAoC,OAAO;AAC1D;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB,iBAAiB,OAAO;AACxB;;AAEA;AACA;;AAEA;AACO;AACP,kBAAkB;AAClB;AACA;;AAEA,iBAAiB,sCAAQ;AACzB;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,KAAa,qBAAqB,UAAU,KAAK,QAAQ;AAC7D,6BAA6B,mCAAmC;AAChE;AACA;AACA,6BAA6B,2BAA2B;AACxD;AACA;;AAEA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;;AAEA;AACA;AACA;AACA,wBAAwB,wCAAU;AAClC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,QAAQ,IAAY,kBAAkB,eAAe,qBAAqB,MAAM;AAChF,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,UAAU;AACpC;;AAEA;AACA;AACA,mBAAmB,sCAAQ;AAC3B;AACA,oBAAoB,gDAAkB;AACtC;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;AChPA,MAAM,kCAA4B,wB;;ACA0B;AACpB;AACP;;AAEF;;AAExB;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACO;AACP,OAAO,0CAAc;AACrB;AACA,WAAW,wCAAY;;AAEvB;AACA;;AAEA,OAAO,OAAO;AACd;AACA,OAAO,OAAO;AACd;AACA;AACA;;AAEA;AACO;AACP;AACA,OAAO,OAAO,+BAA+B,YAAY;AACzD,WAAW,aAAa;AACxB,OAAO,OAAO,+BAA+B,YAAY;AACzD,WAAW,aAAa;;AAExB;AACA,MAAM,OAAO;AACb,wBAAwB,OAAO;AAC/B,aAAa,aAAa;AAC1B;AACA,WAAW,OAAO;AAClB,wBAAwB,OAAO;AAC/B,aAAa,aAAa;AAC1B;;AAEA;AACA,MAAM,OAAO;AACb,wBAAwB,OAAO;AAC/B,aAAa,aAAa;AAC1B;AACA,WAAW,OAAO;AAClB,wBAAwB,OAAO;AAC/B,aAAa,aAAa;AAC1B;;AAEA;AACA;AACA,MAAM,0CAAc;AACpB,SAAS,OAAO;AAChB,aAAa,aAAa;AAC1B;AACA;AACA,UAAU;AACV,qBAAqB,SAAa;AAClC;AACA;AACA;AACA;AACA,WAAW,aAAa;;AAExB;AACA;AACA;;AAEA;AACA,MAAM,OAAO,wEAAwE,OAAO;AAC5F,WAAW,aAAa;AACxB,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,aAAa,aAAa;AAC1B;;AAEA;AACA,C;;AChH0C;AACH;AACoC;AAClB;AAWlC;AACiB;AACgE;;AAEjG;;AAEA;AACP;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM,aAAa,KAAK,kBAAkB,gDAAgD,MAAM;AAChG;AACA,KAAK;AACL;AACA,MAAM,aAAa,KAAK,kBAAkB,gDAAgD,MAAM;AAChG;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,UAAU;AACjC,cAAc,WAAW;AACzB;AACA,qBAAqB,WAAW;AAChC,oBAAoB,UAAU;AAC9B,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC,cAAc,eAAe;AAC7B;AACA,qBAAqB,eAAe;AACpC;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,UAAU;AAC/B,YAAY,YAAY;AACxB;AACA,mBAAmB,YAAY;AAC/B;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP,yBAAyB,oEAAoE,IAAI;AACjG,kBAAkB,cAAc;AAChC;AACA,kCAAkC,aAAa;AAC/C,kCAAkC,aAAa;AAC/C;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,mBAAmB,WAAW;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,OAAO;AACf,oCAAoC,YAAY,EAAE,kBAAkB;AACpE,QAAQ,OAAO;AACf,oCAAoC,aAAa,EAAE;AACnD,iBAAiB,OAAO;AACxB,QAAQ;AACR;;AAEA;AACA,IAAI,IAAY,yBAAyB,mBAAmB,qBAAqB,aAAa;;AAE9F;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,UAAU;AACxC,YAAY,eAAe;AAC3B;AACA,mBAAmB,eAAe;AAClC;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,QAAQ,KAAa,KAAK,aAAa;AACvC;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,qBAAqB,oBAAoB;AACzC,0BAA0B,UAAU;AACpC,YAAY,WAAW;AACvB;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,MAAM,IAAY,KAAK,aAAa;AACpC;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,iBAAiB,UAAU;;AAE3B,wBAAwB,WAAW;AACnC,MAAM,IAAY,KAAK,aAAa,+CAA+C,YAAY;AAC/F;AACA;AACA;;AAEA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,iBAAwB;AACvD;AACA,QAAQ,IAAY,KAAK,aAAa,mCAAmC,SAAS,GAAG,KAAK;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAY,KAAK,aAAa,yBAAyB,SAAS,GAAG,MAAM,WAAW,MAAM;AAClG,2CAA2C,aAAa;AACxD;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,IAAY,KAAK,aAAa,sBAAsB,wBAAwB,aAAa,OAAO;AACtG;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,UAAU;AAC3B;;AAEA,yCAAyC,WAAW;AACpD,MAAM,IAAY,KAAK,aAAa;AACpC;AACA;;AAEA,wBAAwB,cAAc;AACtC,qDAAqD,YAAY;AACjE,MAAM,IAAY,KAAK,aAAa,gBAAgB,WAAW,YAAY,wBAAwB,GAAG,oBAAoB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,WAAW;AACxC;AACA;;AAEA,4BAA4B,eAAe;AAC3C,MAAM,IAAY,KAAK,aAAa;AACpC;;AAEA,4BAA4B,YAAY;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,QAAQ,IAAY,KAAK,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,QAAQ,IAAY,KAAK,aAAa,8BAA8B,MAAM;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAY,KAAK,aAAa;AAClC;AACA;AACA,C;;ACxT0C;AACH;AACM;AACK;AACR;;AAEnC;AACP;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;;AAEA;AACA;;AAEA;AACA,yBAAyB,iBAAwB,OAAO,YAAY;AACpE;AACA,MAAM,IAAY,+CAA+C,cAAc,GAAG,UAAU;AAC5F;AACA,gBAAgB,iBAAwB;AACxC;;AAEA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA,MAAM,aAAa,sDAAsD,MAAM;AAC/E,KAAK;AACL;AACA,MAAM,aAAa,sDAAsD,MAAM;AAC/E,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,C;;AC9D0C;AACF;;AAEA;AACS;AACmB;AAClB;AACE;;AAEpD;AACA,IAAI,OAAO;AACX,kBAAkB,2CAAsB,GAAG,gBAAgB;AAC3D;;AAEO;AACP,MAAM,OAAO,kBAAkB,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,4DAA4D;AACnE,EAAE,cAAc;AAChB,mDAAmD,OAAO;AAC1D;AACA;AACA;;AAEA,yBAAyB,kDAA2B;AACpD;AACA;AACA,KAAK;AACL;AACA,8BAA8B,qCAAgB;AAC9C,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAY,sBAAsB,MAAM,OAAO,SAAS,WAAW,OAAO;AAC5E;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,cAAc;AACvC,yBAAyB,iBAAiB;AAC1C,IAAI,aAAa;AACjB;AACA,C;;ACrEiE;AACR;;;ACDZ;AACA;AACN","sources":["webpack://@mercuryworkshop/wisp-js/webpack/bootstrap","webpack://@mercuryworkshop/wisp-js/webpack/runtime/define property getters","webpack://@mercuryworkshop/wisp-js/webpack/runtime/hasOwnProperty shorthand","webpack://@mercuryworkshop/wisp-js/webpack/runtime/make namespace object","webpack://@mercuryworkshop/wisp-js/external commonjs \"ws\"","webpack://@mercuryworkshop/wisp-js/external commonjs \"crypto\"","webpack://@mercuryworkshop/wisp-js/external node-commonjs \"node:http\"","webpack://@mercuryworkshop/wisp-js/external node-commonjs \"node:net\"","webpack://@mercuryworkshop/wisp-js/external node-commonjs \"node:dgram\"","webpack://@mercuryworkshop/wisp-js/external node-commonjs \"node:dns/promises\"","webpack://@mercuryworkshop/wisp-js/./src/compat.mjs","webpack://@mercuryworkshop/wisp-js/./src/packet.mjs","webpack://@mercuryworkshop/wisp-js/./src/extensions.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/connection.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/polyfill.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/index.mjs","webpack://@mercuryworkshop/wisp-js/./src/logging.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/options.mjs","webpack://@mercuryworkshop/wisp-js/./src/websocket.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/net.mjs","webpack://@mercuryworkshop/wisp-js/external commonjs \"ipaddr.js\"","webpack://@mercuryworkshop/wisp-js/./src/server/filter.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/connection.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/wsproxy.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/http.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/index.mjs","webpack://@mercuryworkshop/wisp-js/./src/index.mjs"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"ws\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"crypto\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:http\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:net\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:dgram\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:dns/promises\");","//this file contains references to external node modules\n//it gets replaced with ./compat_browser.mjs when being bundled for the web\n\nexport const global_this = globalThis;\n\nexport { WebSocket, WebSocketServer } from \"ws\";\nexport * as crypto from \"crypto\";\n\nexport * as http from \"node:http\";\nexport * as net from \"node:net\";\nexport * as dgram from \"node:dgram\";\nexport * as dns from \"node:dns/promises\";","//shared packet parsing / serialization code\n\nconst text_encoder = new TextEncoder();\nconst encode_text = text_encoder.encode.bind(text_encoder);\nconst text_decoder = new TextDecoder();\nconst decode_text = text_decoder.decode.bind(text_decoder);\n\nexport class WispBuffer {\n  constructor(data) {\n    if (data instanceof Uint8Array) {\n      this.from_array(data);\n    }\n    else if (typeof data === \"number\") {\n      this.from_array(new Uint8Array(data));\n    }\n    else if (typeof data === \"string\") {\n      this.from_array(encode_text(data));\n    }\n    else {\n      console.trace();\n      throw \"invalid data type passed to wisp buffer constructor\";\n    }\n  }\n\n  from_array(bytes) {\n    this.size = bytes.length;\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer); \n  }\n\n  concat(buffer) {\n    let new_buffer = new WispBuffer(this.size + buffer.size);\n    new_buffer.bytes.set(this.bytes, 0);\n    new_buffer.bytes.set(buffer.bytes, this.size);\n    return new_buffer;\n  }\n\n  slice(index, size) {\n    let bytes_slice = this.bytes.slice(index, size);\n    return new WispBuffer(bytes_slice);\n  }\n\n  get_string() {\n    return text_decoder.decode(this.bytes);\n  }\n}\n\nexport class WispPacket {\n  static min_size = 5;\n  constructor({type, stream_id, payload, payload_bytes }) {\n    this.type = type;\n    this.stream_id = stream_id;\n    this.payload_bytes = payload_bytes;\n    this.payload = payload;\n  }\n  static parse(buffer) {\n    return new WispPacket({\n      type: buffer.view.getUint8(0),\n      stream_id: buffer.view.getUint32(1, true),\n      payload_bytes: buffer.slice(5)\n    });\n  }\n  static parse_all(buffer) {\n    if (buffer.size < WispPacket.min_size) {\n      throw TypeError(\"packet too small\");\n    }\n    let packet = WispPacket.parse(buffer);\n    let payload_class = packet_classes[packet.type];\n    if (typeof payload_class === \"undefined\") {\n      throw TypeError(\"invalid packet type\");\n    }\n    if (packet.payload_bytes.size < payload_class.size) {\n      throw TypeError(\"payload too small\");\n    }\n    packet.payload = payload_class.parse(packet.payload_bytes);\n    return packet;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    buffer.view.setUint8(0, this.type);\n    buffer.view.setUint32(1, this.stream_id, true);\n    buffer = buffer.concat(this.payload.serialize());\n    return buffer;\n  }\n}\n\nexport class ConnectPayload {\n  static min_size = 3;\n  static type = 0x01;\n  static name = \"CONNECT\";\n  constructor({stream_type, port, hostname}) {\n    this.stream_type = stream_type;\n    this.port = port;\n    this.hostname = hostname;\n  }\n  static parse(buffer) {\n    return new ConnectPayload({\n      stream_type: buffer.view.getUint8(0),\n      port: buffer.view.getUint16(1, true),\n      hostname: decode_text(buffer.slice(3).bytes)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(3);\n    buffer.view.setUint8(0, this.stream_type);\n    buffer.view.setUint16(1, this.port, true);\n    buffer = buffer.concat(new WispBuffer(this.hostname));\n    return buffer;\n  }\n}\n\nexport class DataPayload {\n  static min_size = 0;\n  static type = 0x02;\n  static name = \"DATA\";\n  constructor({data}) {\n    this.data = data;\n  }\n  static parse(buffer) {\n    return new DataPayload({\n      data: buffer\n    });\n  }\n  serialize() {\n    return this.data;\n  }\n}\n\nexport class ContinuePayload {\n  static type = 0x03;\n  static name = \"CONTINUE\";\n  constructor({buffer_remaining}) {\n    this.buffer_remaining = buffer_remaining;\n  }\n  static parse(buffer) {\n    return new ContinuePayload({\n      buffer_remaining: buffer.view.getUint32(0, true),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(4);\n    buffer.view.setUint32(0, this.buffer_remaining, true);\n    return buffer;\n  }\n}\n\nexport class ClosePayload {\n  static min_size = 1;\n  static type = 0x04;\n  static name = \"CLOSE\";\n  constructor({reason}) {\n    this.reason = reason;\n  }\n  static parse(buffer) {\n    return new ClosePayload({\n      reason: buffer.view.getUint8(0),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(1);\n    buffer.view.setUint8(0, this.reason);\n    return buffer;\n  }\n}\n\nexport class InfoPayload {\n  static min_size = 2;\n  static type = 0x05;\n  static name = \"INFO\";\n  constructor({major_ver, minor_ver, extensions}) {\n    this.major_ver = major_ver;\n    this.minor_ver = minor_ver;\n    this.extensions = extensions;\n  }\n  static parse(buffer) {\n    return new InfoPayload({\n      major_ver: buffer.view.getUint8(0),\n      minor_ver: buffer.view.getUint8(1),\n      extensions: buffer.slice(2)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(2);\n    buffer.view.setUint8(0, this.major_ver);\n    buffer.view.setUint8(1, this.minor_ver);\n    return buffer.concat(this.extensions);\n  }\n}\n\nexport const packet_classes = {\n  0x01: ConnectPayload, \n  0x02: DataPayload, \n  0x03: ContinuePayload, \n  0x04: ClosePayload,\n  0x05: InfoPayload\n}\n\nexport const packet_types = {\n  CONNECT: 0x01,\n  DATA: 0x02,\n  CONTINUE: 0x03,\n  CLOSE: 0x04,\n  INFO: 0x05\n}\n\nexport const stream_types = {\n  TCP: 0x01,\n  UDP: 0x02\n}\n\nexport const close_reasons = {\n  //client/server close reasons\n  Unknown: 0x01,\n  Voluntary: 0x02,\n  NetworkError: 0x03,\n  IncompatibleExtensions: 0x04,\n\n  //server only close reasons\n  InvalidInfo: 0x41, \n  UnreachableHost: 0x42,\n  NoResponse: 0x43,\n  ConnRefused: 0x44,\n  TransferTimeout: 0x47,\n  HostBlocked: 0x48,\n  ConnThrottled: 0x49,\n\n  //client only close reasons\n  ClientError: 0x81,\n\n  //extension specific close reasons\n  AuthBadPassword: 0xc0,\n  AuthBadSignature: 0xc1,\n  AuthMissingCredentials: 0xc2\n}","import { WispBuffer } from \"./packet.mjs\";\n\nclass EmptyPayload {\n  constructor() {}\n  static parse() {\n    return new EmptyPayload();\n  }\n  serialize() {\n    return new WispBuffer(0);\n  }\n}\n\nexport class BaseExtension {\n  static id = 0x00;\n  static name = \"\";\n\n  static Server = EmptyPayload;\n  static Client = EmptyPayload;\n\n  constructor({server_config, client_config} = {}) {\n    this.id = this.constructor.id;\n    this.name = this.constructor.name;\n    if (server_config)\n      this.payload = new this.constructor.Server(server_config);\n    else if (client_config)\n      this.payload = new this.constructor.Client(client_config);\n  }\n  static parse(ext_class, buffer, role) {\n    let extension = new ext_class({});\n    if (role === \"client\")\n      extension.payload = ext_class.Client.parse(buffer.slice(5));\n    else if (role === \"server\")\n      extension.payload = ext_class.Server.parse(buffer.slice(5));\n    else \n      throw TypeError(\"invalid role\");\n    return extension;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    let payload_buffer = this.payload.serialize();\n    buffer.view.setInt8(0, this.constructor.id);\n    buffer.view.setUint32(1, payload_buffer.size, true);\n    return buffer.concat(payload_buffer);\n  }\n}\n\nexport class UDPExtension extends BaseExtension {\n  static id = 0x01;\n  static name = \"UDP\";\n}\n\nexport class PasswordAuthExtension extends BaseExtension {\n  static id = 0x02;\n  static name = \"Password Authentication\";\n\n  static Server = class {\n    constructor({required = 1}) {\n      this.required = required ? 1 : 0;\n    }\n    static parse(buffer) {\n      return new PasswordAuthExtension.Server({\n        required: buffer.view.getUint8(0)\n      });\n    }\n    serialize() {\n      let buffer = new WispBuffer(1);\n      buffer.view.setUint8(0, this.required);\n      return buffer;\n    }\n  }\n\n  static Client = class {\n    constructor({username, password}) {\n      this.username = username;\n      this.password = password;\n    }\n    static parse(buffer) {\n      let username_len = buffer.view.getUint8(0);\n      let password_len = buffer.view.getUint16(1, true);\n      let password_index = username_len + 3;\n      return new PasswordAuthExtension.Client({\n        username: buffer.slice(3, username_len).get_string(),\n        password: buffer.slice(password_index, password_len).get_string()\n      });\n    }\n    serialize() {\n      let username_buffer = new WispBuffer(this.username);\n      let password_buffer = new WispBuffer(this.password);\n      let buffer = new WispBuffer(3);\n      buffer.view.setUint8(0, username_buffer.size);\n      buffer.view.setUint16(1, password_buffer.size, true);\n      return buffer.concat(username_buffer).concat(password_buffer);\n    }\n  }\n}\n\nexport class MOTDExtension extends BaseExtension {\n  static id = 0x04;\n  static name = \"Server MOTD\";\n\n  static Server = class {\n    constructor({message}) {\n      this.message = message;\n    }\n    static parse(buffer) {\n      return new MOTDExtension.Server({\n        message: buffer.get_string()\n      });\n    }\n    serialize() {\n      return new WispBuffer(this.message);\n    }\n  }\n\n  static Client = EmptyPayload;\n}\n\nexport function parse_extensions(payload_buffer, valid_extensions, role) {\n  let index = 0;\n  let parsed_extensions = [];\n  while (payload_buffer.size) {\n    let ext_id = payload_buffer.view.getUint8(index);\n    let ext_len = payload_buffer.view.getUint32(index + 1, true);\n    let ext_payload = payload_buffer.slice(0, 5 + ext_len);\n    let ext_class;\n    for (let extension of valid_extensions) {\n      if (extension.id !== ext_id) \n        continue;\n      ext_class = extension.constructor;\n      break;\n    }\n    if (ext_class) {\n      let ext_parsed = BaseExtension.parse(ext_class, ext_payload, role);\n      parsed_extensions.push(ext_parsed);\n    }\n    payload_buffer = payload_buffer.slice(5 + ext_len);\n  }\n  return parsed_extensions;\n}\n\nexport function serialize_extensions(extensions) {{\n  let ext_buffer = new WispBuffer(0);\n  for (let extension of extensions) {\n    ext_buffer = ext_buffer.concat(extension.serialize());\n  }\n  return ext_buffer;\n}}\n\nexport const extensions_map = {\n  0x01: UDPExtension,\n  0x02: PasswordAuthExtension,\n  0x04: MOTDExtension\n}","import * as compat from \"../compat.mjs\";\n\nimport {\n  packet_classes,\n  packet_types,\n  stream_types,\n  WispBuffer, \n  WispPacket, \n  ConnectPayload, \n  DataPayload, \n  ClosePayload,\n  InfoPayload\n} from \"../packet.mjs\";\n\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nclass ClientStream {\n  constructor(hostname, port, websocket, buffer_size, stream_id, connection, stream_type) {\n    this.hostname = hostname;\n    this.port = port;\n    this.ws = websocket;\n    this.buffer_size = buffer_size;\n    this.stream_id = stream_id;\n    this.connection = connection;\n    this.stream_type = stream_type;\n    this.send_buffer = [];\n    this.open = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onmessage = () => {};\n  }\n\n  send(data) {\n    //note: udp shouldn't buffer anything\n    if (this.buffer_size > 0 || !this.open || this.stream_type === stream_types.UDP) {\n      //construct and send a DATA packet\n      let packet = new WispPacket({\n        type: packet_types.DATA,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(data)\n        })\n      });\n      this.ws.send(packet.serialize().bytes);\n      this.buffer_size--;\n    }\n    else { //server is slow, don't send data yet\n      this.send_buffer.push(data);\n    }\n  }\n\n  //handle receiving a CONTINUE packet\n  continue_received(buffer_size) {\n    this.buffer_size = buffer_size;\n    //send buffered data now\n    while (this.buffer_size > 0 && this.send_buffer.length > 0) {\n      this.send(this.send_buffer.shift());\n    }\n  }\n\n  //construct and send a CLOSE packet\n  close(reason = 0x01) {\n    if (!this.open) return;\n    let packet = new WispPacket({\n      type: packet_types.CLOSE,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    this.open = false;\n    delete this.connection.active_streams[this.stream_id];\n  }\n}\n\nexport class ClientConnection {\n  constructor(wisp_url, {wisp_version, wisp_extensions} = {}) {\n    if (!wisp_url.endsWith(\"/\")) {\n      throw new TypeError(\"wisp endpoints must end with a trailing forward slash\");\n    }\n\n    this.wisp_url = wisp_url;\n    this.wisp_version = wisp_version || 2;\n    this.wisp_extensions = wisp_extensions || null;\n\n    this.max_buffer_size = null;\n    this.active_streams = {};\n    this.connected = false;\n    this.connecting = false;\n    this.next_stream_id = 1;\n\n    this.server_exts = {};\n    this.client_exts = {};\n    this.info_received = false;\n    this.server_motd = null;\n    this.udp_enabled = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n\n    this.connect_ws();\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    this.wisp_extensions.push(new UDPExtension({client_config: {}}));\n    this.wisp_extensions.push(new MOTDExtension({client_config: {}}));\n  }\n\n  connect_ws() {\n    let subprotocol = this.wisp_version === 2 ? \"wisp-v2\" : undefined;\n    this.ws = new compat.WebSocket(this.wisp_url, subprotocol);\n    this.ws.binaryType = \"arraybuffer\";\n    this.connecting = true;\n\n    this.ws.onerror = () => {\n      if (this.wisp_version === 2) {\n        this.ws.onclose = null;\n        this.cleanup();\n        this.wisp_version = 1;\n        this.connect_ws();\n        return;\n      }\n      this.cleanup();\n      this.onerror();\n    };\n    this.ws.onclose = () => {\n      this.cleanup();\n      this.onclose();\n    };\n    this.ws.onmessage = (event) => {\n      this.on_ws_msg(event);\n      if (this.connected && this.connecting) {\n        this.connecting = false;\n        this.onopen();\n      }\n    };\n  }\n\n  close() {\n    this.ws.close();\n  }\n\n  create_stream(hostname, port, type=0x01) {\n    let stream_type = type;\n    if (typeof stream_type === \"string\") \n      stream_type = type === \"udp\" ? stream_types.UDP : stream_types.TCP;\n\n    if (stream_type == stream_types.UDP && !this.udp_enabled) {\n      throw new Error(\"udp is not enabled for this wisp connection\");\n    }\n\n    let stream_id = this.next_stream_id++;\n    let stream = new ClientStream(hostname, port, this.ws, this.max_buffer_size, stream_id, this, stream_type);\n    this.active_streams[stream_id] = stream;\n    stream.open = this.connected;\n\n    //construct CONNECT packet\n    let packet = new WispPacket({\n      type: packet_types.CONNECT,\n      stream_id: stream_id,\n      payload: new ConnectPayload({\n        stream_type: stream_type,\n        port: port,\n        hostname: hostname\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    return stream;\n  }\n\n  close_stream(stream, reason) {\n    stream.onclose(reason);\n    delete this.active_streams[stream.stream_id];\n  }\n\n  on_ws_msg(event) {\n    let buffer = new WispBuffer(new Uint8Array(event.data));\n    if (buffer.size < WispPacket.min_size) {\n      console.warn(`wisp client warning: received a packet which is too short`);\n      return;\n    }\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.active_streams[packet.stream_id];\n    if (packet.stream_id === 0 && this.connecting) {\n      if (packet.type === packet_types.CONTINUE) {\n        this.max_buffer_size = packet.payload.buffer_remaining;\n        this.connected = true;\n        if (!this.info_received) {\n          this.wisp_version = 1;\n        }\n      }\n      \n      if (packet.type === packet_types.INFO && this.wisp_version === 2) {\n        let server_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"server\");\n        for (let server_ext of server_extensions) {\n          for (let client_ext of this.wisp_extensions) {\n            if (server_ext.id === client_ext.id) {\n              this.server_exts[server_ext.id] = server_ext;\n              this.client_exts[client_ext.id] = client_ext;\n            }\n          }\n        }\n\n        this.info_received = true; \n        this.server_motd = this.server_exts[MOTDExtension.id]?.payload?.message;\n        this.udp_enabled = !!this.server_exts[UDPExtension.id];\n\n        let ext_buffer = serialize_extensions(this.wisp_extensions);\n        let info_packet = new WispPacket({\n          type: InfoPayload.type,\n          stream_id: 0,\n          payload: new InfoPayload({\n            major_ver: this.wisp_version,\n            minor_ver: 0,\n            extensions: ext_buffer\n          })\n        });\n        this.ws.send(info_packet.serialize().bytes);\n      }\n      return;\n    }\n\n    if (typeof stream === \"undefined\") {\n      console.warn(`wisp client warning: received a ${packet_classes[packet.type].name} packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === packet_types.DATA) {\n      stream.onmessage(packet.payload_bytes.bytes);\n    }\n\n    else if (packet.type === packet_types.CONTINUE) { //other CONTINUE packets\n      stream.continue_received(packet.payload.buffer_remaining);\n    }\n\n    else if (packet.type === packet_types.CLOSE) {\n      this.close_stream(stream, packet.payload.reason);\n    }\n\n    else {\n      console.warn(`wisp client warning: received an invalid packet of type ${packet.type}`);\n    }\n  }\n\n  cleanup() {\n    this.connected = false;\n    this.connecting = false;\n    for (let stream_id of Object.keys(this.active_streams)) {\n      this.close_stream(this.active_streams[stream_id], 0x03);\n    }\n  }\n}\n\n","import { global_this } from \"../compat.mjs\";\nimport { ClientConnection } from \"./connection.mjs\";\n\n//polyfill the DOM Websocket API so that applications using wsproxy can easily use wisp with minimal changes\n\nconst RealCloseEvent = (global_this.CloseEvent || Event);\nexport const _wisp_connections = {};\n\nexport class WispWebSocket extends EventTarget {\n  constructor(url, protocols=null, options = {}) {\n    super();\n    this.url = url;\n    this.protocols = protocols;\n    this.options = options;\n    this.binaryType = \"blob\";\n    this.stream = null;\n    this.connection = null;\n\n    //legacy event handlers\n    this.onopen = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n    this.onclose = () => {};\n\n    this.CONNECTING = 0;\n    this.OPEN = 1;\n    this.CLOSING = 2;\n    this.CLOSED = 3;\n    this._ready_state = this.CONNECTING;\n\n    //parse the wsproxy url\n    let url_split = this.url.split(\"/\");\n    let wsproxy_path = url_split.pop().split(\":\");\n    this.host = wsproxy_path[0];\n    this.port = parseInt(wsproxy_path[1]);\n    this.real_url = url_split.join(\"/\") + \"/\";\n\n    this.init_connection();\n  }\n\n  on_conn_close() {\n    this._ready_state = this.CLOSED;\n    if (_wisp_connections[this.real_url]) {\n      this.onerror(new Event(\"error\"));\n      this.dispatchEvent(new Event(\"error\"));\n    }\n    delete _wisp_connections[this.real_url];\n  }\n\n  init_connection() {\n    //create the stream\n    this.connection = _wisp_connections[this.real_url];\n\n    if (!this.connection) {\n      this.connection = new ClientConnection(this.real_url, this.options);\n      this.connection.onopen = () => {\n        this.init_stream();\n      };\n      this.connection.onclose = () => {\n        this.on_conn_close()\n      };\n      this.connection.onerror = () => {\n        this.on_conn_close()\n      };\n      _wisp_connections[this.real_url] = this.connection;\n    }\n    else if (!this.connection.connected) {\n      let old_onopen = this.connection.onopen;\n      this.connection.onopen = () => {\n        old_onopen();\n        this.init_stream();\n      };\n    }\n    else {\n      this.connection = _wisp_connections[this.real_url];\n      this.init_stream();\n    }\n  }\n\n  init_stream() {\n    this._ready_state = this.OPEN;\n    this.stream = this.connection.create_stream(this.host, this.port);\n\n    this.stream.onmessage = (raw_data) => {\n      let data;\n      if (this.binaryType == \"blob\") {\n        data = new Blob(raw_data);\n      }\n      else if (this.binaryType == \"arraybuffer\") {\n        data = raw_data.buffer;\n      }\n      else {\n        throw \"invalid binaryType string\";\n      }\n      let msg_event = new MessageEvent(\"message\", {data: data});\n      this.onmessage(msg_event);\n      this.dispatchEvent(msg_event);\n    };\n\n    this.stream.onclose = (reason) => {\n      this._ready_state = this.CLOSED;\n      let close_event = new RealCloseEvent(\"close\", {code: reason}); \n      this.onclose(close_event);\n      this.dispatchEvent(close_event);\n    };\n\n    let open_event = new Event(\"open\");\n    this.onopen(open_event);\n    this.dispatchEvent(open_event);\n  }\n\n  send(data) {\n    let data_array;\n\n    if (data instanceof Uint8Array) {\n      data_array = data;  \n    }\n    else if (typeof data === \"string\") {\n      data_array = new TextEncoder().encode(data);\n    }\n    else if (data instanceof Blob) {\n      data.arrayBuffer().then(array_buffer => {\n        this.send(array_buffer);\n      });\n      return;\n    }\n    else if (data instanceof ArrayBuffer) {\n      data_array = new Uint8Array(data);\n    }\n    //dataview objects or any other typedarray\n    else if (ArrayBuffer.isView(data)) {\n      data_array = new Uint8Array(data.buffer);\n    }\n    else {\n      throw \"invalid data type to be sent\";\n    }\n\n    if (!this.stream) {\n      throw \"websocket is not ready\";\n    }\n    this.stream.send(data_array);\n  }\n\n  close() {\n    this.stream.close(0x02);\n  }\n\n  get bufferedAmount() {\n    let total = 0;\n    for (let msg of this.stream.send_buffer) {\n      total += msg.length;\n    }\n    return total;\n  }\n\n  get extensions() {\n    return \"\";\n  }\n\n  get protocol() {\n    return \"binary\";\n  }\n\n  get readyState() {\n    return this._ready_state;\n  }\n}","export { ClientConnection } from \"./connection.mjs\";\nexport { WispWebSocket, _wisp_connections } from \"./polyfill.mjs\";","export const DEBUG = 0;\nexport const INFO = 1;\nexport const WARN = 2;\nexport const ERROR = 3;\nexport const NONE = 4;\nexport let log_level = INFO;\n\nexport function get_timestamp() {\n  let [date, time] = new Date().toJSON().split(\"T\");\n  date = date.replaceAll(\"-\", \"/\");\n  time = time.split(\".\")[0];\n  return `[${date} - ${time}]`;\n}\n\nexport function set_level(level) {\n  log_level = level;\n}\n\nexport function debug(...messages) {\n  if (log_level > DEBUG) return;\n  console.debug(get_timestamp() + \" debug:\", ...messages);\n}\n\nexport function info(...messages) {\n  if (log_level > INFO) return;\n  console.info(get_timestamp() + \" info:\", ...messages);\n}\n\nexport function log(...messages) {\n  if (log_level > INFO) return;\n  console.log(get_timestamp() + \" log:\", ...messages);\n}\n\nexport function warn(...messages) {\n  if (log_level > WARN) return;\n  console.warn(get_timestamp() + \" warn:\", ...messages);\n}\n\nexport function error(...messages) {\n  if (log_level > ERROR) return;\n  console.error(get_timestamp() + \" error:\", ...messages);\n}\n\n","export const options = {\n  //destination hostname restrictions\n  hostname_blacklist: null,\n  hostname_whitelist: null,\n  port_blacklist: null,\n  port_whitelist: null,\n  allow_direct_ip: true,\n  allow_private_ips: false,\n  allow_loopback_ips: false,\n  \n  //client connection restrictions\n  client_ip_blacklist: null, //not implemented!\n  client_ip_whitelist: null, //not implemented!\n  stream_limit_per_host: -1,\n  stream_limit_total: -1,\n  allow_udp_streams: true,\n  allow_tcp_streams: true,\n\n  //dns options\n  dns_ttl: 120,\n  dns_method: \"lookup\",\n  dns_servers: null,\n  dns_result_order: \"verbatim\",\n\n  //misc options\n  parse_real_ip: true,\n  parse_real_ip_from: [\"127.0.0.1\"],\n\n  //wisp v2 options\n  wisp_version: 2,\n  wisp_motd: null\n}\n\n","//async websocket wrapper for both node and the browser\n\nimport * as compat from \"./compat.mjs\";\nimport { WispPacket } from \"./packet.mjs\";\n\nexport function get_conn_id() {\n  return compat.crypto.randomUUID().split(\"-\")[0];\n}\n\n//an async websocket wrapper\nexport class AsyncWebSocket {\n  send_buffer_size = 32*1024*1024;\n  \n  constructor(ws) {\n    this.ws = ws;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(1);\n  }\n\n  async connect() {\n    await new Promise((resolve, reject) => {\n      this.ws.onopen = () => {\n        this.connected = true;\n        resolve();\n      }\n      this.ws.onmessage = (event) => {\n        this.data_queue.put(event.data);\n      }\n      this.ws.onclose = () => {\n        if (!this.connected) reject();\n        else this.data_queue.close();\n      }\n      if (this.ws.readyState === this.ws.OPEN) {\n        this.connected = true;\n        resolve();\n      }\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    if (data instanceof WispPacket) {\n      data = data.serialize().bytes\n    }\n\n    this.ws.send(data);\n    if (this.ws.bufferedAmount <= this.send_buffer_size) {\n      return;\n    }\n\n    //if the send buffer is too full, throttle the upload\n    while (true) {\n      if (this.ws.bufferedAmount <= this.send_buffer_size / 2) {\n        break;\n      }\n      await new Promise((resolve) => {setTimeout(resolve, 10)});\n    }\n  }\n\n  close(code, reason) {\n    this.ws.close(code, reason);\n    this.data_queue.close();\n  }\n\n  get buffered_amount() {\n    return this.ws.bufferedAmount;\n  }\n}\n\n//an async fifo queue\nexport class AsyncQueue {\n  constructor(max_size) {\n    this.max_size = max_size;\n    this.queue = [];\n    this.put_callbacks = [];\n    this.get_callbacks = [];\n  }\n\n  put_now(data) {\n    this.queue.push(data);\n    this.get_callbacks.shift()?.();\n  }\n\n  async put(data) {\n    if (this.size <= this.max_size) {\n      this.put_now(data);\n      return;\n    }\n\n    //wait until there is a place to put the item\n    await new Promise((resolve) => {\n      this.put_callbacks.push(resolve);\n    });\n    this.put_now(data);\n  }\n\n  get_now() {\n    this.put_callbacks.shift()?.();\n    return this.queue.shift();\n  }\n\n  async get() {\n    if (this.size > 0) {\n      return this.get_now();\n    }\n\n    //wait until there is an item available in the queue\n    await new Promise((resolve) => {\n      this.get_callbacks.push(resolve);\n    });\n    return this.get_now();\n  }\n\n  close() {\n    this.queue = [];\n    let callback;\n    //resolve all pending operations\n    while (callback = this.get_callbacks.shift())\n      callback();\n    while (callback = this.put_callbacks.shift())\n      callback();\n  }\n\n  get size() {\n    return this.queue.length;\n  }\n}","import * as logging from \"../logging.mjs\";\nimport { AsyncQueue } from \"../websocket.mjs\";\nimport { options } from \"./options.mjs\";\nimport { net, dgram, dns } from \"../compat.mjs\";\n\n//wrappers for node networking apis\n//in the browser these can be redefined to allow for custom transports\n\nexport const is_node = (typeof process !== \"undefined\");\n\nconst dns_cache = new Map();\nlet dns_servers = null;\nlet resolver = null;\n\nexport function assert_on_node() {\n  if (!is_node) {\n    throw new Error(\"not running on node.js\");\n  }\n}\n\n//wrapper for node resolver methods\n//resolve4 and resolve6 need to be wrapped to work around a nodejs bug\nfunction resolve4(hostname) {\n  return resolver.resolve4(hostname);\n}\nfunction resolve6(hostname) {\n  return resolver.resolve6(hostname);\n}\nasync function resolve_with_fallback(resolve_first, resolve_after, hostname) {\n  try {\n    return (await resolve_first(hostname))[0];\n  }\n  catch {\n    return (await resolve_after(hostname))[0];\n  }\n}  \n\n//a wrapper for the actual dns lookup\nasync function perform_lookup(hostname) {\n  //resolve using system dns\n  if (options.dns_method === \"lookup\") {\n    let result = await dns.lookup(hostname, {order: options.dns_result_order}); \n    return result.address;\n  }\n\n  //resolve using dns.resolve4 / dns.resolve6, which bypasses the system dns\n  else if (options.dns_method === \"resolve\") {\n    //we need to make a new resolver at first run because setServers doesn't work otherwise\n    if (!resolver) resolver = new dns.Resolver();\n\n    //set custom dns servers if needed\n    if (options.dns_servers !== dns_servers) {\n      logging.debug(\"Setting custom DNS servers to: \" + options.dns_servers.join(\", \"));\n      resolver.setServers(options.dns_servers);\n      dns_servers = options.dns_servers;\n    }\n\n    if (options.dns_result_order === \"verbatim\" || options.dns_result_order === \"ipv6first\") \n      return await resolve_with_fallback(resolve6, resolve4, hostname);\n    else if (options.dns_result_order === \"ipv4first\")\n      return await resolve_with_fallback(resolve4, resolve6, hostname);\n    else\n      throw new Error(\"Invalid result order. options.dns_result_order must be either 'ipv6first', 'ipv4first', or 'verbatim'.\");\n  }\n\n  //use a custom function for dns resolution\n  else if (typeof options.dns_method === \"function\") {\n    return await options.dns_method(hostname);\n  }\n\n  throw new Error(\"Invalid DNS method. options.dns_method must either be 'lookup' or 'resolve'.\");\n}\n\n//perform a dns lookup and use the cache\nexport async function lookup_ip(hostname) {\n  if (!is_node) { //we cannot do the dns lookup on the browser\n    return hostname;\n  }\n\n  let ip_level = net.isIP(hostname);\n  if (ip_level === 4 || ip_level === 6) {\n    return hostname; //hostname is already an ip address\n  }\n\n  //remove stale entries from the cache\n  let now = Date.now();\n  for (let [entry_hostname, cache_entry] of dns_cache) {\n    let ttl = now - cache_entry.time;\n    if (ttl > options.dns_ttl) {\n      dns_cache.delete(entry_hostname);\n    }\n  }\n\n  //look in the cache first before using the system resolver\n  let cache_entry = dns_cache.get(hostname);\n  if (cache_entry) {\n    if (cache_entry.error) \n      throw cache_entry.error\n    return cache_entry.address;\n  }\n\n  //try to perform the actual dns lookup and store the result\n  let address;\n  try {\n    address = await perform_lookup(hostname);\n    logging.debug(`Domain resolved: ${hostname} -> ${address}`);\n    dns_cache.set(hostname, {time: Date.now(), address: address});\n  }\n  catch (e) {\n    dns_cache.set(hostname, {time: Date.now(), error: e});\n    throw e;\n  }\n\n  return address;\n}\n\n//async tcp and udp socket wrappers\nexport class NodeTCPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n    this.recv_buffer_size = 128;\n\n    this.socket = null;\n    this.paused = false;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    await new Promise((resolve, reject) => {\n      this.socket = new net.Socket();\n      this.socket.setNoDelay(true);\n      this.socket.on(\"connect\", () => {\n        this.connected = true;\n        resolve();\n      });\n      this.socket.on(\"data\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"close\", (error) => {\n        if (error && !this.connected) reject();\n        else this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.on(\"error\", (error) => {\n        logging.warn(`tcp stream to ${this.hostname} ended with error - ${error}`);\n      });\n      this.socket.on(\"end\", () => {\n        if (!this.socket) return;\n        this.socket.destroy();\n        this.socket = null;\n      });\n      this.socket.connect({\n        host: ip,\n        port: this.port\n      });\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    await new Promise((resolve) => {\n      this.socket.write(data, resolve);\n    });\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.end();\n    this.socket = null;\n  }\n\n  pause() {\n    if (this.data_queue.size >= this.data_queue.max_size) {\n      this.socket.pause();\n      this.paused = true;\n    }\n  }\n  resume() {\n    if (!this.socket) return;\n    if (this.paused) {\n      this.socket.resume();\n      this.paused = false;\n    }\n  }\n}\n\nexport class NodeUDPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n\n    this.connected = false;\n    this.recv_buffer_size = 128;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    let ip_level = net.isIP(ip);\n    await new Promise((resolve, reject) => {\n      this.socket = dgram.createSocket(ip_level === 6 ? \"udp6\" : \"udp4\");\n      this.socket.on(\"connect\", () => {\n        resolve();\n      });\n      this.socket.on(\"message\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"error\", () => {\n        if (!this.connected) reject();\n        this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.connect(this.port, ip);\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    this.socket.send(data);\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.close();\n    this.socket = null;\n  }\n\n  pause() {}\n  resume() {}\n}","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"ipaddr.js\");","import { close_reasons, stream_types } from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport * as net from \"./net.mjs\";\n\nimport ipaddr from \"ipaddr.js\";\n\nexport class AccessDeniedError extends Error {}\n\n//helper functions for the whitelist/blacklist logic\nfunction check_port_range(entry, port) {\n  return (entry === port) || (entry[0] <= port && entry[1] >= port)\n}\nfunction check_whitelist(entries, filter) {\n  let matched = false;\n  for (let entry of entries) {\n    if (filter(entry)) {\n      matched = true;\n      break\n    }\n  }\n  return !matched;\n}\nfunction check_blacklist(entries, filter) {\n  for (let entry of entries) {\n    if (filter(entry))\n      return true;\n    }\n  return false;\n}\n\nfunction check_ip_range(ip, range) {\n  return range.includes(ip.range());\n}\n\n//check if an ip is blocked\nexport function is_ip_blocked(ip_str) {\n  if (!ipaddr.isValid(ip_str)) \n    return false;\n  let ip = ipaddr.parse(ip_str);\n\n  let loopback_ranges = [\"loopback\", \"unspecified\"];\n  let private_ranges = [\"broadcast\", \"linkLocal\", \"carrierGradeNat\", \"private\", \"reserved\"];\n\n  if (!options.allow_loopback_ips && check_ip_range(ip, loopback_ranges)) \n    return true;\n  if (!options.allow_private_ips && check_ip_range(ip, private_ranges)) \n    return true;\n  return false;\n}\n\n//returns the close reason if the connection should be blocked\nexport async function is_stream_allowed(connection, type, hostname, port) {\n  //check if tcp or udp should be blocked\n  if (!options.allow_tcp_streams && type === stream_types.TCP)\n    return close_reasons.HostBlocked;\n  if (!options.allow_udp_streams && type === stream_types.UDP)\n    return close_reasons.HostBlocked;\n\n  //check the hostname whitelist/blacklist\n  if (options.hostname_whitelist) {\n    if (check_whitelist(options.hostname_whitelist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n  else if (options.hostname_blacklist) {\n    if (check_blacklist(options.hostname_blacklist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the port is blocked\n  if (options.port_whitelist) {\n    if (check_whitelist(options.port_whitelist, (entry) => check_port_range(entry, port))) \n      return close_reasons.HostBlocked;\n  }\n  else if (options.port_blacklist) {\n    if (check_blacklist(options.port_blacklist, (entry) => check_port_range(entry, port)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the destination ip is blocked\n  let ip_str = hostname;\n  if (ipaddr.isValid(hostname)) {\n    if (!options.allow_direct_ip)\n      return close_reasons.HostBlocked;\n  }\n  else {\n    try { //look up the ip to make sure that the resolved address is allowed\n      ip_str = await net.lookup_ip(hostname);\n    }\n    catch {}\n  }\n  if (is_ip_blocked(ip_str)) \n    return close_reasons.HostBlocked;\n\n  //don't check stream counts if there isn't an associated wisp connection (with wsproxy for example)\n  if (!connection) \n    return 0;\n\n  //check for stream count limits\n  if (options.stream_limit_total !== -1 && Object.keys(connection.streams).length >= options.stream_limit_total) \n    return close_reasons.ConnThrottled;\n  if (options.stream_limit_per_host !== -1) {\n    let streams_per_host = 0;\n    for (let stream of connection.streams) {\n      if (stream.socket.hostname === hostname) {\n        streams_per_host++;\n      }\n    }\n    if (streams_per_host >= options.stream_limit_per_host)\n      return close_reasons.ConnThrottled;\n  }\n\n  return 0;\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { AsyncQueue, AsyncWebSocket, get_conn_id } from \"../websocket.mjs\";\nimport { NodeTCPSocket, NodeUDPSocket } from \"./net.mjs\";\nimport { \n  WispBuffer,\n  WispPacket,\n  ContinuePayload,\n  ClosePayload,\n  ConnectPayload,\n  DataPayload,\n  InfoPayload,\n  stream_types,\n  close_reasons\n} from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nexport class HandshakeError extends Error {}\n\nexport class ServerStream {\n  static buffer_size = 128;\n\n  constructor(stream_id, conn, socket) {\n    this.stream_id = stream_id;\n    this.conn = conn;\n    this.socket = socket;    \n    this.send_buffer = new AsyncQueue(ServerStream.buffer_size);\n    this.packets_sent = 0;\n  }\n\n  async setup() {\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a tcp/udp to ws task encountered an error - ${error}`);\n      this.close();\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a ws to tcp/udp task encountered an error - ${error}`);\n      this.close();\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n\n      this.socket.pause();\n      let packet = new WispPacket({\n        type: DataPayload.type,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(new Uint8Array(data))\n        })\n      });\n      await this.conn.ws.send(packet);\n      this.socket.resume();\n    }\n    await this.conn.close_stream(this.stream_id, close_reasons.Voluntary);\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data = await this.send_buffer.get();\n      if (data == null) {\n        break; //stream closed\n      }\n      await this.socket.send(data);\n\n      this.packets_sent++;\n      if (this.packets_sent % (ServerStream.buffer_size / 2) !== 0) {\n        continue;\n      }\n      let packet = new WispPacket({\n        type: ContinuePayload.type,\n        stream_id: this.stream_id,\n        payload: new ContinuePayload({\n          buffer_remaining: ServerStream.buffer_size - this.send_buffer.size\n        })\n      });\n      this.conn.ws.send(packet);\n    }\n    await this.close();\n  }\n\n  async close(reason = null) {\n    this.send_buffer.close();\n    this.socket.close();\n    if (reason == null) return;\n\n    let packet = new WispPacket({\n      type: ClosePayload.type,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    await this.conn.ws.send(packet);\n  }\n\n  async put_data(data) {\n    await this.send_buffer.put(data);\n  }\n}\n\nexport class ServerConnection {\n  constructor(ws, path, {TCPSocket, UDPSocket, ping_interval, wisp_version, wisp_extensions} = {}) {\n    this.ws = new AsyncWebSocket(ws);\n    this.path = path;\n    this.TCPSocket = TCPSocket || NodeTCPSocket;\n    this.UDPSocket = UDPSocket || NodeUDPSocket;\n    this.ping_interval = ping_interval || 30;\n    this.wisp_version = wisp_version || options.wisp_version;\n    this.wisp_extensions = wisp_extensions || null;\n    \n    this.ping_task = null;\n    this.streams = {};\n    this.conn_id = get_conn_id();\n\n    this.server_exts = {};\n    this.client_exts = {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    if (options.allow_udp_streams) \n      this.wisp_extensions.push(new UDPExtension({server_config: {}}));\n    if (options.wisp_motd)\n      this.wisp_extensions.push(new MOTDExtension({server_config: {\n        message: options.wisp_motd\n      }}));\n  }\n\n  async setup() {\n    logging.info(`setting up new wisp v${this.wisp_version} connection with id ${this.conn_id}`);\n\n    await this.ws.connect();\n    if (this.wisp_version == 2) {\n      await this.setup_wisp_v2()\n    }\n\n    //send initial continue packet\n    let continue_packet = new WispPacket({\n      type: ContinuePayload.type,\n      stream_id: 0,\n      payload: new ContinuePayload({\n        buffer_remaining: ServerStream.buffer_size\n      })\n    });\n    this.ws.send(continue_packet);\n\n    if (typeof this.ws.ws.ping === \"function\") {\n      this.ping_task = setInterval(() => {\n        logging.debug(`(${this.conn_id}) sending websocket ping`);\n        this.ws.ws.ping();\n      }, this.ping_interval * 1000);  \n    }\n  }\n\n  async setup_wisp_v2() {\n    //send initial info packet for wisp v2\n    let ext_buffer = serialize_extensions(this.wisp_extensions);\n    let info_packet = new WispPacket({\n      type: InfoPayload.type,\n      stream_id: 0,\n      payload: new InfoPayload({\n        major_ver: this.wisp_version,\n        minor_ver: 0,\n        extensions: ext_buffer\n      })\n    });\n    this.ws.send(info_packet);\n\n    //wait for the client's info packet\n    let data = await this.ws.recv();\n    if (data == null) {\n      logging.warn(`(${this.conn_id}) handshake error: ws closed before handshake complete`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n    let buffer = new WispBuffer(new Uint8Array(data));\n    let packet = WispPacket.parse_all(buffer);\n\n    if (packet.type !== InfoPayload.type) {\n      logging.warn(`(${this.conn_id}) handshake error: unexpected packet of type ${packet.type}`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n\n    //figure out the common extensions\n    let client_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"client\");\n    for (let client_ext of client_extensions) {\n      for (let server_ext of this.wisp_extensions) {\n        if (server_ext.id === client_ext.id) {\n          this.server_exts[server_ext.id] = server_ext;\n          this.client_exts[client_ext.id] = client_ext;\n        }\n      }\n    }\n  }\n\n  create_stream(stream_id, type, hostname, port) {\n    let SocketImpl = type === stream_types.TCP ? this.TCPSocket : this.UDPSocket;\n    let socket = new SocketImpl(hostname, port);\n    let stream = new ServerStream(stream_id, this, socket);\n    this.streams[stream_id] = stream;\n\n    //start connecting to the destination server in the background\n    (async () => {\n      let close_reason = await filter.is_stream_allowed(this, type, hostname, port);\n      if (close_reason) {\n        logging.warn(`(${this.conn_id}) refusing to create a stream to ${hostname}:${port}`);\n        await this.close_stream(stream_id, close_reason, true);\n        return;\n      }\n      try {\n        await stream.setup();\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) creating a stream to ${hostname}:${port} failed - ${error}`);\n        await this.close_stream(stream_id, close_reasons.NetworkError);\n      }\n    })();\n  }\n\n  async close_stream(stream_id, reason = null, quiet = false) {\n    let stream = this.streams[stream_id];\n    if (stream == null) {\n      return;\n    }\n    if (reason && !quiet) {\n      logging.info(`(${this.conn_id}) closing stream to ${stream.socket.hostname} for reason ${reason}`);\n    }\n    await stream.close(reason);\n    delete this.streams[stream_id];\n  }\n\n  route_packet(buffer) {\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.streams[packet.stream_id];\n\n    if (stream == null && packet.type == DataPayload.type) {\n      logging.warn(`(${this.conn_id}) received a DATA packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === ConnectPayload.type) {\n      let type_info = packet.payload.stream_type === stream_types.TCP ? \"TCP\" : \"UDP\";\n      logging.info(`(${this.conn_id}) opening new ${type_info} stream to ${packet.payload.hostname}:${packet.payload.port}`);\n      this.create_stream(\n        packet.stream_id, \n        packet.payload.stream_type, \n        packet.payload.hostname.trim(), \n        packet.payload.port\n      )\n    }\n\n    else if (packet.type === DataPayload.type) {\n      stream.put_data(packet.payload.data.bytes);\n    }\n\n    else if (packet.type == ContinuePayload.type) {\n      logging.warn(`(${this.conn_id}) client sent a CONTINUE packet, this should never be possible`);\n    }\n\n    else if (packet.type == ClosePayload.type) {\n      this.close_stream(packet.stream_id, packet.reason);\n    }\n  }\n\n  async run() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      if (typeof data === \"string\") {\n        logging.warn(`(${this.conn_id}) routing a packet failed - unexpected ws text frame`);\n        continue;\n      }\n      \n      try {\n        //note: data is an arraybuffer so the uint8array constructor does not copy\n        this.route_packet(new WispBuffer(new Uint8Array(data)));\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) routing a packet failed - ${error}`);\n      }\n    }\n    \n    await this.cleanup();\n  }\n\n  async cleanup() {\n    //clean up all streams when the websocket is closed\n    for (let stream_id of Object.keys(this.streams)) {\n      await this.close_stream(stream_id);\n    }\n    clearInterval(this.ping_task);\n    logging.info(`(${this.conn_id}) wisp connection closed`);\n    this.ws.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { stream_types } from \"../packet.mjs\";\nimport { AsyncWebSocket } from \"../websocket.mjs\";\nimport { NodeTCPSocket } from \"./net.mjs\";\n\nexport class WSProxyConnection {\n  constructor(ws, path) {\n    let [hostname, port] = path.split(\"/\").pop().split(\":\");\n    this.hostname = hostname.trim();\n    this.port = parseInt(port);\n    this.ws = new AsyncWebSocket(ws);\n  }\n\n  async setup() {\n    await this.ws.connect();\n\n    //check that the destination host/ip is allowed\n    let err_code = await filter.is_stream_allowed(null, stream_types.TCP, this.hostname, this.port);\n    if (err_code !== 0) {\n      logging.info(`Refusing to create a wsproxy connection to ${this.hostname}:${this.port}`);\n      this.ws.close();\n      throw new filter.AccessDeniedError();\n    }\n\n    //connect to the tcp host after we are certain that it's safe to do so\n    this.socket = new NodeTCPSocket(this.hostname, this.port);\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`a tcp to ws task (wsproxy) encountered an error - ${error}`);\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`a ws to tcp task (wsproxy) encountered an error - ${error}`);\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n      this.socket.pause();\n      await this.ws.send(data);\n      this.socket.resume();\n    }\n    await this.ws.close();\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      await this.socket.send(data);\n    }\n    await this.socket.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as compat from \"../compat.mjs\";\n\nimport { options } from \"./options.mjs\";\nimport { AccessDeniedError } from \"./filter.mjs\";\nimport { ServerConnection, HandshakeError } from \"./connection.mjs\";\nimport { WSProxyConnection } from \"./wsproxy.mjs\";\nimport { is_node, assert_on_node } from \"./net.mjs\";\n\nlet ws_server = null;\nif (is_node) {\n  ws_server = new compat.WebSocketServer({ noServer: true });\n}\n\nexport function parse_real_ip(headers, client_ip) {\n  if (options.parse_real_ip && options.parse_real_ip_from.includes(client_ip)) {\n    if (headers[\"x-forwarded-for\"]) {\n      return headers[\"x-forwarded-for\"].split(\",\")[0].trim();\n    }\n    else if (headers[\"x-real-ip\"]) {\n      return headers[\"x-real-ip\"];\n    }\n  }\n  return client_ip;\n}\n\nexport function routeRequest(request, socket, head, conn_options={}) {\n  assert_on_node();\n  if (request.headers[\"sec-websocket-protocol\"] && options.wisp_version === 2)\n    conn_options.wisp_version = 2;\n  else \n    conn_options.wisp_version = 1;\n\n  if (request instanceof compat.http.IncomingMessage) {\n    ws_server.handleUpgrade(request, socket, head, (ws) => {\n      create_connection(ws, request.url, request, conn_options);\n    });\n  }\n  else if (request instanceof compat.WebSocket) {\n    create_connection(ws, \"/\", {}), conn_options;\n  }\n}\n\nasync function create_connection(ws, path, request, conn_options) {\n  ws.binaryType = \"arraybuffer\";\n  let client_ip = request.socket.address().address;\n  let real_ip = parse_real_ip(request.headers, client_ip);\n  let origin = request.headers[\"origin\"];\n  logging.info(`new connection on ${path} from ${real_ip} (origin: ${origin})`);\n  \n  try {\n    if (path.endsWith(\"/\")) {\n      let wisp_conn = new ServerConnection(ws, path, conn_options);\n      await wisp_conn.setup();\n      await wisp_conn.run();\n    }\n  \n    else {\n      let wsproxy = new WSProxyConnection(ws, path, conn_options);\n      await wsproxy.setup();\n    }\n  }\n\n  catch (error) {\n    ws.close();\n    if (error instanceof HandshakeError) return;\n    if (error instanceof AccessDeniedError) return;\n    logging.error(\"Uncaught server error:\\n\" + (error.stack || error));\n  }\n}","export { ServerStream, ServerConnection} from \"./connection.mjs\";\nexport { routeRequest, parse_real_ip } from \"./http.mjs\";\nexport { options } from \"./options.mjs\";","export * as client from \"./client/index.mjs\";\nexport * as server from \"./server/index.mjs\";\nexport * as packet from \"./packet.mjs\";\nexport * as extensions from \"./extensions.mjs\";"],"names":[],"ignoreList":[],"sourceRoot":""}