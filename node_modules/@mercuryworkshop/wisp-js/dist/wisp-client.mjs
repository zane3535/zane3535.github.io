var e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{ClosePayload:()=>u,ConnectPayload:()=>d,ContinuePayload:()=>w,DataPayload:()=>_,InfoPayload:()=>f,WispBuffer:()=>l,WispPacket:()=>p,close_reasons:()=>b,packet_classes:()=>y,packet_types:()=>m,stream_types:()=>v});var s={};e.r(s),e.d(s,{BaseExtension:()=>x,MOTDExtension:()=>U,PasswordAuthExtension:()=>E,UDPExtension:()=>z,extensions_map:()=>O,parse_extensions:()=>C,serialize_extensions:()=>T});var i={};e.r(i),e.d(i,{ClientConnection:()=>S,WispWebSocket:()=>D,_wisp_connections:()=>A});const n="undefined"==typeof globalThis?window:globalThis,r=n.WebSocket,o=(n.crypto,new TextEncoder),a=o.encode.bind(o),c=new TextDecoder,h=c.decode.bind(c);class l{constructor(e){if(e instanceof Uint8Array)this.from_array(e);else if("number"==typeof e)this.from_array(new Uint8Array(e));else{if("string"!=typeof e)throw console.trace(),"invalid data type passed to wisp buffer constructor";this.from_array(a(e))}}from_array(e){this.size=e.length,this.bytes=e,this.view=new DataView(e.buffer)}concat(e){let t=new l(this.size+e.size);return t.bytes.set(this.bytes,0),t.bytes.set(e.bytes,this.size),t}slice(e,t){let s=this.bytes.slice(e,t);return new l(s)}get_string(){return c.decode(this.bytes)}}class p{static min_size=5;constructor({type:e,stream_id:t,payload:s,payload_bytes:i}){this.type=e,this.stream_id=t,this.payload_bytes=i,this.payload=s}static parse(e){return new p({type:e.view.getUint8(0),stream_id:e.view.getUint32(1,!0),payload_bytes:e.slice(5)})}static parse_all(e){if(e.size<p.min_size)throw TypeError("packet too small");let t=p.parse(e),s=y[t.type];if(void 0===s)throw TypeError("invalid packet type");if(t.payload_bytes.size<s.size)throw TypeError("payload too small");return t.payload=s.parse(t.payload_bytes),t}serialize(){let e=new l(5);return e.view.setUint8(0,this.type),e.view.setUint32(1,this.stream_id,!0),e=e.concat(this.payload.serialize()),e}}class d{static min_size=3;static type=1;static name="CONNECT";constructor({stream_type:e,port:t,hostname:s}){this.stream_type=e,this.port=t,this.hostname=s}static parse(e){return new d({stream_type:e.view.getUint8(0),port:e.view.getUint16(1,!0),hostname:h(e.slice(3).bytes)})}serialize(){let e=new l(3);return e.view.setUint8(0,this.stream_type),e.view.setUint16(1,this.port,!0),e=e.concat(new l(this.hostname)),e}}class _{static min_size=0;static type=2;static name="DATA";constructor({data:e}){this.data=e}static parse(e){return new _({data:e})}serialize(){return this.data}}class w{static type=3;static name="CONTINUE";constructor({buffer_remaining:e}){this.buffer_remaining=e}static parse(e){return new w({buffer_remaining:e.view.getUint32(0,!0)})}serialize(){let e=new l(4);return e.view.setUint32(0,this.buffer_remaining,!0),e}}class u{static min_size=1;static type=4;static name="CLOSE";constructor({reason:e}){this.reason=e}static parse(e){return new u({reason:e.view.getUint8(0)})}serialize(){let e=new l(1);return e.view.setUint8(0,this.reason),e}}class f{static min_size=2;static type=5;static name="INFO";constructor({major_ver:e,minor_ver:t,extensions:s}){this.major_ver=e,this.minor_ver=t,this.extensions=s}static parse(e){return new f({major_ver:e.view.getUint8(0),minor_ver:e.view.getUint8(1),extensions:e.slice(2)})}serialize(){let e=new l(2);return e.view.setUint8(0,this.major_ver),e.view.setUint8(1,this.minor_ver),e.concat(this.extensions)}}const y={1:d,2:_,3:w,4:u,5:f},m={CONNECT:1,DATA:2,CONTINUE:3,CLOSE:4,INFO:5},v={TCP:1,UDP:2},b={Unknown:1,Voluntary:2,NetworkError:3,IncompatibleExtensions:4,InvalidInfo:65,UnreachableHost:66,NoResponse:67,ConnRefused:68,TransferTimeout:71,HostBlocked:72,ConnThrottled:73,ClientError:129,AuthBadPassword:192,AuthBadSignature:193,AuthMissingCredentials:194};class g{constructor(){}static parse(){return new g}serialize(){return new l(0)}}class x{static id=0;static name="";static Server=g;static Client=g;constructor({server_config:e,client_config:t}={}){this.id=this.constructor.id,this.name=this.constructor.name,e?this.payload=new this.constructor.Server(e):t&&(this.payload=new this.constructor.Client(t))}static parse(e,t,s){let i=new e({});if("client"===s)i.payload=e.Client.parse(t.slice(5));else{if("server"!==s)throw TypeError("invalid role");i.payload=e.Server.parse(t.slice(5))}return i}serialize(){let e=new l(5),t=this.payload.serialize();return e.view.setInt8(0,this.constructor.id),e.view.setUint32(1,t.size,!0),e.concat(t)}}class z extends x{static id=1;static name="UDP"}class E extends x{static id=2;static name="Password Authentication";static Server=class{constructor({required:e=1}){this.required=e?1:0}static parse(e){return new E.Server({required:e.view.getUint8(0)})}serialize(){let e=new l(1);return e.view.setUint8(0,this.required),e}};static Client=class{constructor({username:e,password:t}){this.username=e,this.password=t}static parse(e){let t=e.view.getUint8(0),s=e.view.getUint16(1,!0),i=t+3;return new E.Client({username:e.slice(3,t).get_string(),password:e.slice(i,s).get_string()})}serialize(){let e=new l(this.username),t=new l(this.password),s=new l(3);return s.view.setUint8(0,e.size),s.view.setUint16(1,t.size,!0),s.concat(e).concat(t)}}}class U extends x{static id=4;static name="Server MOTD";static Server=class{constructor({message:e}){this.message=e}static parse(e){return new U.Server({message:e.get_string()})}serialize(){return new l(this.message)}};static Client=g}function C(e,t,s){let i=[];for(;e.size;){let n,r=e.view.getUint8(0),o=e.view.getUint32(1,!0),a=e.slice(0,5+o);for(let e of t)if(e.id===r){n=e.constructor;break}if(n){let e=x.parse(n,a,s);i.push(e)}e=e.slice(5+o)}return i}function T(e){{let t=new l(0);for(let s of e)t=t.concat(s.serialize());return t}}const O={1:z,2:E,4:U};class N{constructor(e,t,s,i,n,r,o){this.hostname=e,this.port=t,this.ws=s,this.buffer_size=i,this.stream_id=n,this.connection=r,this.stream_type=o,this.send_buffer=[],this.open=!0,this.onopen=()=>{},this.onclose=()=>{},this.onmessage=()=>{}}send(e){if(this.buffer_size>0||!this.open||this.stream_type===v.UDP){let t=new p({type:m.DATA,stream_id:this.stream_id,payload:new _({data:new l(e)})});this.ws.send(t.serialize().bytes),this.buffer_size--}else this.send_buffer.push(e)}continue_received(e){for(this.buffer_size=e;this.buffer_size>0&&this.send_buffer.length>0;)this.send(this.send_buffer.shift())}close(e=1){if(!this.open)return;let t=new p({type:m.CLOSE,stream_id:this.stream_id,payload:new u({reason:e})});this.ws.send(t.serialize().bytes),this.open=!1,delete this.connection.active_streams[this.stream_id]}}class S{constructor(e,{wisp_version:t,wisp_extensions:s}={}){if(!e.endsWith("/"))throw new TypeError("wisp endpoints must end with a trailing forward slash");this.wisp_url=e,this.wisp_version=t||2,this.wisp_extensions=s||null,this.max_buffer_size=null,this.active_streams={},this.connected=!1,this.connecting=!1,this.next_stream_id=1,this.server_exts={},this.client_exts={},this.info_received=!1,this.server_motd=null,this.udp_enabled=!0,this.onopen=()=>{},this.onclose=()=>{},this.onerror=()=>{},this.onmessage=()=>{},2===this.wisp_version&&null===this.wisp_extensions&&this.add_extensions(),this.connect_ws()}add_extensions(){this.wisp_extensions=[],this.wisp_extensions.push(new z({client_config:{}})),this.wisp_extensions.push(new U({client_config:{}}))}connect_ws(){let e=2===this.wisp_version?"wisp-v2":void 0;this.ws=new r(this.wisp_url,e),this.ws.binaryType="arraybuffer",this.connecting=!0,this.ws.onerror=()=>{if(2===this.wisp_version)return this.ws.onclose=null,this.cleanup(),this.wisp_version=1,void this.connect_ws();this.cleanup(),this.onerror()},this.ws.onclose=()=>{this.cleanup(),this.onclose()},this.ws.onmessage=e=>{this.on_ws_msg(e),this.connected&&this.connecting&&(this.connecting=!1,this.onopen())}}close(){this.ws.close()}create_stream(e,t,s=1){let i=s;if("string"==typeof i&&(i="udp"===s?v.UDP:v.TCP),i==v.UDP&&!this.udp_enabled)throw new Error("udp is not enabled for this wisp connection");let n=this.next_stream_id++,r=new N(e,t,this.ws,this.max_buffer_size,n,this,i);this.active_streams[n]=r,r.open=this.connected;let o=new p({type:m.CONNECT,stream_id:n,payload:new d({stream_type:i,port:t,hostname:e})});return this.ws.send(o.serialize().bytes),r}close_stream(e,t){e.onclose(t),delete this.active_streams[e.stream_id]}on_ws_msg(e){let t=new l(new Uint8Array(e.data));if(t.size<p.min_size)return void console.warn("wisp client warning: received a packet which is too short");let s=p.parse_all(t),i=this.active_streams[s.stream_id];if(0===s.stream_id&&this.connecting){if(s.type===m.CONTINUE&&(this.max_buffer_size=s.payload.buffer_remaining,this.connected=!0,this.info_received||(this.wisp_version=1)),s.type===m.INFO&&2===this.wisp_version){let e=C(s.payload.extensions,this.wisp_extensions,"server");for(let t of e)for(let e of this.wisp_extensions)t.id===e.id&&(this.server_exts[t.id]=t,this.client_exts[e.id]=e);this.info_received=!0,this.server_motd=this.server_exts[U.id]?.payload?.message,this.udp_enabled=!!this.server_exts[z.id];let t=T(this.wisp_extensions),i=new p({type:f.type,stream_id:0,payload:new f({major_ver:this.wisp_version,minor_ver:0,extensions:t})});this.ws.send(i.serialize().bytes)}}else void 0!==i?s.type===m.DATA?i.onmessage(s.payload_bytes.bytes):s.type===m.CONTINUE?i.continue_received(s.payload.buffer_remaining):s.type===m.CLOSE?this.close_stream(i,s.payload.reason):console.warn(`wisp client warning: received an invalid packet of type ${s.type}`):console.warn(`wisp client warning: received a ${y[s.type].name} packet for a stream which doesn't exist`)}cleanup(){this.connected=!1,this.connecting=!1;for(let e of Object.keys(this.active_streams))this.close_stream(this.active_streams[e],3)}}const P=n.CloseEvent||Event,A={};class D extends EventTarget{constructor(e,t=null,s={}){super(),this.url=e,this.protocols=t,this.options=s,this.binaryType="blob",this.stream=null,this.connection=null,this.onopen=()=>{},this.onerror=()=>{},this.onmessage=()=>{},this.onclose=()=>{},this.CONNECTING=0,this.OPEN=1,this.CLOSING=2,this.CLOSED=3,this._ready_state=this.CONNECTING;let i=this.url.split("/"),n=i.pop().split(":");this.host=n[0],this.port=parseInt(n[1]),this.real_url=i.join("/")+"/",this.init_connection()}on_conn_close(){this._ready_state=this.CLOSED,A[this.real_url]&&(this.onerror(new Event("error")),this.dispatchEvent(new Event("error"))),delete A[this.real_url]}init_connection(){if(this.connection=A[this.real_url],this.connection)if(this.connection.connected)this.connection=A[this.real_url],this.init_stream();else{let e=this.connection.onopen;this.connection.onopen=()=>{e(),this.init_stream()}}else this.connection=new S(this.real_url,this.options),this.connection.onopen=()=>{this.init_stream()},this.connection.onclose=()=>{this.on_conn_close()},this.connection.onerror=()=>{this.on_conn_close()},A[this.real_url]=this.connection}init_stream(){this._ready_state=this.OPEN,this.stream=this.connection.create_stream(this.host,this.port),this.stream.onmessage=e=>{let t;if("blob"==this.binaryType)t=new Blob(e);else{if("arraybuffer"!=this.binaryType)throw"invalid binaryType string";t=e.buffer}let s=new MessageEvent("message",{data:t});this.onmessage(s),this.dispatchEvent(s)},this.stream.onclose=e=>{this._ready_state=this.CLOSED;let t=new P("close",{code:e});this.onclose(t),this.dispatchEvent(t)};let e=new Event("open");this.onopen(e),this.dispatchEvent(e)}send(e){let t;if(e instanceof Uint8Array)t=e;else if("string"==typeof e)t=(new TextEncoder).encode(e);else{if(e instanceof Blob)return void e.arrayBuffer().then(e=>{this.send(e)});if(e instanceof ArrayBuffer)t=new Uint8Array(e);else{if(!ArrayBuffer.isView(e))throw"invalid data type to be sent";t=new Uint8Array(e.buffer)}}if(!this.stream)throw"websocket is not ready";this.stream.send(t)}close(){this.stream.close(2)}get bufferedAmount(){let e=0;for(let t of this.stream.send_buffer)e+=t.length;return e}get extensions(){return""}get protocol(){return"binary"}get readyState(){return this._ready_state}}export{i as client,s as extensions,t as packet};
//# sourceMappingURL=wisp-client.mjs.map