var wisp_client;(()=>{"use strict";var e={d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{client:()=>n,extensions:()=>i,packet:()=>s});var s={};e.r(s),e.d(s,{ClosePayload:()=>y,ConnectPayload:()=>_,ContinuePayload:()=>f,DataPayload:()=>w,InfoPayload:()=>m,WispBuffer:()=>d,WispPacket:()=>u,close_reasons:()=>x,packet_classes:()=>v,packet_types:()=>b,stream_types:()=>g});var i={};e.r(i),e.d(i,{BaseExtension:()=>T,MOTDExtension:()=>S,PasswordAuthExtension:()=>P,UDPExtension:()=>O,extensions_map:()=>D,parse_extensions:()=>N,serialize_extensions:()=>A});var n={};e.r(n),e.d(n,{ClientConnection:()=>k,WispWebSocket:()=>L,_wisp_connections:()=>B});const r="undefined"==typeof globalThis?window:globalThis,o=r.WebSocket;function a(e,t,s){return(t=function(e){var t=function(e){if("object"!=typeof e||!e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var s=t.call(e,"string");if("object"!=typeof s)return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof t?t:t+""}(t))in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}r.crypto;const l=new TextEncoder,c=l.encode.bind(l),h=new TextDecoder,p=h.decode.bind(h);class d{constructor(e){if(e instanceof Uint8Array)this.from_array(e);else if("number"==typeof e)this.from_array(new Uint8Array(e));else{if("string"!=typeof e)throw console.trace(),"invalid data type passed to wisp buffer constructor";this.from_array(c(e))}}from_array(e){this.size=e.length,this.bytes=e,this.view=new DataView(e.buffer)}concat(e){let t=new d(this.size+e.size);return t.bytes.set(this.bytes,0),t.bytes.set(e.bytes,this.size),t}slice(e,t){let s=this.bytes.slice(e,t);return new d(s)}get_string(){return h.decode(this.bytes)}}class u{constructor(e){let{type:t,stream_id:s,payload:i,payload_bytes:n}=e;this.type=t,this.stream_id=s,this.payload_bytes=n,this.payload=i}static parse(e){return new u({type:e.view.getUint8(0),stream_id:e.view.getUint32(1,!0),payload_bytes:e.slice(5)})}static parse_all(e){if(e.size<u.min_size)throw TypeError("packet too small");let t=u.parse(e),s=v[t.type];if(void 0===s)throw TypeError("invalid packet type");if(t.payload_bytes.size<s.size)throw TypeError("payload too small");return t.payload=s.parse(t.payload_bytes),t}serialize(){let e=new d(5);return e.view.setUint8(0,this.type),e.view.setUint32(1,this.stream_id,!0),e=e.concat(this.payload.serialize()),e}}a(u,"min_size",5);class _{constructor(e){let{stream_type:t,port:s,hostname:i}=e;this.stream_type=t,this.port=s,this.hostname=i}static parse(e){return new _({stream_type:e.view.getUint8(0),port:e.view.getUint16(1,!0),hostname:p(e.slice(3).bytes)})}serialize(){let e=new d(3);return e.view.setUint8(0,this.stream_type),e.view.setUint16(1,this.port,!0),e=e.concat(new d(this.hostname)),e}}a(_,"min_size",3),a(_,"type",1),a(_,"name","CONNECT");class w{constructor(e){let{data:t}=e;this.data=t}static parse(e){return new w({data:e})}serialize(){return this.data}}a(w,"min_size",0),a(w,"type",2),a(w,"name","DATA");class f{constructor(e){let{buffer_remaining:t}=e;this.buffer_remaining=t}static parse(e){return new f({buffer_remaining:e.view.getUint32(0,!0)})}serialize(){let e=new d(4);return e.view.setUint32(0,this.buffer_remaining,!0),e}}a(f,"type",3),a(f,"name","CONTINUE");class y{constructor(e){let{reason:t}=e;this.reason=t}static parse(e){return new y({reason:e.view.getUint8(0)})}serialize(){let e=new d(1);return e.view.setUint8(0,this.reason),e}}a(y,"min_size",1),a(y,"type",4),a(y,"name","CLOSE");class m{constructor(e){let{major_ver:t,minor_ver:s,extensions:i}=e;this.major_ver=t,this.minor_ver=s,this.extensions=i}static parse(e){return new m({major_ver:e.view.getUint8(0),minor_ver:e.view.getUint8(1),extensions:e.slice(2)})}serialize(){let e=new d(2);return e.view.setUint8(0,this.major_ver),e.view.setUint8(1,this.minor_ver),e.concat(this.extensions)}}a(m,"min_size",2),a(m,"type",5),a(m,"name","INFO");const v={1:_,2:w,3:f,4:y,5:m},b={CONNECT:1,DATA:2,CONTINUE:3,CLOSE:4,INFO:5},g={TCP:1,UDP:2},x={Unknown:1,Voluntary:2,NetworkError:3,IncompatibleExtensions:4,InvalidInfo:65,UnreachableHost:66,NoResponse:67,ConnRefused:68,TransferTimeout:71,HostBlocked:72,ConnThrottled:73,ClientError:129,AuthBadPassword:192,AuthBadSignature:193,AuthMissingCredentials:194};var z,E;function U(e,t,s){return(t=function(e){var t=function(e){if("object"!=typeof e||!e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var s=t.call(e,"string");if("object"!=typeof s)return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof t?t:t+""}(t))in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}class C{constructor(){}static parse(){return new C}serialize(){return new d(0)}}class T{constructor(){let{server_config:e,client_config:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.id=this.constructor.id,this.name=this.constructor.name,e?this.payload=new this.constructor.Server(e):t&&(this.payload=new this.constructor.Client(t))}static parse(e,t,s){let i=new e({});if("client"===s)i.payload=e.Client.parse(t.slice(5));else{if("server"!==s)throw TypeError("invalid role");i.payload=e.Server.parse(t.slice(5))}return i}serialize(){let e=new d(5),t=this.payload.serialize();return e.view.setInt8(0,this.constructor.id),e.view.setUint32(1,t.size,!0),e.concat(t)}}U(T,"id",0),U(T,"name",""),U(T,"Server",C),U(T,"Client",C);class O extends T{}U(O,"id",1),U(O,"name","UDP");class P extends T{}z=P,U(P,"id",2),U(P,"name","Password Authentication"),U(P,"Server",class{constructor(e){let{required:t=1}=e;this.required=t?1:0}static parse(e){return new z.Server({required:e.view.getUint8(0)})}serialize(){let e=new d(1);return e.view.setUint8(0,this.required),e}}),U(P,"Client",class{constructor(e){let{username:t,password:s}=e;this.username=t,this.password=s}static parse(e){let t=e.view.getUint8(0),s=e.view.getUint16(1,!0),i=t+3;return new z.Client({username:e.slice(3,t).get_string(),password:e.slice(i,s).get_string()})}serialize(){let e=new d(this.username),t=new d(this.password),s=new d(3);return s.view.setUint8(0,e.size),s.view.setUint16(1,t.size,!0),s.concat(e).concat(t)}});class S extends T{}function N(e,t,s){let i=[];for(;e.size;){let n,r=e.view.getUint8(0),o=e.view.getUint32(1,!0),a=e.slice(0,5+o);for(let e of t)if(e.id===r){n=e.constructor;break}if(n){let e=T.parse(n,a,s);i.push(e)}e=e.slice(5+o)}return i}function A(e){{let t=new d(0);for(let s of e)t=t.concat(s.serialize());return t}}E=S,U(S,"id",4),U(S,"name","Server MOTD"),U(S,"Server",class{constructor(e){let{message:t}=e;this.message=t}static parse(e){return new E.Server({message:e.get_string()})}serialize(){return new d(this.message)}}),U(S,"Client",C);const D={1:O,2:P,4:S};class j{constructor(e,t,s,i,n,r,o){this.hostname=e,this.port=t,this.ws=s,this.buffer_size=i,this.stream_id=n,this.connection=r,this.stream_type=o,this.send_buffer=[],this.open=!0,this.onopen=()=>{},this.onclose=()=>{},this.onmessage=()=>{}}send(e){if(this.buffer_size>0||!this.open||this.stream_type===g.UDP){let t=new u({type:b.DATA,stream_id:this.stream_id,payload:new w({data:new d(e)})});this.ws.send(t.serialize().bytes),this.buffer_size--}else this.send_buffer.push(e)}continue_received(e){for(this.buffer_size=e;this.buffer_size>0&&this.send_buffer.length>0;)this.send(this.send_buffer.shift())}close(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;if(!this.open)return;let t=new u({type:b.CLOSE,stream_id:this.stream_id,payload:new y({reason:e})});this.ws.send(t.serialize().bytes),this.open=!1,delete this.connection.active_streams[this.stream_id]}}class k{constructor(e){let{wisp_version:t,wisp_extensions:s}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e.endsWith("/"))throw new TypeError("wisp endpoints must end with a trailing forward slash");this.wisp_url=e,this.wisp_version=t||2,this.wisp_extensions=s||null,this.max_buffer_size=null,this.active_streams={},this.connected=!1,this.connecting=!1,this.next_stream_id=1,this.server_exts={},this.client_exts={},this.info_received=!1,this.server_motd=null,this.udp_enabled=!0,this.onopen=()=>{},this.onclose=()=>{},this.onerror=()=>{},this.onmessage=()=>{},2===this.wisp_version&&null===this.wisp_extensions&&this.add_extensions(),this.connect_ws()}add_extensions(){this.wisp_extensions=[],this.wisp_extensions.push(new O({client_config:{}})),this.wisp_extensions.push(new S({client_config:{}}))}connect_ws(){let e=2===this.wisp_version?"wisp-v2":void 0;this.ws=new o(this.wisp_url,e),this.ws.binaryType="arraybuffer",this.connecting=!0,this.ws.onerror=()=>{if(2===this.wisp_version)return this.ws.onclose=null,this.cleanup(),this.wisp_version=1,void this.connect_ws();this.cleanup(),this.onerror()},this.ws.onclose=()=>{this.cleanup(),this.onclose()},this.ws.onmessage=e=>{this.on_ws_msg(e),this.connected&&this.connecting&&(this.connecting=!1,this.onopen())}}close(){this.ws.close()}create_stream(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=s;if("string"==typeof i&&(i="udp"===s?g.UDP:g.TCP),i==g.UDP&&!this.udp_enabled)throw new Error("udp is not enabled for this wisp connection");let n=this.next_stream_id++,r=new j(e,t,this.ws,this.max_buffer_size,n,this,i);this.active_streams[n]=r,r.open=this.connected;let o=new u({type:b.CONNECT,stream_id:n,payload:new _({stream_type:i,port:t,hostname:e})});return this.ws.send(o.serialize().bytes),r}close_stream(e,t){e.onclose(t),delete this.active_streams[e.stream_id]}on_ws_msg(e){let t=new d(new Uint8Array(e.data));if(t.size<u.min_size)return void console.warn("wisp client warning: received a packet which is too short");let s=u.parse_all(t),i=this.active_streams[s.stream_id];if(0===s.stream_id&&this.connecting){if(s.type===b.CONTINUE&&(this.max_buffer_size=s.payload.buffer_remaining,this.connected=!0,this.info_received||(this.wisp_version=1)),s.type===b.INFO&&2===this.wisp_version){var n;let e=N(s.payload.extensions,this.wisp_extensions,"server");for(let t of e)for(let e of this.wisp_extensions)t.id===e.id&&(this.server_exts[t.id]=t,this.client_exts[e.id]=e);this.info_received=!0,this.server_motd=null===(n=this.server_exts[S.id])||void 0===n||null===(n=n.payload)||void 0===n?void 0:n.message,this.udp_enabled=!!this.server_exts[O.id];let t=A(this.wisp_extensions),i=new u({type:m.type,stream_id:0,payload:new m({major_ver:this.wisp_version,minor_ver:0,extensions:t})});this.ws.send(i.serialize().bytes)}}else void 0!==i?s.type===b.DATA?i.onmessage(s.payload_bytes.bytes):s.type===b.CONTINUE?i.continue_received(s.payload.buffer_remaining):s.type===b.CLOSE?this.close_stream(i,s.payload.reason):console.warn(`wisp client warning: received an invalid packet of type ${s.type}`):console.warn(`wisp client warning: received a ${v[s.type].name} packet for a stream which doesn't exist`)}cleanup(){this.connected=!1,this.connecting=!1;for(let e of Object.keys(this.active_streams))this.close_stream(this.active_streams[e],3)}}const I=r.CloseEvent||Event,B={};class L extends EventTarget{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};super(),this.url=e,this.protocols=t,this.options=s,this.binaryType="blob",this.stream=null,this.connection=null,this.onopen=()=>{},this.onerror=()=>{},this.onmessage=()=>{},this.onclose=()=>{},this.CONNECTING=0,this.OPEN=1,this.CLOSING=2,this.CLOSED=3,this._ready_state=this.CONNECTING;let i=this.url.split("/"),n=i.pop().split(":");this.host=n[0],this.port=parseInt(n[1]),this.real_url=i.join("/")+"/",this.init_connection()}on_conn_close(){this._ready_state=this.CLOSED,B[this.real_url]&&(this.onerror(new Event("error")),this.dispatchEvent(new Event("error"))),delete B[this.real_url]}init_connection(){if(this.connection=B[this.real_url],this.connection)if(this.connection.connected)this.connection=B[this.real_url],this.init_stream();else{let e=this.connection.onopen;this.connection.onopen=()=>{e(),this.init_stream()}}else this.connection=new k(this.real_url,this.options),this.connection.onopen=()=>{this.init_stream()},this.connection.onclose=()=>{this.on_conn_close()},this.connection.onerror=()=>{this.on_conn_close()},B[this.real_url]=this.connection}init_stream(){this._ready_state=this.OPEN,this.stream=this.connection.create_stream(this.host,this.port),this.stream.onmessage=e=>{let t;if("blob"==this.binaryType)t=new Blob(e);else{if("arraybuffer"!=this.binaryType)throw"invalid binaryType string";t=e.buffer}let s=new MessageEvent("message",{data:t});this.onmessage(s),this.dispatchEvent(s)},this.stream.onclose=e=>{this._ready_state=this.CLOSED;let t=new I("close",{code:e});this.onclose(t),this.dispatchEvent(t)};let e=new Event("open");this.onopen(e),this.dispatchEvent(e)}send(e){let t;if(e instanceof Uint8Array)t=e;else if("string"==typeof e)t=(new TextEncoder).encode(e);else{if(e instanceof Blob)return void e.arrayBuffer().then(e=>{this.send(e)});if(e instanceof ArrayBuffer)t=new Uint8Array(e);else{if(!ArrayBuffer.isView(e))throw"invalid data type to be sent";t=new Uint8Array(e.buffer)}}if(!this.stream)throw"websocket is not ready";this.stream.send(t)}close(){this.stream.close(2)}get bufferedAmount(){let e=0;for(let t of this.stream.send_buffer)e+=t.length;return e}get extensions(){return""}get protocol(){return"binary"}get readyState(){return this._ready_state}}wisp_client=t})();
//# sourceMappingURL=wisp-client-legacy.js.map