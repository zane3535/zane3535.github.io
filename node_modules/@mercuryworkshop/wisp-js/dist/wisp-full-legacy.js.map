{"version":3,"file":"wisp-full-legacy.js","mappings":"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","sources":["webpack://wisp_full/./node_modules/ipaddr.js/lib/ipaddr.js","webpack://wisp_full/webpack/bootstrap","webpack://wisp_full/webpack/runtime/define property getters","webpack://wisp_full/webpack/runtime/hasOwnProperty shorthand","webpack://wisp_full/webpack/runtime/make namespace object","webpack://wisp_full/./src/compat_browser.mjs","webpack://wisp_full/./src/packet.mjs","webpack://wisp_full/./src/extensions.mjs","webpack://wisp_full/./src/client/connection.mjs","webpack://wisp_full/./src/client/polyfill.mjs","webpack://wisp_full/./src/logging.mjs","webpack://wisp_full/./src/server/options.mjs","webpack://wisp_full/./src/websocket.mjs","webpack://wisp_full/./src/server/net.mjs","webpack://wisp_full/./src/server/filter.mjs","webpack://wisp_full/./src/server/connection.mjs","webpack://wisp_full/./src/server/wsproxy.mjs","webpack://wisp_full/./src/server/http.mjs"],"sourcesContent":["(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 18, 0, 0]), 15],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ],\n            // RFC7534, RFC7535\n            as112: [\n                [new IPv4([192, 175, 48, 0]), 24],\n                [new IPv4([192, 31, 196, 0]), 24],\n            ],\n            // RFC7450\n            amt: [\n                [new IPv4([192, 52, 193, 0]), 24],\n            ],\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv4 address in CIDR notation.\n    ipaddr.IPv4.isValidCIDR = function (string) {\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address with CIDR prefix.\n    ipaddr.IPv4.isValidCIDRFourPartDecimal = function (string) {\n        const match = string.match(/^(.+)\\/(\\d+)$/);\n\n        if (!ipaddr.IPv4.isValidCIDR(string) || !match) {\n            return false;\n        }\n\n        return ipaddr.IPv4.isValidFourPartDecimal(match[1]);\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6666\n            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC5180\n            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n            // RFC7450\n            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n            as112v6: [\n                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],\n                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],\n            ],\n            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],\n            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],\n            reserved: [\n                // RFC3849\n                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],\n                // RFC2928\n                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],\n            ],\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // Calls toRFC5952String under the hood.\n        IPv6.prototype.toString = function () {\n            return this.toRFC5952String();\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv6 address in CIDR notation.\n    ipaddr.IPv6.isValidCIDR = function (string) {\n\n        // See note in IPv6.isValid\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = match[1]\n            if (!match[1].endsWith('::')) {\n                addr = addr.slice(0, -1)\n            }\n            addr = expandIPv6(addr + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n    // Checks if the address is valid IP address in CIDR notation\n    ipaddr.isValidCIDR = function (string) {\n        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","//the node modules referenced by other parts of the code do not exist on the web\n//some of them can be replaced by the standard browser apis, others have to be ignored\n\n//compatibility for old browsers where globalThis doesn't exist\nexport const global_this = typeof globalThis === \"undefined\" ? window : globalThis;\n\nexport const WebSocket = global_this.WebSocket;\nexport const crypto = global_this.crypto;\nexport const WebSocketServer = null;\nexport const net = null;\nexport const dgram = null;\nexport const dns = null;\nexport const http = null;","//shared packet parsing / serialization code\n\nconst text_encoder = new TextEncoder();\nconst encode_text = text_encoder.encode.bind(text_encoder);\nconst text_decoder = new TextDecoder();\nconst decode_text = text_decoder.decode.bind(text_decoder);\n\nexport class WispBuffer {\n  constructor(data) {\n    if (data instanceof Uint8Array) {\n      this.from_array(data);\n    }\n    else if (typeof data === \"number\") {\n      this.from_array(new Uint8Array(data));\n    }\n    else if (typeof data === \"string\") {\n      this.from_array(encode_text(data));\n    }\n    else {\n      console.trace();\n      throw \"invalid data type passed to wisp buffer constructor\";\n    }\n  }\n\n  from_array(bytes) {\n    this.size = bytes.length;\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer); \n  }\n\n  concat(buffer) {\n    let new_buffer = new WispBuffer(this.size + buffer.size);\n    new_buffer.bytes.set(this.bytes, 0);\n    new_buffer.bytes.set(buffer.bytes, this.size);\n    return new_buffer;\n  }\n\n  slice(index, size) {\n    let bytes_slice = this.bytes.slice(index, size);\n    return new WispBuffer(bytes_slice);\n  }\n\n  get_string() {\n    return text_decoder.decode(this.bytes);\n  }\n}\n\nexport class WispPacket {\n  static min_size = 5;\n  constructor({type, stream_id, payload, payload_bytes }) {\n    this.type = type;\n    this.stream_id = stream_id;\n    this.payload_bytes = payload_bytes;\n    this.payload = payload;\n  }\n  static parse(buffer) {\n    return new WispPacket({\n      type: buffer.view.getUint8(0),\n      stream_id: buffer.view.getUint32(1, true),\n      payload_bytes: buffer.slice(5)\n    });\n  }\n  static parse_all(buffer) {\n    if (buffer.size < WispPacket.min_size) {\n      throw TypeError(\"packet too small\");\n    }\n    let packet = WispPacket.parse(buffer);\n    let payload_class = packet_classes[packet.type];\n    if (typeof payload_class === \"undefined\") {\n      throw TypeError(\"invalid packet type\");\n    }\n    if (packet.payload_bytes.size < payload_class.size) {\n      throw TypeError(\"payload too small\");\n    }\n    packet.payload = payload_class.parse(packet.payload_bytes);\n    return packet;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    buffer.view.setUint8(0, this.type);\n    buffer.view.setUint32(1, this.stream_id, true);\n    buffer = buffer.concat(this.payload.serialize());\n    return buffer;\n  }\n}\n\nexport class ConnectPayload {\n  static min_size = 3;\n  static type = 0x01;\n  static name = \"CONNECT\";\n  constructor({stream_type, port, hostname}) {\n    this.stream_type = stream_type;\n    this.port = port;\n    this.hostname = hostname;\n  }\n  static parse(buffer) {\n    return new ConnectPayload({\n      stream_type: buffer.view.getUint8(0),\n      port: buffer.view.getUint16(1, true),\n      hostname: decode_text(buffer.slice(3).bytes)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(3);\n    buffer.view.setUint8(0, this.stream_type);\n    buffer.view.setUint16(1, this.port, true);\n    buffer = buffer.concat(new WispBuffer(this.hostname));\n    return buffer;\n  }\n}\n\nexport class DataPayload {\n  static min_size = 0;\n  static type = 0x02;\n  static name = \"DATA\";\n  constructor({data}) {\n    this.data = data;\n  }\n  static parse(buffer) {\n    return new DataPayload({\n      data: buffer\n    });\n  }\n  serialize() {\n    return this.data;\n  }\n}\n\nexport class ContinuePayload {\n  static type = 0x03;\n  static name = \"CONTINUE\";\n  constructor({buffer_remaining}) {\n    this.buffer_remaining = buffer_remaining;\n  }\n  static parse(buffer) {\n    return new ContinuePayload({\n      buffer_remaining: buffer.view.getUint32(0, true),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(4);\n    buffer.view.setUint32(0, this.buffer_remaining, true);\n    return buffer;\n  }\n}\n\nexport class ClosePayload {\n  static min_size = 1;\n  static type = 0x04;\n  static name = \"CLOSE\";\n  constructor({reason}) {\n    this.reason = reason;\n  }\n  static parse(buffer) {\n    return new ClosePayload({\n      reason: buffer.view.getUint8(0),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(1);\n    buffer.view.setUint8(0, this.reason);\n    return buffer;\n  }\n}\n\nexport class InfoPayload {\n  static min_size = 2;\n  static type = 0x05;\n  static name = \"INFO\";\n  constructor({major_ver, minor_ver, extensions}) {\n    this.major_ver = major_ver;\n    this.minor_ver = minor_ver;\n    this.extensions = extensions;\n  }\n  static parse(buffer) {\n    return new InfoPayload({\n      major_ver: buffer.view.getUint8(0),\n      minor_ver: buffer.view.getUint8(1),\n      extensions: buffer.slice(2)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(2);\n    buffer.view.setUint8(0, this.major_ver);\n    buffer.view.setUint8(1, this.minor_ver);\n    return buffer.concat(this.extensions);\n  }\n}\n\nexport const packet_classes = {\n  0x01: ConnectPayload, \n  0x02: DataPayload, \n  0x03: ContinuePayload, \n  0x04: ClosePayload,\n  0x05: InfoPayload\n}\n\nexport const packet_types = {\n  CONNECT: 0x01,\n  DATA: 0x02,\n  CONTINUE: 0x03,\n  CLOSE: 0x04,\n  INFO: 0x05\n}\n\nexport const stream_types = {\n  TCP: 0x01,\n  UDP: 0x02\n}\n\nexport const close_reasons = {\n  //client/server close reasons\n  Unknown: 0x01,\n  Voluntary: 0x02,\n  NetworkError: 0x03,\n  IncompatibleExtensions: 0x04,\n\n  //server only close reasons\n  InvalidInfo: 0x41, \n  UnreachableHost: 0x42,\n  NoResponse: 0x43,\n  ConnRefused: 0x44,\n  TransferTimeout: 0x47,\n  HostBlocked: 0x48,\n  ConnThrottled: 0x49,\n\n  //client only close reasons\n  ClientError: 0x81,\n\n  //extension specific close reasons\n  AuthBadPassword: 0xc0,\n  AuthBadSignature: 0xc1,\n  AuthMissingCredentials: 0xc2\n}","import { WispBuffer } from \"./packet.mjs\";\n\nclass EmptyPayload {\n  constructor() {}\n  static parse() {\n    return new EmptyPayload();\n  }\n  serialize() {\n    return new WispBuffer(0);\n  }\n}\n\nexport class BaseExtension {\n  static id = 0x00;\n  static name = \"\";\n\n  static Server = EmptyPayload;\n  static Client = EmptyPayload;\n\n  constructor({server_config, client_config} = {}) {\n    this.id = this.constructor.id;\n    this.name = this.constructor.name;\n    if (server_config)\n      this.payload = new this.constructor.Server(server_config);\n    else if (client_config)\n      this.payload = new this.constructor.Client(client_config);\n  }\n  static parse(ext_class, buffer, role) {\n    let extension = new ext_class({});\n    if (role === \"client\")\n      extension.payload = ext_class.Client.parse(buffer.slice(5));\n    else if (role === \"server\")\n      extension.payload = ext_class.Server.parse(buffer.slice(5));\n    else \n      throw TypeError(\"invalid role\");\n    return extension;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    let payload_buffer = this.payload.serialize();\n    buffer.view.setInt8(0, this.constructor.id);\n    buffer.view.setUint32(1, payload_buffer.size, true);\n    return buffer.concat(payload_buffer);\n  }\n}\n\nexport class UDPExtension extends BaseExtension {\n  static id = 0x01;\n  static name = \"UDP\";\n}\n\nexport class PasswordAuthExtension extends BaseExtension {\n  static id = 0x02;\n  static name = \"Password Authentication\";\n\n  static Server = class {\n    constructor({required = 1}) {\n      this.required = required ? 1 : 0;\n    }\n    static parse(buffer) {\n      return new PasswordAuthExtension.Server({\n        required: buffer.view.getUint8(0)\n      });\n    }\n    serialize() {\n      let buffer = new WispBuffer(1);\n      buffer.view.setUint8(0, this.required);\n      return buffer;\n    }\n  }\n\n  static Client = class {\n    constructor({username, password}) {\n      this.username = username;\n      this.password = password;\n    }\n    static parse(buffer) {\n      let username_len = buffer.view.getUint8(0);\n      let password_len = buffer.view.getUint16(1, true);\n      let password_index = username_len + 3;\n      return new PasswordAuthExtension.Client({\n        username: buffer.slice(3, username_len).get_string(),\n        password: buffer.slice(password_index, password_len).get_string()\n      });\n    }\n    serialize() {\n      let username_buffer = new WispBuffer(this.username);\n      let password_buffer = new WispBuffer(this.password);\n      let buffer = new WispBuffer(3);\n      buffer.view.setUint8(0, username_buffer.size);\n      buffer.view.setUint16(1, password_buffer.size, true);\n      return buffer.concat(username_buffer).concat(password_buffer);\n    }\n  }\n}\n\nexport class MOTDExtension extends BaseExtension {\n  static id = 0x04;\n  static name = \"Server MOTD\";\n\n  static Server = class {\n    constructor({message}) {\n      this.message = message;\n    }\n    static parse(buffer) {\n      return new MOTDExtension.Server({\n        message: buffer.get_string()\n      });\n    }\n    serialize() {\n      return new WispBuffer(this.message);\n    }\n  }\n\n  static Client = EmptyPayload;\n}\n\nexport function parse_extensions(payload_buffer, valid_extensions, role) {\n  let index = 0;\n  let parsed_extensions = [];\n  while (payload_buffer.size) {\n    let ext_id = payload_buffer.view.getUint8(index);\n    let ext_len = payload_buffer.view.getUint32(index + 1, true);\n    let ext_payload = payload_buffer.slice(0, 5 + ext_len);\n    let ext_class;\n    for (let extension of valid_extensions) {\n      if (extension.id !== ext_id) \n        continue;\n      ext_class = extension.constructor;\n      break;\n    }\n    if (ext_class) {\n      let ext_parsed = BaseExtension.parse(ext_class, ext_payload, role);\n      parsed_extensions.push(ext_parsed);\n    }\n    payload_buffer = payload_buffer.slice(5 + ext_len);\n  }\n  return parsed_extensions;\n}\n\nexport function serialize_extensions(extensions) {{\n  let ext_buffer = new WispBuffer(0);\n  for (let extension of extensions) {\n    ext_buffer = ext_buffer.concat(extension.serialize());\n  }\n  return ext_buffer;\n}}\n\nexport const extensions_map = {\n  0x01: UDPExtension,\n  0x02: PasswordAuthExtension,\n  0x04: MOTDExtension\n}","import * as compat from \"../compat.mjs\";\n\nimport {\n  packet_classes,\n  packet_types,\n  stream_types,\n  WispBuffer, \n  WispPacket, \n  ConnectPayload, \n  DataPayload, \n  ClosePayload,\n  InfoPayload\n} from \"../packet.mjs\";\n\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nclass ClientStream {\n  constructor(hostname, port, websocket, buffer_size, stream_id, connection, stream_type) {\n    this.hostname = hostname;\n    this.port = port;\n    this.ws = websocket;\n    this.buffer_size = buffer_size;\n    this.stream_id = stream_id;\n    this.connection = connection;\n    this.stream_type = stream_type;\n    this.send_buffer = [];\n    this.open = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onmessage = () => {};\n  }\n\n  send(data) {\n    //note: udp shouldn't buffer anything\n    if (this.buffer_size > 0 || !this.open || this.stream_type === stream_types.UDP) {\n      //construct and send a DATA packet\n      let packet = new WispPacket({\n        type: packet_types.DATA,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(data)\n        })\n      });\n      this.ws.send(packet.serialize().bytes);\n      this.buffer_size--;\n    }\n    else { //server is slow, don't send data yet\n      this.send_buffer.push(data);\n    }\n  }\n\n  //handle receiving a CONTINUE packet\n  continue_received(buffer_size) {\n    this.buffer_size = buffer_size;\n    //send buffered data now\n    while (this.buffer_size > 0 && this.send_buffer.length > 0) {\n      this.send(this.send_buffer.shift());\n    }\n  }\n\n  //construct and send a CLOSE packet\n  close(reason = 0x01) {\n    if (!this.open) return;\n    let packet = new WispPacket({\n      type: packet_types.CLOSE,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    this.open = false;\n    delete this.connection.active_streams[this.stream_id];\n  }\n}\n\nexport class ClientConnection {\n  constructor(wisp_url, {wisp_version, wisp_extensions} = {}) {\n    if (!wisp_url.endsWith(\"/\")) {\n      throw new TypeError(\"wisp endpoints must end with a trailing forward slash\");\n    }\n\n    this.wisp_url = wisp_url;\n    this.wisp_version = wisp_version || 2;\n    this.wisp_extensions = wisp_extensions || null;\n\n    this.max_buffer_size = null;\n    this.active_streams = {};\n    this.connected = false;\n    this.connecting = false;\n    this.next_stream_id = 1;\n\n    this.server_exts = {};\n    this.client_exts = {};\n    this.info_received = false;\n    this.server_motd = null;\n    this.udp_enabled = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n\n    this.connect_ws();\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    this.wisp_extensions.push(new UDPExtension({client_config: {}}));\n    this.wisp_extensions.push(new MOTDExtension({client_config: {}}));\n  }\n\n  connect_ws() {\n    let subprotocol = this.wisp_version === 2 ? \"wisp-v2\" : undefined;\n    this.ws = new compat.WebSocket(this.wisp_url, subprotocol);\n    this.ws.binaryType = \"arraybuffer\";\n    this.connecting = true;\n\n    this.ws.onerror = () => {\n      if (this.wisp_version === 2) {\n        this.ws.onclose = null;\n        this.cleanup();\n        this.wisp_version = 1;\n        this.connect_ws();\n        return;\n      }\n      this.cleanup();\n      this.onerror();\n    };\n    this.ws.onclose = () => {\n      this.cleanup();\n      this.onclose();\n    };\n    this.ws.onmessage = (event) => {\n      this.on_ws_msg(event);\n      if (this.connected && this.connecting) {\n        this.connecting = false;\n        this.onopen();\n      }\n    };\n  }\n\n  close() {\n    this.ws.close();\n  }\n\n  create_stream(hostname, port, type=0x01) {\n    let stream_type = type;\n    if (typeof stream_type === \"string\") \n      stream_type = type === \"udp\" ? stream_types.UDP : stream_types.TCP;\n\n    if (stream_type == stream_types.UDP && !this.udp_enabled) {\n      throw new Error(\"udp is not enabled for this wisp connection\");\n    }\n\n    let stream_id = this.next_stream_id++;\n    let stream = new ClientStream(hostname, port, this.ws, this.max_buffer_size, stream_id, this, stream_type);\n    this.active_streams[stream_id] = stream;\n    stream.open = this.connected;\n\n    //construct CONNECT packet\n    let packet = new WispPacket({\n      type: packet_types.CONNECT,\n      stream_id: stream_id,\n      payload: new ConnectPayload({\n        stream_type: stream_type,\n        port: port,\n        hostname: hostname\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    return stream;\n  }\n\n  close_stream(stream, reason) {\n    stream.onclose(reason);\n    delete this.active_streams[stream.stream_id];\n  }\n\n  on_ws_msg(event) {\n    let buffer = new WispBuffer(new Uint8Array(event.data));\n    if (buffer.size < WispPacket.min_size) {\n      console.warn(`wisp client warning: received a packet which is too short`);\n      return;\n    }\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.active_streams[packet.stream_id];\n    if (packet.stream_id === 0 && this.connecting) {\n      if (packet.type === packet_types.CONTINUE) {\n        this.max_buffer_size = packet.payload.buffer_remaining;\n        this.connected = true;\n        if (!this.info_received) {\n          this.wisp_version = 1;\n        }\n      }\n      \n      if (packet.type === packet_types.INFO && this.wisp_version === 2) {\n        let server_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"server\");\n        for (let server_ext of server_extensions) {\n          for (let client_ext of this.wisp_extensions) {\n            if (server_ext.id === client_ext.id) {\n              this.server_exts[server_ext.id] = server_ext;\n              this.client_exts[client_ext.id] = client_ext;\n            }\n          }\n        }\n\n        this.info_received = true; \n        this.server_motd = this.server_exts[MOTDExtension.id]?.payload?.message;\n        this.udp_enabled = !!this.server_exts[UDPExtension.id];\n\n        let ext_buffer = serialize_extensions(this.wisp_extensions);\n        let info_packet = new WispPacket({\n          type: InfoPayload.type,\n          stream_id: 0,\n          payload: new InfoPayload({\n            major_ver: this.wisp_version,\n            minor_ver: 0,\n            extensions: ext_buffer\n          })\n        });\n        this.ws.send(info_packet.serialize().bytes);\n      }\n      return;\n    }\n\n    if (typeof stream === \"undefined\") {\n      console.warn(`wisp client warning: received a ${packet_classes[packet.type].name} packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === packet_types.DATA) {\n      stream.onmessage(packet.payload_bytes.bytes);\n    }\n\n    else if (packet.type === packet_types.CONTINUE) { //other CONTINUE packets\n      stream.continue_received(packet.payload.buffer_remaining);\n    }\n\n    else if (packet.type === packet_types.CLOSE) {\n      this.close_stream(stream, packet.payload.reason);\n    }\n\n    else {\n      console.warn(`wisp client warning: received an invalid packet of type ${packet.type}`);\n    }\n  }\n\n  cleanup() {\n    this.connected = false;\n    this.connecting = false;\n    for (let stream_id of Object.keys(this.active_streams)) {\n      this.close_stream(this.active_streams[stream_id], 0x03);\n    }\n  }\n}\n\n","import { global_this } from \"../compat.mjs\";\nimport { ClientConnection } from \"./connection.mjs\";\n\n//polyfill the DOM Websocket API so that applications using wsproxy can easily use wisp with minimal changes\n\nconst RealCloseEvent = (global_this.CloseEvent || Event);\nexport const _wisp_connections = {};\n\nexport class WispWebSocket extends EventTarget {\n  constructor(url, protocols=null, options = {}) {\n    super();\n    this.url = url;\n    this.protocols = protocols;\n    this.options = options;\n    this.binaryType = \"blob\";\n    this.stream = null;\n    this.connection = null;\n\n    //legacy event handlers\n    this.onopen = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n    this.onclose = () => {};\n\n    this.CONNECTING = 0;\n    this.OPEN = 1;\n    this.CLOSING = 2;\n    this.CLOSED = 3;\n    this._ready_state = this.CONNECTING;\n\n    //parse the wsproxy url\n    let url_split = this.url.split(\"/\");\n    let wsproxy_path = url_split.pop().split(\":\");\n    this.host = wsproxy_path[0];\n    this.port = parseInt(wsproxy_path[1]);\n    this.real_url = url_split.join(\"/\") + \"/\";\n\n    this.init_connection();\n  }\n\n  on_conn_close() {\n    this._ready_state = this.CLOSED;\n    if (_wisp_connections[this.real_url]) {\n      this.onerror(new Event(\"error\"));\n      this.dispatchEvent(new Event(\"error\"));\n    }\n    delete _wisp_connections[this.real_url];\n  }\n\n  init_connection() {\n    //create the stream\n    this.connection = _wisp_connections[this.real_url];\n\n    if (!this.connection) {\n      this.connection = new ClientConnection(this.real_url, this.options);\n      this.connection.onopen = () => {\n        this.init_stream();\n      };\n      this.connection.onclose = () => {\n        this.on_conn_close()\n      };\n      this.connection.onerror = () => {\n        this.on_conn_close()\n      };\n      _wisp_connections[this.real_url] = this.connection;\n    }\n    else if (!this.connection.connected) {\n      let old_onopen = this.connection.onopen;\n      this.connection.onopen = () => {\n        old_onopen();\n        this.init_stream();\n      };\n    }\n    else {\n      this.connection = _wisp_connections[this.real_url];\n      this.init_stream();\n    }\n  }\n\n  init_stream() {\n    this._ready_state = this.OPEN;\n    this.stream = this.connection.create_stream(this.host, this.port);\n\n    this.stream.onmessage = (raw_data) => {\n      let data;\n      if (this.binaryType == \"blob\") {\n        data = new Blob(raw_data);\n      }\n      else if (this.binaryType == \"arraybuffer\") {\n        data = raw_data.buffer;\n      }\n      else {\n        throw \"invalid binaryType string\";\n      }\n      let msg_event = new MessageEvent(\"message\", {data: data});\n      this.onmessage(msg_event);\n      this.dispatchEvent(msg_event);\n    };\n\n    this.stream.onclose = (reason) => {\n      this._ready_state = this.CLOSED;\n      let close_event = new RealCloseEvent(\"close\", {code: reason}); \n      this.onclose(close_event);\n      this.dispatchEvent(close_event);\n    };\n\n    let open_event = new Event(\"open\");\n    this.onopen(open_event);\n    this.dispatchEvent(open_event);\n  }\n\n  send(data) {\n    let data_array;\n\n    if (data instanceof Uint8Array) {\n      data_array = data;  \n    }\n    else if (typeof data === \"string\") {\n      data_array = new TextEncoder().encode(data);\n    }\n    else if (data instanceof Blob) {\n      data.arrayBuffer().then(array_buffer => {\n        this.send(array_buffer);\n      });\n      return;\n    }\n    else if (data instanceof ArrayBuffer) {\n      data_array = new Uint8Array(data);\n    }\n    //dataview objects or any other typedarray\n    else if (ArrayBuffer.isView(data)) {\n      data_array = new Uint8Array(data.buffer);\n    }\n    else {\n      throw \"invalid data type to be sent\";\n    }\n\n    if (!this.stream) {\n      throw \"websocket is not ready\";\n    }\n    this.stream.send(data_array);\n  }\n\n  close() {\n    this.stream.close(0x02);\n  }\n\n  get bufferedAmount() {\n    let total = 0;\n    for (let msg of this.stream.send_buffer) {\n      total += msg.length;\n    }\n    return total;\n  }\n\n  get extensions() {\n    return \"\";\n  }\n\n  get protocol() {\n    return \"binary\";\n  }\n\n  get readyState() {\n    return this._ready_state;\n  }\n}","export const DEBUG = 0;\nexport const INFO = 1;\nexport const WARN = 2;\nexport const ERROR = 3;\nexport const NONE = 4;\nexport let log_level = INFO;\n\nexport function get_timestamp() {\n  let [date, time] = new Date().toJSON().split(\"T\");\n  date = date.replaceAll(\"-\", \"/\");\n  time = time.split(\".\")[0];\n  return `[${date} - ${time}]`;\n}\n\nexport function set_level(level) {\n  log_level = level;\n}\n\nexport function debug(...messages) {\n  if (log_level > DEBUG) return;\n  console.debug(get_timestamp() + \" debug:\", ...messages);\n}\n\nexport function info(...messages) {\n  if (log_level > INFO) return;\n  console.info(get_timestamp() + \" info:\", ...messages);\n}\n\nexport function log(...messages) {\n  if (log_level > INFO) return;\n  console.log(get_timestamp() + \" log:\", ...messages);\n}\n\nexport function warn(...messages) {\n  if (log_level > WARN) return;\n  console.warn(get_timestamp() + \" warn:\", ...messages);\n}\n\nexport function error(...messages) {\n  if (log_level > ERROR) return;\n  console.error(get_timestamp() + \" error:\", ...messages);\n}\n\n","export const options = {\n  //destination hostname restrictions\n  hostname_blacklist: null,\n  hostname_whitelist: null,\n  port_blacklist: null,\n  port_whitelist: null,\n  allow_direct_ip: true,\n  allow_private_ips: false,\n  allow_loopback_ips: false,\n  \n  //client connection restrictions\n  client_ip_blacklist: null, //not implemented!\n  client_ip_whitelist: null, //not implemented!\n  stream_limit_per_host: -1,\n  stream_limit_total: -1,\n  allow_udp_streams: true,\n  allow_tcp_streams: true,\n\n  //dns options\n  dns_ttl: 120,\n  dns_method: \"lookup\",\n  dns_servers: null,\n  dns_result_order: \"verbatim\",\n\n  //misc options\n  parse_real_ip: true,\n  parse_real_ip_from: [\"127.0.0.1\"],\n\n  //wisp v2 options\n  wisp_version: 2,\n  wisp_motd: null\n}\n\n","//async websocket wrapper for both node and the browser\n\nimport * as compat from \"./compat.mjs\";\nimport { WispPacket } from \"./packet.mjs\";\n\nexport function get_conn_id() {\n  return compat.crypto.randomUUID().split(\"-\")[0];\n}\n\n//an async websocket wrapper\nexport class AsyncWebSocket {\n  send_buffer_size = 32*1024*1024;\n  \n  constructor(ws) {\n    this.ws = ws;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(1);\n  }\n\n  async connect() {\n    await new Promise((resolve, reject) => {\n      this.ws.onopen = () => {\n        this.connected = true;\n        resolve();\n      }\n      this.ws.onmessage = (event) => {\n        this.data_queue.put(event.data);\n      }\n      this.ws.onclose = () => {\n        if (!this.connected) reject();\n        else this.data_queue.close();\n      }\n      if (this.ws.readyState === this.ws.OPEN) {\n        this.connected = true;\n        resolve();\n      }\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    if (data instanceof WispPacket) {\n      data = data.serialize().bytes\n    }\n\n    this.ws.send(data);\n    if (this.ws.bufferedAmount <= this.send_buffer_size) {\n      return;\n    }\n\n    //if the send buffer is too full, throttle the upload\n    while (true) {\n      if (this.ws.bufferedAmount <= this.send_buffer_size / 2) {\n        break;\n      }\n      await new Promise((resolve) => {setTimeout(resolve, 10)});\n    }\n  }\n\n  close(code, reason) {\n    this.ws.close(code, reason);\n    this.data_queue.close();\n  }\n\n  get buffered_amount() {\n    return this.ws.bufferedAmount;\n  }\n}\n\n//an async fifo queue\nexport class AsyncQueue {\n  constructor(max_size) {\n    this.max_size = max_size;\n    this.queue = [];\n    this.put_callbacks = [];\n    this.get_callbacks = [];\n  }\n\n  put_now(data) {\n    this.queue.push(data);\n    this.get_callbacks.shift()?.();\n  }\n\n  async put(data) {\n    if (this.size <= this.max_size) {\n      this.put_now(data);\n      return;\n    }\n\n    //wait until there is a place to put the item\n    await new Promise((resolve) => {\n      this.put_callbacks.push(resolve);\n    });\n    this.put_now(data);\n  }\n\n  get_now() {\n    this.put_callbacks.shift()?.();\n    return this.queue.shift();\n  }\n\n  async get() {\n    if (this.size > 0) {\n      return this.get_now();\n    }\n\n    //wait until there is an item available in the queue\n    await new Promise((resolve) => {\n      this.get_callbacks.push(resolve);\n    });\n    return this.get_now();\n  }\n\n  close() {\n    this.queue = [];\n    let callback;\n    //resolve all pending operations\n    while (callback = this.get_callbacks.shift())\n      callback();\n    while (callback = this.put_callbacks.shift())\n      callback();\n  }\n\n  get size() {\n    return this.queue.length;\n  }\n}","import * as logging from \"../logging.mjs\";\nimport { AsyncQueue } from \"../websocket.mjs\";\nimport { options } from \"./options.mjs\";\nimport { net, dgram, dns } from \"../compat.mjs\";\n\n//wrappers for node networking apis\n//in the browser these can be redefined to allow for custom transports\n\nexport const is_node = (typeof process !== \"undefined\");\n\nconst dns_cache = new Map();\nlet dns_servers = null;\nlet resolver = null;\n\nexport function assert_on_node() {\n  if (!is_node) {\n    throw new Error(\"not running on node.js\");\n  }\n}\n\n//wrapper for node resolver methods\n//resolve4 and resolve6 need to be wrapped to work around a nodejs bug\nfunction resolve4(hostname) {\n  return resolver.resolve4(hostname);\n}\nfunction resolve6(hostname) {\n  return resolver.resolve6(hostname);\n}\nasync function resolve_with_fallback(resolve_first, resolve_after, hostname) {\n  try {\n    return (await resolve_first(hostname))[0];\n  }\n  catch {\n    return (await resolve_after(hostname))[0];\n  }\n}  \n\n//a wrapper for the actual dns lookup\nasync function perform_lookup(hostname) {\n  //resolve using system dns\n  if (options.dns_method === \"lookup\") {\n    let result = await dns.lookup(hostname, {order: options.dns_result_order}); \n    return result.address;\n  }\n\n  //resolve using dns.resolve4 / dns.resolve6, which bypasses the system dns\n  else if (options.dns_method === \"resolve\") {\n    //we need to make a new resolver at first run because setServers doesn't work otherwise\n    if (!resolver) resolver = new dns.Resolver();\n\n    //set custom dns servers if needed\n    if (options.dns_servers !== dns_servers) {\n      logging.debug(\"Setting custom DNS servers to: \" + options.dns_servers.join(\", \"));\n      resolver.setServers(options.dns_servers);\n      dns_servers = options.dns_servers;\n    }\n\n    if (options.dns_result_order === \"verbatim\" || options.dns_result_order === \"ipv6first\") \n      return await resolve_with_fallback(resolve6, resolve4, hostname);\n    else if (options.dns_result_order === \"ipv4first\")\n      return await resolve_with_fallback(resolve4, resolve6, hostname);\n    else\n      throw new Error(\"Invalid result order. options.dns_result_order must be either 'ipv6first', 'ipv4first', or 'verbatim'.\");\n  }\n\n  //use a custom function for dns resolution\n  else if (typeof options.dns_method === \"function\") {\n    return await options.dns_method(hostname);\n  }\n\n  throw new Error(\"Invalid DNS method. options.dns_method must either be 'lookup' or 'resolve'.\");\n}\n\n//perform a dns lookup and use the cache\nexport async function lookup_ip(hostname) {\n  if (!is_node) { //we cannot do the dns lookup on the browser\n    return hostname;\n  }\n\n  let ip_level = net.isIP(hostname);\n  if (ip_level === 4 || ip_level === 6) {\n    return hostname; //hostname is already an ip address\n  }\n\n  //remove stale entries from the cache\n  let now = Date.now();\n  for (let [entry_hostname, cache_entry] of dns_cache) {\n    let ttl = now - cache_entry.time;\n    if (ttl > options.dns_ttl) {\n      dns_cache.delete(entry_hostname);\n    }\n  }\n\n  //look in the cache first before using the system resolver\n  let cache_entry = dns_cache.get(hostname);\n  if (cache_entry) {\n    if (cache_entry.error) \n      throw cache_entry.error\n    return cache_entry.address;\n  }\n\n  //try to perform the actual dns lookup and store the result\n  let address;\n  try {\n    address = await perform_lookup(hostname);\n    logging.debug(`Domain resolved: ${hostname} -> ${address}`);\n    dns_cache.set(hostname, {time: Date.now(), address: address});\n  }\n  catch (e) {\n    dns_cache.set(hostname, {time: Date.now(), error: e});\n    throw e;\n  }\n\n  return address;\n}\n\n//async tcp and udp socket wrappers\nexport class NodeTCPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n    this.recv_buffer_size = 128;\n\n    this.socket = null;\n    this.paused = false;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    await new Promise((resolve, reject) => {\n      this.socket = new net.Socket();\n      this.socket.setNoDelay(true);\n      this.socket.on(\"connect\", () => {\n        this.connected = true;\n        resolve();\n      });\n      this.socket.on(\"data\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"close\", (error) => {\n        if (error && !this.connected) reject();\n        else this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.on(\"error\", (error) => {\n        logging.warn(`tcp stream to ${this.hostname} ended with error - ${error}`);\n      });\n      this.socket.on(\"end\", () => {\n        if (!this.socket) return;\n        this.socket.destroy();\n        this.socket = null;\n      });\n      this.socket.connect({\n        host: ip,\n        port: this.port\n      });\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    await new Promise((resolve) => {\n      this.socket.write(data, resolve);\n    });\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.end();\n    this.socket = null;\n  }\n\n  pause() {\n    if (this.data_queue.size >= this.data_queue.max_size) {\n      this.socket.pause();\n      this.paused = true;\n    }\n  }\n  resume() {\n    if (!this.socket) return;\n    if (this.paused) {\n      this.socket.resume();\n      this.paused = false;\n    }\n  }\n}\n\nexport class NodeUDPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n\n    this.connected = false;\n    this.recv_buffer_size = 128;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    let ip_level = net.isIP(ip);\n    await new Promise((resolve, reject) => {\n      this.socket = dgram.createSocket(ip_level === 6 ? \"udp6\" : \"udp4\");\n      this.socket.on(\"connect\", () => {\n        resolve();\n      });\n      this.socket.on(\"message\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"error\", () => {\n        if (!this.connected) reject();\n        this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.connect(this.port, ip);\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    this.socket.send(data);\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.close();\n    this.socket = null;\n  }\n\n  pause() {}\n  resume() {}\n}","import { close_reasons, stream_types } from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport * as net from \"./net.mjs\";\n\nimport ipaddr from \"ipaddr.js\";\n\nexport class AccessDeniedError extends Error {}\n\n//helper functions for the whitelist/blacklist logic\nfunction check_port_range(entry, port) {\n  return (entry === port) || (entry[0] <= port && entry[1] >= port)\n}\nfunction check_whitelist(entries, filter) {\n  let matched = false;\n  for (let entry of entries) {\n    if (filter(entry)) {\n      matched = true;\n      break\n    }\n  }\n  return !matched;\n}\nfunction check_blacklist(entries, filter) {\n  for (let entry of entries) {\n    if (filter(entry))\n      return true;\n    }\n  return false;\n}\n\nfunction check_ip_range(ip, range) {\n  return range.includes(ip.range());\n}\n\n//check if an ip is blocked\nexport function is_ip_blocked(ip_str) {\n  if (!ipaddr.isValid(ip_str)) \n    return false;\n  let ip = ipaddr.parse(ip_str);\n\n  let loopback_ranges = [\"loopback\", \"unspecified\"];\n  let private_ranges = [\"broadcast\", \"linkLocal\", \"carrierGradeNat\", \"private\", \"reserved\"];\n\n  if (!options.allow_loopback_ips && check_ip_range(ip, loopback_ranges)) \n    return true;\n  if (!options.allow_private_ips && check_ip_range(ip, private_ranges)) \n    return true;\n  return false;\n}\n\n//returns the close reason if the connection should be blocked\nexport async function is_stream_allowed(connection, type, hostname, port) {\n  //check if tcp or udp should be blocked\n  if (!options.allow_tcp_streams && type === stream_types.TCP)\n    return close_reasons.HostBlocked;\n  if (!options.allow_udp_streams && type === stream_types.UDP)\n    return close_reasons.HostBlocked;\n\n  //check the hostname whitelist/blacklist\n  if (options.hostname_whitelist) {\n    if (check_whitelist(options.hostname_whitelist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n  else if (options.hostname_blacklist) {\n    if (check_blacklist(options.hostname_blacklist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the port is blocked\n  if (options.port_whitelist) {\n    if (check_whitelist(options.port_whitelist, (entry) => check_port_range(entry, port))) \n      return close_reasons.HostBlocked;\n  }\n  else if (options.port_blacklist) {\n    if (check_blacklist(options.port_blacklist, (entry) => check_port_range(entry, port)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the destination ip is blocked\n  let ip_str = hostname;\n  if (ipaddr.isValid(hostname)) {\n    if (!options.allow_direct_ip)\n      return close_reasons.HostBlocked;\n  }\n  else {\n    try { //look up the ip to make sure that the resolved address is allowed\n      ip_str = await net.lookup_ip(hostname);\n    }\n    catch {}\n  }\n  if (is_ip_blocked(ip_str)) \n    return close_reasons.HostBlocked;\n\n  //don't check stream counts if there isn't an associated wisp connection (with wsproxy for example)\n  if (!connection) \n    return 0;\n\n  //check for stream count limits\n  if (options.stream_limit_total !== -1 && Object.keys(connection.streams).length >= options.stream_limit_total) \n    return close_reasons.ConnThrottled;\n  if (options.stream_limit_per_host !== -1) {\n    let streams_per_host = 0;\n    for (let stream of connection.streams) {\n      if (stream.socket.hostname === hostname) {\n        streams_per_host++;\n      }\n    }\n    if (streams_per_host >= options.stream_limit_per_host)\n      return close_reasons.ConnThrottled;\n  }\n\n  return 0;\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { AsyncQueue, AsyncWebSocket, get_conn_id } from \"../websocket.mjs\";\nimport { NodeTCPSocket, NodeUDPSocket } from \"./net.mjs\";\nimport { \n  WispBuffer,\n  WispPacket,\n  ContinuePayload,\n  ClosePayload,\n  ConnectPayload,\n  DataPayload,\n  InfoPayload,\n  stream_types,\n  close_reasons\n} from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nexport class HandshakeError extends Error {}\n\nexport class ServerStream {\n  static buffer_size = 128;\n\n  constructor(stream_id, conn, socket) {\n    this.stream_id = stream_id;\n    this.conn = conn;\n    this.socket = socket;    \n    this.send_buffer = new AsyncQueue(ServerStream.buffer_size);\n    this.packets_sent = 0;\n  }\n\n  async setup() {\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a tcp/udp to ws task encountered an error - ${error}`);\n      this.close();\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a ws to tcp/udp task encountered an error - ${error}`);\n      this.close();\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n\n      this.socket.pause();\n      let packet = new WispPacket({\n        type: DataPayload.type,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(new Uint8Array(data))\n        })\n      });\n      await this.conn.ws.send(packet);\n      this.socket.resume();\n    }\n    await this.conn.close_stream(this.stream_id, close_reasons.Voluntary);\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data = await this.send_buffer.get();\n      if (data == null) {\n        break; //stream closed\n      }\n      await this.socket.send(data);\n\n      this.packets_sent++;\n      if (this.packets_sent % (ServerStream.buffer_size / 2) !== 0) {\n        continue;\n      }\n      let packet = new WispPacket({\n        type: ContinuePayload.type,\n        stream_id: this.stream_id,\n        payload: new ContinuePayload({\n          buffer_remaining: ServerStream.buffer_size - this.send_buffer.size\n        })\n      });\n      this.conn.ws.send(packet);\n    }\n    await this.close();\n  }\n\n  async close(reason = null) {\n    this.send_buffer.close();\n    this.socket.close();\n    if (reason == null) return;\n\n    let packet = new WispPacket({\n      type: ClosePayload.type,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    await this.conn.ws.send(packet);\n  }\n\n  async put_data(data) {\n    await this.send_buffer.put(data);\n  }\n}\n\nexport class ServerConnection {\n  constructor(ws, path, {TCPSocket, UDPSocket, ping_interval, wisp_version, wisp_extensions} = {}) {\n    this.ws = new AsyncWebSocket(ws);\n    this.path = path;\n    this.TCPSocket = TCPSocket || NodeTCPSocket;\n    this.UDPSocket = UDPSocket || NodeUDPSocket;\n    this.ping_interval = ping_interval || 30;\n    this.wisp_version = wisp_version || options.wisp_version;\n    this.wisp_extensions = wisp_extensions || null;\n    \n    this.ping_task = null;\n    this.streams = {};\n    this.conn_id = get_conn_id();\n\n    this.server_exts = {};\n    this.client_exts = {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    if (options.allow_udp_streams) \n      this.wisp_extensions.push(new UDPExtension({server_config: {}}));\n    if (options.wisp_motd)\n      this.wisp_extensions.push(new MOTDExtension({server_config: {\n        message: options.wisp_motd\n      }}));\n  }\n\n  async setup() {\n    logging.info(`setting up new wisp v${this.wisp_version} connection with id ${this.conn_id}`);\n\n    await this.ws.connect();\n    if (this.wisp_version == 2) {\n      await this.setup_wisp_v2()\n    }\n\n    //send initial continue packet\n    let continue_packet = new WispPacket({\n      type: ContinuePayload.type,\n      stream_id: 0,\n      payload: new ContinuePayload({\n        buffer_remaining: ServerStream.buffer_size\n      })\n    });\n    this.ws.send(continue_packet);\n\n    if (typeof this.ws.ws.ping === \"function\") {\n      this.ping_task = setInterval(() => {\n        logging.debug(`(${this.conn_id}) sending websocket ping`);\n        this.ws.ws.ping();\n      }, this.ping_interval * 1000);  \n    }\n  }\n\n  async setup_wisp_v2() {\n    //send initial info packet for wisp v2\n    let ext_buffer = serialize_extensions(this.wisp_extensions);\n    let info_packet = new WispPacket({\n      type: InfoPayload.type,\n      stream_id: 0,\n      payload: new InfoPayload({\n        major_ver: this.wisp_version,\n        minor_ver: 0,\n        extensions: ext_buffer\n      })\n    });\n    this.ws.send(info_packet);\n\n    //wait for the client's info packet\n    let data = await this.ws.recv();\n    if (data == null) {\n      logging.warn(`(${this.conn_id}) handshake error: ws closed before handshake complete`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n    let buffer = new WispBuffer(new Uint8Array(data));\n    let packet = WispPacket.parse_all(buffer);\n\n    if (packet.type !== InfoPayload.type) {\n      logging.warn(`(${this.conn_id}) handshake error: unexpected packet of type ${packet.type}`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n\n    //figure out the common extensions\n    let client_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"client\");\n    for (let client_ext of client_extensions) {\n      for (let server_ext of this.wisp_extensions) {\n        if (server_ext.id === client_ext.id) {\n          this.server_exts[server_ext.id] = server_ext;\n          this.client_exts[client_ext.id] = client_ext;\n        }\n      }\n    }\n  }\n\n  create_stream(stream_id, type, hostname, port) {\n    let SocketImpl = type === stream_types.TCP ? this.TCPSocket : this.UDPSocket;\n    let socket = new SocketImpl(hostname, port);\n    let stream = new ServerStream(stream_id, this, socket);\n    this.streams[stream_id] = stream;\n\n    //start connecting to the destination server in the background\n    (async () => {\n      let close_reason = await filter.is_stream_allowed(this, type, hostname, port);\n      if (close_reason) {\n        logging.warn(`(${this.conn_id}) refusing to create a stream to ${hostname}:${port}`);\n        await this.close_stream(stream_id, close_reason, true);\n        return;\n      }\n      try {\n        await stream.setup();\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) creating a stream to ${hostname}:${port} failed - ${error}`);\n        await this.close_stream(stream_id, close_reasons.NetworkError);\n      }\n    })();\n  }\n\n  async close_stream(stream_id, reason = null, quiet = false) {\n    let stream = this.streams[stream_id];\n    if (stream == null) {\n      return;\n    }\n    if (reason && !quiet) {\n      logging.info(`(${this.conn_id}) closing stream to ${stream.socket.hostname} for reason ${reason}`);\n    }\n    await stream.close(reason);\n    delete this.streams[stream_id];\n  }\n\n  route_packet(buffer) {\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.streams[packet.stream_id];\n\n    if (stream == null && packet.type == DataPayload.type) {\n      logging.warn(`(${this.conn_id}) received a DATA packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === ConnectPayload.type) {\n      let type_info = packet.payload.stream_type === stream_types.TCP ? \"TCP\" : \"UDP\";\n      logging.info(`(${this.conn_id}) opening new ${type_info} stream to ${packet.payload.hostname}:${packet.payload.port}`);\n      this.create_stream(\n        packet.stream_id, \n        packet.payload.stream_type, \n        packet.payload.hostname.trim(), \n        packet.payload.port\n      )\n    }\n\n    else if (packet.type === DataPayload.type) {\n      stream.put_data(packet.payload.data.bytes);\n    }\n\n    else if (packet.type == ContinuePayload.type) {\n      logging.warn(`(${this.conn_id}) client sent a CONTINUE packet, this should never be possible`);\n    }\n\n    else if (packet.type == ClosePayload.type) {\n      this.close_stream(packet.stream_id, packet.reason);\n    }\n  }\n\n  async run() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      if (typeof data === \"string\") {\n        logging.warn(`(${this.conn_id}) routing a packet failed - unexpected ws text frame`);\n        continue;\n      }\n      \n      try {\n        //note: data is an arraybuffer so the uint8array constructor does not copy\n        this.route_packet(new WispBuffer(new Uint8Array(data)));\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) routing a packet failed - ${error}`);\n      }\n    }\n    \n    await this.cleanup();\n  }\n\n  async cleanup() {\n    //clean up all streams when the websocket is closed\n    for (let stream_id of Object.keys(this.streams)) {\n      await this.close_stream(stream_id);\n    }\n    clearInterval(this.ping_task);\n    logging.info(`(${this.conn_id}) wisp connection closed`);\n    this.ws.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { stream_types } from \"../packet.mjs\";\nimport { AsyncWebSocket } from \"../websocket.mjs\";\nimport { NodeTCPSocket } from \"./net.mjs\";\n\nexport class WSProxyConnection {\n  constructor(ws, path) {\n    let [hostname, port] = path.split(\"/\").pop().split(\":\");\n    this.hostname = hostname.trim();\n    this.port = parseInt(port);\n    this.ws = new AsyncWebSocket(ws);\n  }\n\n  async setup() {\n    await this.ws.connect();\n\n    //check that the destination host/ip is allowed\n    let err_code = await filter.is_stream_allowed(null, stream_types.TCP, this.hostname, this.port);\n    if (err_code !== 0) {\n      logging.info(`Refusing to create a wsproxy connection to ${this.hostname}:${this.port}`);\n      this.ws.close();\n      throw new filter.AccessDeniedError();\n    }\n\n    //connect to the tcp host after we are certain that it's safe to do so\n    this.socket = new NodeTCPSocket(this.hostname, this.port);\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`a tcp to ws task (wsproxy) encountered an error - ${error}`);\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`a ws to tcp task (wsproxy) encountered an error - ${error}`);\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n      this.socket.pause();\n      await this.ws.send(data);\n      this.socket.resume();\n    }\n    await this.ws.close();\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      await this.socket.send(data);\n    }\n    await this.socket.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as compat from \"../compat.mjs\";\n\nimport { options } from \"./options.mjs\";\nimport { AccessDeniedError } from \"./filter.mjs\";\nimport { ServerConnection, HandshakeError } from \"./connection.mjs\";\nimport { WSProxyConnection } from \"./wsproxy.mjs\";\nimport { is_node, assert_on_node } from \"./net.mjs\";\n\nlet ws_server = null;\nif (is_node) {\n  ws_server = new compat.WebSocketServer({ noServer: true });\n}\n\nexport function parse_real_ip(headers, client_ip) {\n  if (options.parse_real_ip && options.parse_real_ip_from.includes(client_ip)) {\n    if (headers[\"x-forwarded-for\"]) {\n      return headers[\"x-forwarded-for\"].split(\",\")[0].trim();\n    }\n    else if (headers[\"x-real-ip\"]) {\n      return headers[\"x-real-ip\"];\n    }\n  }\n  return client_ip;\n}\n\nexport function routeRequest(request, socket, head, conn_options={}) {\n  assert_on_node();\n  if (request.headers[\"sec-websocket-protocol\"] && options.wisp_version === 2)\n    conn_options.wisp_version = 2;\n  else \n    conn_options.wisp_version = 1;\n\n  if (request instanceof compat.http.IncomingMessage) {\n    ws_server.handleUpgrade(request, socket, head, (ws) => {\n      create_connection(ws, request.url, request, conn_options);\n    });\n  }\n  else if (request instanceof compat.WebSocket) {\n    create_connection(ws, \"/\", {}), conn_options;\n  }\n}\n\nasync function create_connection(ws, path, request, conn_options) {\n  ws.binaryType = \"arraybuffer\";\n  let client_ip = request.socket.address().address;\n  let real_ip = parse_real_ip(request.headers, client_ip);\n  let origin = request.headers[\"origin\"];\n  logging.info(`new connection on ${path} from ${real_ip} (origin: ${origin})`);\n  \n  try {\n    if (path.endsWith(\"/\")) {\n      let wisp_conn = new ServerConnection(ws, path, conn_options);\n      await wisp_conn.setup();\n      await wisp_conn.run();\n    }\n  \n    else {\n      let wsproxy = new WSProxyConnection(ws, path, conn_options);\n      await wsproxy.setup();\n    }\n  }\n\n  catch (error) {\n    ws.close();\n    if (error instanceof HandshakeError) return;\n    if (error instanceof AccessDeniedError) return;\n    logging.error(\"Uncaught server error:\\n\" + (error.stack || error));\n  }\n}"],"names":["root","ipv4Part","ipv4Regexes","fourOctet","RegExp","threeOctet","twoOctet","longValue","octalRegex","hexRegex","zoneIndex","ipv6Part","ipv6Regexes","deprecatedTransitional","transitional","expandIPv6","string","parts","indexOf","lastIndexOf","replacement","replacementCount","colonCount","lastColon","zoneId","match","substring","replace","substr","slice","length","ref","split","results","i","push","parseInt","matchCIDR","first","second","partSize","cidrBits","Error","shift","part","parseIntAuto","test","isNaN","padPart","ipaddr","IPv4","octets","octet","this","prototype","SpecialRanges","unspecified","broadcast","multicast","linkLocal","loopback","carrierGradeNat","reserved","as112","amt","kind","other","cidrRange","undefined","prefixLengthFromSubnetMask","cidr","stop","zerotable","zeros","range","subnetMatch","toByteArray","toIPv4MappedAddress","IPv6","parse","toString","toNormalizedString","join","broadcastAddressFromCIDR","parseCIDR","ipInterfaceOctets","subnetMaskOctets","subnetMaskFromPrefixLength","e","isIPv4","parser","isValid","isValidCIDR","isValidFourPartDecimal","isValidCIDRFourPartDecimal","networkAddressFromCIDR","maskLength","parsed","Object","defineProperty","value","reverse","prefix","j","filledOctetCount","Math","floor","pow","uniqueLocal","ipv4Mapped","discard","rfc6145","rfc6052","teredo","benchmarking","as112v6","deprecated","orchid2","droneRemoteIdProtocolEntityTags","isIPv4MappedAddress","bytes","toFixedLengthString","addr","call","suffix","toIPv4Address","high","low","toRFC5952String","regex","bestMatchIndex","bestMatchLength","exec","index","isIPv6","native","endsWith","fromByteArray","e2","process","address","rangeList","defaultName","rangeName","rangeSubnets","subnet","hasOwnProperty","Array","apply","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","key","o","enumerable","get","obj","prop","r","Symbol","toStringTag","global_this","globalThis","window","WebSocket","crypto","net","http","text_encoder","TextEncoder","encode_text","encode","bind","text_decoder","TextDecoder","decode_text","decode","WispBuffer","constructor","data","Uint8Array","from_array","console","trace","size","view","DataView","buffer","concat","new_buffer","set","bytes_slice","get_string","WispPacket","_ref","type","stream_id","payload","payload_bytes","getUint8","getUint32","parse_all","min_size","TypeError","packet","payload_class","packet_classes","serialize","setUint8","setUint32","_defineProperty","ConnectPayload","_ref2","stream_type","port","hostname","getUint16","setUint16","DataPayload","_ref3","ContinuePayload","_ref4","buffer_remaining","ClosePayload","_ref5","reason","InfoPayload","_ref6","major_ver","minor_ver","extensions","packet_types","CONNECT","DATA","CONTINUE","CLOSE","INFO","stream_types","TCP","UDP","close_reasons","Unknown","Voluntary","NetworkError","IncompatibleExtensions","InvalidInfo","UnreachableHost","NoResponse","ConnRefused","TransferTimeout","HostBlocked","ConnThrottled","ClientError","AuthBadPassword","AuthBadSignature","AuthMissingCredentials","EmptyPayload","BaseExtension","server_config","client_config","arguments","id","name","Server","Client","ext_class","role","extension","payload_buffer","setInt8","UDPExtension","PasswordAuthExtension","_PasswordAuthExtension","required","username","password","username_len","password_len","password_index","username_buffer","password_buffer","MOTDExtension","parse_extensions","valid_extensions","parsed_extensions","ext_id","ext_len","ext_payload","ext_parsed","serialize_extensions","ext_buffer","_MOTDExtension","message","extensions_map","ClientStream","websocket","buffer_size","connection","ws","send_buffer","open","onopen","onclose","onmessage","send","continue_received","close","active_streams","ClientConnection","wisp_url","wisp_version","wisp_extensions","max_buffer_size","connected","connecting","next_stream_id","server_exts","client_exts","info_received","server_motd","udp_enabled","onerror","add_extensions","connect_ws","subprotocol","compat","binaryType","cleanup","event","on_ws_msg","create_stream","stream","close_stream","warn","_this$server_exts$MOT","server_extensions","server_ext","client_ext","info_packet","keys","RealCloseEvent","CloseEvent","Event","_wisp_connections","WispWebSocket","EventTarget","url","protocols","options","super","CONNECTING","OPEN","CLOSING","CLOSED","_ready_state","url_split","wsproxy_path","pop","host","real_url","init_connection","on_conn_close","dispatchEvent","init_stream","old_onopen","raw_data","Blob","msg_event","MessageEvent","close_event","code","open_event","data_array","arrayBuffer","then","array_buffer","ArrayBuffer","isView","bufferedAmount","total","msg","protocol","readyState","ERROR","log_level","get_timestamp","date","time","Date","toJSON","replaceAll","debug","_len","messages","_key","info","_len2","_key2","_len4","_key4","error","_len5","_key5","hostname_blacklist","hostname_whitelist","port_blacklist","port_whitelist","allow_direct_ip","allow_private_ips","allow_loopback_ips","client_ip_blacklist","client_ip_whitelist","stream_limit_per_host","stream_limit_total","allow_udp_streams","allow_tcp_streams","dns_ttl","dns_method","dns_servers","dns_result_order","parse_real_ip","parse_real_ip_from","wisp_motd","AsyncWebSocket","data_queue","AsyncQueue","connect","Promise","resolve","reject","put","recv","send_buffer_size","setTimeout","buffered_amount","max_size","queue","put_callbacks","get_callbacks","put_now","_this$get_callbacks$s","get_now","_this$put_callbacks$s","callback","is_node","dns_cache","Map","resolver","assert_on_node","resolve4","resolve6","async","resolve_with_fallback","resolve_first","resolve_after","_unused","lookup_ip","ip_level","isIP","now","entry_hostname","cache_entry","delete","lookup","order","Resolver","logging","setServers","perform_lookup","NodeTCPSocket","recv_buffer_size","socket","paused","ip","Socket","setNoDelay","on","destroy","write","end","pause","resume","NodeUDPSocket","createSocket","AccessDeniedError","check_port_range","entry","check_whitelist","entries","filter","matched","check_blacklist","check_ip_range","includes","is_stream_allowed","ip_str","is_ip_blocked","streams","streams_per_host","HandshakeError","ServerStream","conn","packets_sent","setup","tcp_to_ws","catch","conn_id","ws_to_tcp","put_data","ServerConnection","path","TCPSocket","UDPSocket","ping_interval","ping_task","randomUUID","setup_wisp_v2","continue_packet","ping","setInterval","client_extensions","close_reason","quiet","route_packet","type_info","trim","run","clearInterval","WSProxyConnection","ws_server","headers","client_ip","routeRequest","request","head","conn_options","IncomingMessage","handleUpgrade","create_connection","wisp_conn","wsproxy","stack","noServer"],"ignoreList":[],"sourceRoot":""}