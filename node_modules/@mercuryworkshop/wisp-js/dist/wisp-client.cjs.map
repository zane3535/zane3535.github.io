{"version":3,"file":"wisp-client.cjs","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA,MAAM,2BAA4B,iB;;ACAlC,MAAM,+BAA4B,qB;;ACAlC,MAAM,kCAA4B,wB;;ACAlC,MAAM,iCAA4B,uB;;ACAlC,MAAM,mCAA4B,yB;;ACAlC,MAAM,wBAA4B,gC;;ACAlC;AACA;;AAEO;;AAEyC;AACf;;AAEC;AACF;AACI;;;ACVpC;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA,eAAe,yCAAyC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;ACzO0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA,eAAe,8BAA8B,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,gCAAgC,UAAU;AAC1C,gCAAgC,UAAU;AAC1C,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,C;;ACxJwC;;AAYjB;;AAEiF;;AAExG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,YAAY;AAC/E;AACA,uBAAuB,UAAU;AACjC,cAAc,YAAY;AAC1B;AACA,qBAAqB,WAAW;AAChC,oBAAoB,UAAU;AAC9B,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,YAAY,YAAY;AACxB;AACA,mBAAmB,YAAY;AAC/B;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP,yBAAyB,+BAA+B,IAAI;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC,YAAY,EAAE,kBAAkB;AAClE,kCAAkC,aAAa,EAAE,kBAAkB;AACnE;;AAEA;AACA;AACA,kBAAkB,qCAAgB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,YAAY,OAAO,YAAY;;AAEpE,uBAAuB,YAAY;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B,YAAY,YAAY;AACxB;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B,sBAAsB,UAAU;AAChC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,aAAa;AACzD,8CAA8C,YAAY;;AAE1D,yBAAyB,oBAAoB;AAC7C,8BAA8B,UAAU;AACxC,gBAAgB,WAAW;AAC3B;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,cAAc,oBAAoB;AACxF;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;;AAEA,6BAA6B,YAAY,aAAa;AACtD;AACA;;AAEA,6BAA6B,YAAY;AACzC;AACA;;AAEA;AACA,8EAA8E,YAAY;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpQ4C;AACQ;;AAEpD;;AAEA,wBAAwB,WAAW;AAC5B;;AAEA;AACP,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;ACtKoD;;;ACAN;AACN","sources":["webpack://@mercuryworkshop/wisp-js/webpack/bootstrap","webpack://@mercuryworkshop/wisp-js/webpack/runtime/define property getters","webpack://@mercuryworkshop/wisp-js/webpack/runtime/hasOwnProperty shorthand","webpack://@mercuryworkshop/wisp-js/webpack/runtime/make namespace object","webpack://@mercuryworkshop/wisp-js/external commonjs \"ws\"","webpack://@mercuryworkshop/wisp-js/external commonjs \"crypto\"","webpack://@mercuryworkshop/wisp-js/external node-commonjs \"node:http\"","webpack://@mercuryworkshop/wisp-js/external node-commonjs \"node:net\"","webpack://@mercuryworkshop/wisp-js/external node-commonjs \"node:dgram\"","webpack://@mercuryworkshop/wisp-js/external node-commonjs \"node:dns/promises\"","webpack://@mercuryworkshop/wisp-js/./src/compat.mjs","webpack://@mercuryworkshop/wisp-js/./src/packet.mjs","webpack://@mercuryworkshop/wisp-js/./src/extensions.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/connection.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/polyfill.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/index.mjs","webpack://@mercuryworkshop/wisp-js/./src/entrypoints/client.mjs"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"ws\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"crypto\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:http\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:net\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:dgram\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:dns/promises\");","//this file contains references to external node modules\n//it gets replaced with ./compat_browser.mjs when being bundled for the web\n\nexport const global_this = globalThis;\n\nexport { WebSocket, WebSocketServer } from \"ws\";\nexport * as crypto from \"crypto\";\n\nexport * as http from \"node:http\";\nexport * as net from \"node:net\";\nexport * as dgram from \"node:dgram\";\nexport * as dns from \"node:dns/promises\";","//shared packet parsing / serialization code\n\nconst text_encoder = new TextEncoder();\nconst encode_text = text_encoder.encode.bind(text_encoder);\nconst text_decoder = new TextDecoder();\nconst decode_text = text_decoder.decode.bind(text_decoder);\n\nexport class WispBuffer {\n  constructor(data) {\n    if (data instanceof Uint8Array) {\n      this.from_array(data);\n    }\n    else if (typeof data === \"number\") {\n      this.from_array(new Uint8Array(data));\n    }\n    else if (typeof data === \"string\") {\n      this.from_array(encode_text(data));\n    }\n    else {\n      console.trace();\n      throw \"invalid data type passed to wisp buffer constructor\";\n    }\n  }\n\n  from_array(bytes) {\n    this.size = bytes.length;\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer); \n  }\n\n  concat(buffer) {\n    let new_buffer = new WispBuffer(this.size + buffer.size);\n    new_buffer.bytes.set(this.bytes, 0);\n    new_buffer.bytes.set(buffer.bytes, this.size);\n    return new_buffer;\n  }\n\n  slice(index, size) {\n    let bytes_slice = this.bytes.slice(index, size);\n    return new WispBuffer(bytes_slice);\n  }\n\n  get_string() {\n    return text_decoder.decode(this.bytes);\n  }\n}\n\nexport class WispPacket {\n  static min_size = 5;\n  constructor({type, stream_id, payload, payload_bytes }) {\n    this.type = type;\n    this.stream_id = stream_id;\n    this.payload_bytes = payload_bytes;\n    this.payload = payload;\n  }\n  static parse(buffer) {\n    return new WispPacket({\n      type: buffer.view.getUint8(0),\n      stream_id: buffer.view.getUint32(1, true),\n      payload_bytes: buffer.slice(5)\n    });\n  }\n  static parse_all(buffer) {\n    if (buffer.size < WispPacket.min_size) {\n      throw TypeError(\"packet too small\");\n    }\n    let packet = WispPacket.parse(buffer);\n    let payload_class = packet_classes[packet.type];\n    if (typeof payload_class === \"undefined\") {\n      throw TypeError(\"invalid packet type\");\n    }\n    if (packet.payload_bytes.size < payload_class.size) {\n      throw TypeError(\"payload too small\");\n    }\n    packet.payload = payload_class.parse(packet.payload_bytes);\n    return packet;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    buffer.view.setUint8(0, this.type);\n    buffer.view.setUint32(1, this.stream_id, true);\n    buffer = buffer.concat(this.payload.serialize());\n    return buffer;\n  }\n}\n\nexport class ConnectPayload {\n  static min_size = 3;\n  static type = 0x01;\n  static name = \"CONNECT\";\n  constructor({stream_type, port, hostname}) {\n    this.stream_type = stream_type;\n    this.port = port;\n    this.hostname = hostname;\n  }\n  static parse(buffer) {\n    return new ConnectPayload({\n      stream_type: buffer.view.getUint8(0),\n      port: buffer.view.getUint16(1, true),\n      hostname: decode_text(buffer.slice(3).bytes)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(3);\n    buffer.view.setUint8(0, this.stream_type);\n    buffer.view.setUint16(1, this.port, true);\n    buffer = buffer.concat(new WispBuffer(this.hostname));\n    return buffer;\n  }\n}\n\nexport class DataPayload {\n  static min_size = 0;\n  static type = 0x02;\n  static name = \"DATA\";\n  constructor({data}) {\n    this.data = data;\n  }\n  static parse(buffer) {\n    return new DataPayload({\n      data: buffer\n    });\n  }\n  serialize() {\n    return this.data;\n  }\n}\n\nexport class ContinuePayload {\n  static type = 0x03;\n  static name = \"CONTINUE\";\n  constructor({buffer_remaining}) {\n    this.buffer_remaining = buffer_remaining;\n  }\n  static parse(buffer) {\n    return new ContinuePayload({\n      buffer_remaining: buffer.view.getUint32(0, true),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(4);\n    buffer.view.setUint32(0, this.buffer_remaining, true);\n    return buffer;\n  }\n}\n\nexport class ClosePayload {\n  static min_size = 1;\n  static type = 0x04;\n  static name = \"CLOSE\";\n  constructor({reason}) {\n    this.reason = reason;\n  }\n  static parse(buffer) {\n    return new ClosePayload({\n      reason: buffer.view.getUint8(0),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(1);\n    buffer.view.setUint8(0, this.reason);\n    return buffer;\n  }\n}\n\nexport class InfoPayload {\n  static min_size = 2;\n  static type = 0x05;\n  static name = \"INFO\";\n  constructor({major_ver, minor_ver, extensions}) {\n    this.major_ver = major_ver;\n    this.minor_ver = minor_ver;\n    this.extensions = extensions;\n  }\n  static parse(buffer) {\n    return new InfoPayload({\n      major_ver: buffer.view.getUint8(0),\n      minor_ver: buffer.view.getUint8(1),\n      extensions: buffer.slice(2)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(2);\n    buffer.view.setUint8(0, this.major_ver);\n    buffer.view.setUint8(1, this.minor_ver);\n    return buffer.concat(this.extensions);\n  }\n}\n\nexport const packet_classes = {\n  0x01: ConnectPayload, \n  0x02: DataPayload, \n  0x03: ContinuePayload, \n  0x04: ClosePayload,\n  0x05: InfoPayload\n}\n\nexport const packet_types = {\n  CONNECT: 0x01,\n  DATA: 0x02,\n  CONTINUE: 0x03,\n  CLOSE: 0x04,\n  INFO: 0x05\n}\n\nexport const stream_types = {\n  TCP: 0x01,\n  UDP: 0x02\n}\n\nexport const close_reasons = {\n  //client/server close reasons\n  Unknown: 0x01,\n  Voluntary: 0x02,\n  NetworkError: 0x03,\n  IncompatibleExtensions: 0x04,\n\n  //server only close reasons\n  InvalidInfo: 0x41, \n  UnreachableHost: 0x42,\n  NoResponse: 0x43,\n  ConnRefused: 0x44,\n  TransferTimeout: 0x47,\n  HostBlocked: 0x48,\n  ConnThrottled: 0x49,\n\n  //client only close reasons\n  ClientError: 0x81,\n\n  //extension specific close reasons\n  AuthBadPassword: 0xc0,\n  AuthBadSignature: 0xc1,\n  AuthMissingCredentials: 0xc2\n}","import { WispBuffer } from \"./packet.mjs\";\n\nclass EmptyPayload {\n  constructor() {}\n  static parse() {\n    return new EmptyPayload();\n  }\n  serialize() {\n    return new WispBuffer(0);\n  }\n}\n\nexport class BaseExtension {\n  static id = 0x00;\n  static name = \"\";\n\n  static Server = EmptyPayload;\n  static Client = EmptyPayload;\n\n  constructor({server_config, client_config} = {}) {\n    this.id = this.constructor.id;\n    this.name = this.constructor.name;\n    if (server_config)\n      this.payload = new this.constructor.Server(server_config);\n    else if (client_config)\n      this.payload = new this.constructor.Client(client_config);\n  }\n  static parse(ext_class, buffer, role) {\n    let extension = new ext_class({});\n    if (role === \"client\")\n      extension.payload = ext_class.Client.parse(buffer.slice(5));\n    else if (role === \"server\")\n      extension.payload = ext_class.Server.parse(buffer.slice(5));\n    else \n      throw TypeError(\"invalid role\");\n    return extension;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    let payload_buffer = this.payload.serialize();\n    buffer.view.setInt8(0, this.constructor.id);\n    buffer.view.setUint32(1, payload_buffer.size, true);\n    return buffer.concat(payload_buffer);\n  }\n}\n\nexport class UDPExtension extends BaseExtension {\n  static id = 0x01;\n  static name = \"UDP\";\n}\n\nexport class PasswordAuthExtension extends BaseExtension {\n  static id = 0x02;\n  static name = \"Password Authentication\";\n\n  static Server = class {\n    constructor({required = 1}) {\n      this.required = required ? 1 : 0;\n    }\n    static parse(buffer) {\n      return new PasswordAuthExtension.Server({\n        required: buffer.view.getUint8(0)\n      });\n    }\n    serialize() {\n      let buffer = new WispBuffer(1);\n      buffer.view.setUint8(0, this.required);\n      return buffer;\n    }\n  }\n\n  static Client = class {\n    constructor({username, password}) {\n      this.username = username;\n      this.password = password;\n    }\n    static parse(buffer) {\n      let username_len = buffer.view.getUint8(0);\n      let password_len = buffer.view.getUint16(1, true);\n      let password_index = username_len + 3;\n      return new PasswordAuthExtension.Client({\n        username: buffer.slice(3, username_len).get_string(),\n        password: buffer.slice(password_index, password_len).get_string()\n      });\n    }\n    serialize() {\n      let username_buffer = new WispBuffer(this.username);\n      let password_buffer = new WispBuffer(this.password);\n      let buffer = new WispBuffer(3);\n      buffer.view.setUint8(0, username_buffer.size);\n      buffer.view.setUint16(1, password_buffer.size, true);\n      return buffer.concat(username_buffer).concat(password_buffer);\n    }\n  }\n}\n\nexport class MOTDExtension extends BaseExtension {\n  static id = 0x04;\n  static name = \"Server MOTD\";\n\n  static Server = class {\n    constructor({message}) {\n      this.message = message;\n    }\n    static parse(buffer) {\n      return new MOTDExtension.Server({\n        message: buffer.get_string()\n      });\n    }\n    serialize() {\n      return new WispBuffer(this.message);\n    }\n  }\n\n  static Client = EmptyPayload;\n}\n\nexport function parse_extensions(payload_buffer, valid_extensions, role) {\n  let index = 0;\n  let parsed_extensions = [];\n  while (payload_buffer.size) {\n    let ext_id = payload_buffer.view.getUint8(index);\n    let ext_len = payload_buffer.view.getUint32(index + 1, true);\n    let ext_payload = payload_buffer.slice(0, 5 + ext_len);\n    let ext_class;\n    for (let extension of valid_extensions) {\n      if (extension.id !== ext_id) \n        continue;\n      ext_class = extension.constructor;\n      break;\n    }\n    if (ext_class) {\n      let ext_parsed = BaseExtension.parse(ext_class, ext_payload, role);\n      parsed_extensions.push(ext_parsed);\n    }\n    payload_buffer = payload_buffer.slice(5 + ext_len);\n  }\n  return parsed_extensions;\n}\n\nexport function serialize_extensions(extensions) {{\n  let ext_buffer = new WispBuffer(0);\n  for (let extension of extensions) {\n    ext_buffer = ext_buffer.concat(extension.serialize());\n  }\n  return ext_buffer;\n}}\n\nexport const extensions_map = {\n  0x01: UDPExtension,\n  0x02: PasswordAuthExtension,\n  0x04: MOTDExtension\n}","import * as compat from \"../compat.mjs\";\n\nimport {\n  packet_classes,\n  packet_types,\n  stream_types,\n  WispBuffer, \n  WispPacket, \n  ConnectPayload, \n  DataPayload, \n  ClosePayload,\n  InfoPayload\n} from \"../packet.mjs\";\n\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nclass ClientStream {\n  constructor(hostname, port, websocket, buffer_size, stream_id, connection, stream_type) {\n    this.hostname = hostname;\n    this.port = port;\n    this.ws = websocket;\n    this.buffer_size = buffer_size;\n    this.stream_id = stream_id;\n    this.connection = connection;\n    this.stream_type = stream_type;\n    this.send_buffer = [];\n    this.open = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onmessage = () => {};\n  }\n\n  send(data) {\n    //note: udp shouldn't buffer anything\n    if (this.buffer_size > 0 || !this.open || this.stream_type === stream_types.UDP) {\n      //construct and send a DATA packet\n      let packet = new WispPacket({\n        type: packet_types.DATA,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(data)\n        })\n      });\n      this.ws.send(packet.serialize().bytes);\n      this.buffer_size--;\n    }\n    else { //server is slow, don't send data yet\n      this.send_buffer.push(data);\n    }\n  }\n\n  //handle receiving a CONTINUE packet\n  continue_received(buffer_size) {\n    this.buffer_size = buffer_size;\n    //send buffered data now\n    while (this.buffer_size > 0 && this.send_buffer.length > 0) {\n      this.send(this.send_buffer.shift());\n    }\n  }\n\n  //construct and send a CLOSE packet\n  close(reason = 0x01) {\n    if (!this.open) return;\n    let packet = new WispPacket({\n      type: packet_types.CLOSE,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    this.open = false;\n    delete this.connection.active_streams[this.stream_id];\n  }\n}\n\nexport class ClientConnection {\n  constructor(wisp_url, {wisp_version, wisp_extensions} = {}) {\n    if (!wisp_url.endsWith(\"/\")) {\n      throw new TypeError(\"wisp endpoints must end with a trailing forward slash\");\n    }\n\n    this.wisp_url = wisp_url;\n    this.wisp_version = wisp_version || 2;\n    this.wisp_extensions = wisp_extensions || null;\n\n    this.max_buffer_size = null;\n    this.active_streams = {};\n    this.connected = false;\n    this.connecting = false;\n    this.next_stream_id = 1;\n\n    this.server_exts = {};\n    this.client_exts = {};\n    this.info_received = false;\n    this.server_motd = null;\n    this.udp_enabled = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n\n    this.connect_ws();\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    this.wisp_extensions.push(new UDPExtension({client_config: {}}));\n    this.wisp_extensions.push(new MOTDExtension({client_config: {}}));\n  }\n\n  connect_ws() {\n    let subprotocol = this.wisp_version === 2 ? \"wisp-v2\" : undefined;\n    this.ws = new compat.WebSocket(this.wisp_url, subprotocol);\n    this.ws.binaryType = \"arraybuffer\";\n    this.connecting = true;\n\n    this.ws.onerror = () => {\n      if (this.wisp_version === 2) {\n        this.ws.onclose = null;\n        this.cleanup();\n        this.wisp_version = 1;\n        this.connect_ws();\n        return;\n      }\n      this.cleanup();\n      this.onerror();\n    };\n    this.ws.onclose = () => {\n      this.cleanup();\n      this.onclose();\n    };\n    this.ws.onmessage = (event) => {\n      this.on_ws_msg(event);\n      if (this.connected && this.connecting) {\n        this.connecting = false;\n        this.onopen();\n      }\n    };\n  }\n\n  close() {\n    this.ws.close();\n  }\n\n  create_stream(hostname, port, type=0x01) {\n    let stream_type = type;\n    if (typeof stream_type === \"string\") \n      stream_type = type === \"udp\" ? stream_types.UDP : stream_types.TCP;\n\n    if (stream_type == stream_types.UDP && !this.udp_enabled) {\n      throw new Error(\"udp is not enabled for this wisp connection\");\n    }\n\n    let stream_id = this.next_stream_id++;\n    let stream = new ClientStream(hostname, port, this.ws, this.max_buffer_size, stream_id, this, stream_type);\n    this.active_streams[stream_id] = stream;\n    stream.open = this.connected;\n\n    //construct CONNECT packet\n    let packet = new WispPacket({\n      type: packet_types.CONNECT,\n      stream_id: stream_id,\n      payload: new ConnectPayload({\n        stream_type: stream_type,\n        port: port,\n        hostname: hostname\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    return stream;\n  }\n\n  close_stream(stream, reason) {\n    stream.onclose(reason);\n    delete this.active_streams[stream.stream_id];\n  }\n\n  on_ws_msg(event) {\n    let buffer = new WispBuffer(new Uint8Array(event.data));\n    if (buffer.size < WispPacket.min_size) {\n      console.warn(`wisp client warning: received a packet which is too short`);\n      return;\n    }\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.active_streams[packet.stream_id];\n    if (packet.stream_id === 0 && this.connecting) {\n      if (packet.type === packet_types.CONTINUE) {\n        this.max_buffer_size = packet.payload.buffer_remaining;\n        this.connected = true;\n        if (!this.info_received) {\n          this.wisp_version = 1;\n        }\n      }\n      \n      if (packet.type === packet_types.INFO && this.wisp_version === 2) {\n        let server_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"server\");\n        for (let server_ext of server_extensions) {\n          for (let client_ext of this.wisp_extensions) {\n            if (server_ext.id === client_ext.id) {\n              this.server_exts[server_ext.id] = server_ext;\n              this.client_exts[client_ext.id] = client_ext;\n            }\n          }\n        }\n\n        this.info_received = true; \n        this.server_motd = this.server_exts[MOTDExtension.id]?.payload?.message;\n        this.udp_enabled = !!this.server_exts[UDPExtension.id];\n\n        let ext_buffer = serialize_extensions(this.wisp_extensions);\n        let info_packet = new WispPacket({\n          type: InfoPayload.type,\n          stream_id: 0,\n          payload: new InfoPayload({\n            major_ver: this.wisp_version,\n            minor_ver: 0,\n            extensions: ext_buffer\n          })\n        });\n        this.ws.send(info_packet.serialize().bytes);\n      }\n      return;\n    }\n\n    if (typeof stream === \"undefined\") {\n      console.warn(`wisp client warning: received a ${packet_classes[packet.type].name} packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === packet_types.DATA) {\n      stream.onmessage(packet.payload_bytes.bytes);\n    }\n\n    else if (packet.type === packet_types.CONTINUE) { //other CONTINUE packets\n      stream.continue_received(packet.payload.buffer_remaining);\n    }\n\n    else if (packet.type === packet_types.CLOSE) {\n      this.close_stream(stream, packet.payload.reason);\n    }\n\n    else {\n      console.warn(`wisp client warning: received an invalid packet of type ${packet.type}`);\n    }\n  }\n\n  cleanup() {\n    this.connected = false;\n    this.connecting = false;\n    for (let stream_id of Object.keys(this.active_streams)) {\n      this.close_stream(this.active_streams[stream_id], 0x03);\n    }\n  }\n}\n\n","import { global_this } from \"../compat.mjs\";\nimport { ClientConnection } from \"./connection.mjs\";\n\n//polyfill the DOM Websocket API so that applications using wsproxy can easily use wisp with minimal changes\n\nconst RealCloseEvent = (global_this.CloseEvent || Event);\nexport const _wisp_connections = {};\n\nexport class WispWebSocket extends EventTarget {\n  constructor(url, protocols=null, options = {}) {\n    super();\n    this.url = url;\n    this.protocols = protocols;\n    this.options = options;\n    this.binaryType = \"blob\";\n    this.stream = null;\n    this.connection = null;\n\n    //legacy event handlers\n    this.onopen = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n    this.onclose = () => {};\n\n    this.CONNECTING = 0;\n    this.OPEN = 1;\n    this.CLOSING = 2;\n    this.CLOSED = 3;\n    this._ready_state = this.CONNECTING;\n\n    //parse the wsproxy url\n    let url_split = this.url.split(\"/\");\n    let wsproxy_path = url_split.pop().split(\":\");\n    this.host = wsproxy_path[0];\n    this.port = parseInt(wsproxy_path[1]);\n    this.real_url = url_split.join(\"/\") + \"/\";\n\n    this.init_connection();\n  }\n\n  on_conn_close() {\n    this._ready_state = this.CLOSED;\n    if (_wisp_connections[this.real_url]) {\n      this.onerror(new Event(\"error\"));\n      this.dispatchEvent(new Event(\"error\"));\n    }\n    delete _wisp_connections[this.real_url];\n  }\n\n  init_connection() {\n    //create the stream\n    this.connection = _wisp_connections[this.real_url];\n\n    if (!this.connection) {\n      this.connection = new ClientConnection(this.real_url, this.options);\n      this.connection.onopen = () => {\n        this.init_stream();\n      };\n      this.connection.onclose = () => {\n        this.on_conn_close()\n      };\n      this.connection.onerror = () => {\n        this.on_conn_close()\n      };\n      _wisp_connections[this.real_url] = this.connection;\n    }\n    else if (!this.connection.connected) {\n      let old_onopen = this.connection.onopen;\n      this.connection.onopen = () => {\n        old_onopen();\n        this.init_stream();\n      };\n    }\n    else {\n      this.connection = _wisp_connections[this.real_url];\n      this.init_stream();\n    }\n  }\n\n  init_stream() {\n    this._ready_state = this.OPEN;\n    this.stream = this.connection.create_stream(this.host, this.port);\n\n    this.stream.onmessage = (raw_data) => {\n      let data;\n      if (this.binaryType == \"blob\") {\n        data = new Blob(raw_data);\n      }\n      else if (this.binaryType == \"arraybuffer\") {\n        data = raw_data.buffer;\n      }\n      else {\n        throw \"invalid binaryType string\";\n      }\n      let msg_event = new MessageEvent(\"message\", {data: data});\n      this.onmessage(msg_event);\n      this.dispatchEvent(msg_event);\n    };\n\n    this.stream.onclose = (reason) => {\n      this._ready_state = this.CLOSED;\n      let close_event = new RealCloseEvent(\"close\", {code: reason}); \n      this.onclose(close_event);\n      this.dispatchEvent(close_event);\n    };\n\n    let open_event = new Event(\"open\");\n    this.onopen(open_event);\n    this.dispatchEvent(open_event);\n  }\n\n  send(data) {\n    let data_array;\n\n    if (data instanceof Uint8Array) {\n      data_array = data;  \n    }\n    else if (typeof data === \"string\") {\n      data_array = new TextEncoder().encode(data);\n    }\n    else if (data instanceof Blob) {\n      data.arrayBuffer().then(array_buffer => {\n        this.send(array_buffer);\n      });\n      return;\n    }\n    else if (data instanceof ArrayBuffer) {\n      data_array = new Uint8Array(data);\n    }\n    //dataview objects or any other typedarray\n    else if (ArrayBuffer.isView(data)) {\n      data_array = new Uint8Array(data.buffer);\n    }\n    else {\n      throw \"invalid data type to be sent\";\n    }\n\n    if (!this.stream) {\n      throw \"websocket is not ready\";\n    }\n    this.stream.send(data_array);\n  }\n\n  close() {\n    this.stream.close(0x02);\n  }\n\n  get bufferedAmount() {\n    let total = 0;\n    for (let msg of this.stream.send_buffer) {\n      total += msg.length;\n    }\n    return total;\n  }\n\n  get extensions() {\n    return \"\";\n  }\n\n  get protocol() {\n    return \"binary\";\n  }\n\n  get readyState() {\n    return this._ready_state;\n  }\n}","export { ClientConnection } from \"./connection.mjs\";\nexport { WispWebSocket, _wisp_connections } from \"./polyfill.mjs\";","export * as client from \"../client/index.mjs\";\nexport * as packet from \"../packet.mjs\";\nexport * as extensions from \"../extensions.mjs\";"],"names":[],"ignoreList":[],"sourceRoot":""}