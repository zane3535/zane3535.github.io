{"version":3,"file":"wisp-full.mjs","mappings":"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","sources":["webpack://@mercuryworkshop/wisp-js/./node_modules/ipaddr.js/lib/ipaddr.js","webpack://@mercuryworkshop/wisp-js/webpack/bootstrap","webpack://@mercuryworkshop/wisp-js/webpack/runtime/define property getters","webpack://@mercuryworkshop/wisp-js/webpack/runtime/hasOwnProperty shorthand","webpack://@mercuryworkshop/wisp-js/webpack/runtime/make namespace object","webpack://@mercuryworkshop/wisp-js/./src/compat_browser.mjs","webpack://@mercuryworkshop/wisp-js/./src/packet.mjs","webpack://@mercuryworkshop/wisp-js/./src/extensions.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/connection.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/polyfill.mjs","webpack://@mercuryworkshop/wisp-js/./src/logging.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/options.mjs","webpack://@mercuryworkshop/wisp-js/./src/websocket.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/net.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/filter.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/connection.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/wsproxy.mjs","webpack://@mercuryworkshop/wisp-js/./src/server/http.mjs"],"sourcesContent":["(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 18, 0, 0]), 15],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ],\n            // RFC7534, RFC7535\n            as112: [\n                [new IPv4([192, 175, 48, 0]), 24],\n                [new IPv4([192, 31, 196, 0]), 24],\n            ],\n            // RFC7450\n            amt: [\n                [new IPv4([192, 52, 193, 0]), 24],\n            ],\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv4 address in CIDR notation.\n    ipaddr.IPv4.isValidCIDR = function (string) {\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address with CIDR prefix.\n    ipaddr.IPv4.isValidCIDRFourPartDecimal = function (string) {\n        const match = string.match(/^(.+)\\/(\\d+)$/);\n\n        if (!ipaddr.IPv4.isValidCIDR(string) || !match) {\n            return false;\n        }\n\n        return ipaddr.IPv4.isValidFourPartDecimal(match[1]);\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6666\n            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC5180\n            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n            // RFC7450\n            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n            as112v6: [\n                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],\n                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],\n            ],\n            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],\n            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],\n            reserved: [\n                // RFC3849\n                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],\n                // RFC2928\n                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],\n            ],\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // Calls toRFC5952String under the hood.\n        IPv6.prototype.toString = function () {\n            return this.toRFC5952String();\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv6 address in CIDR notation.\n    ipaddr.IPv6.isValidCIDR = function (string) {\n\n        // See note in IPv6.isValid\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = match[1]\n            if (!match[1].endsWith('::')) {\n                addr = addr.slice(0, -1)\n            }\n            addr = expandIPv6(addr + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n    // Checks if the address is valid IP address in CIDR notation\n    ipaddr.isValidCIDR = function (string) {\n        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","//the node modules referenced by other parts of the code do not exist on the web\n//some of them can be replaced by the standard browser apis, others have to be ignored\n\n//compatibility for old browsers where globalThis doesn't exist\nexport const global_this = typeof globalThis === \"undefined\" ? window : globalThis;\n\nexport const WebSocket = global_this.WebSocket;\nexport const crypto = global_this.crypto;\nexport const WebSocketServer = null;\nexport const net = null;\nexport const dgram = null;\nexport const dns = null;\nexport const http = null;","//shared packet parsing / serialization code\n\nconst text_encoder = new TextEncoder();\nconst encode_text = text_encoder.encode.bind(text_encoder);\nconst text_decoder = new TextDecoder();\nconst decode_text = text_decoder.decode.bind(text_decoder);\n\nexport class WispBuffer {\n  constructor(data) {\n    if (data instanceof Uint8Array) {\n      this.from_array(data);\n    }\n    else if (typeof data === \"number\") {\n      this.from_array(new Uint8Array(data));\n    }\n    else if (typeof data === \"string\") {\n      this.from_array(encode_text(data));\n    }\n    else {\n      console.trace();\n      throw \"invalid data type passed to wisp buffer constructor\";\n    }\n  }\n\n  from_array(bytes) {\n    this.size = bytes.length;\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer); \n  }\n\n  concat(buffer) {\n    let new_buffer = new WispBuffer(this.size + buffer.size);\n    new_buffer.bytes.set(this.bytes, 0);\n    new_buffer.bytes.set(buffer.bytes, this.size);\n    return new_buffer;\n  }\n\n  slice(index, size) {\n    let bytes_slice = this.bytes.slice(index, size);\n    return new WispBuffer(bytes_slice);\n  }\n\n  get_string() {\n    return text_decoder.decode(this.bytes);\n  }\n}\n\nexport class WispPacket {\n  static min_size = 5;\n  constructor({type, stream_id, payload, payload_bytes }) {\n    this.type = type;\n    this.stream_id = stream_id;\n    this.payload_bytes = payload_bytes;\n    this.payload = payload;\n  }\n  static parse(buffer) {\n    return new WispPacket({\n      type: buffer.view.getUint8(0),\n      stream_id: buffer.view.getUint32(1, true),\n      payload_bytes: buffer.slice(5)\n    });\n  }\n  static parse_all(buffer) {\n    if (buffer.size < WispPacket.min_size) {\n      throw TypeError(\"packet too small\");\n    }\n    let packet = WispPacket.parse(buffer);\n    let payload_class = packet_classes[packet.type];\n    if (typeof payload_class === \"undefined\") {\n      throw TypeError(\"invalid packet type\");\n    }\n    if (packet.payload_bytes.size < payload_class.size) {\n      throw TypeError(\"payload too small\");\n    }\n    packet.payload = payload_class.parse(packet.payload_bytes);\n    return packet;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    buffer.view.setUint8(0, this.type);\n    buffer.view.setUint32(1, this.stream_id, true);\n    buffer = buffer.concat(this.payload.serialize());\n    return buffer;\n  }\n}\n\nexport class ConnectPayload {\n  static min_size = 3;\n  static type = 0x01;\n  static name = \"CONNECT\";\n  constructor({stream_type, port, hostname}) {\n    this.stream_type = stream_type;\n    this.port = port;\n    this.hostname = hostname;\n  }\n  static parse(buffer) {\n    return new ConnectPayload({\n      stream_type: buffer.view.getUint8(0),\n      port: buffer.view.getUint16(1, true),\n      hostname: decode_text(buffer.slice(3).bytes)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(3);\n    buffer.view.setUint8(0, this.stream_type);\n    buffer.view.setUint16(1, this.port, true);\n    buffer = buffer.concat(new WispBuffer(this.hostname));\n    return buffer;\n  }\n}\n\nexport class DataPayload {\n  static min_size = 0;\n  static type = 0x02;\n  static name = \"DATA\";\n  constructor({data}) {\n    this.data = data;\n  }\n  static parse(buffer) {\n    return new DataPayload({\n      data: buffer\n    });\n  }\n  serialize() {\n    return this.data;\n  }\n}\n\nexport class ContinuePayload {\n  static type = 0x03;\n  static name = \"CONTINUE\";\n  constructor({buffer_remaining}) {\n    this.buffer_remaining = buffer_remaining;\n  }\n  static parse(buffer) {\n    return new ContinuePayload({\n      buffer_remaining: buffer.view.getUint32(0, true),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(4);\n    buffer.view.setUint32(0, this.buffer_remaining, true);\n    return buffer;\n  }\n}\n\nexport class ClosePayload {\n  static min_size = 1;\n  static type = 0x04;\n  static name = \"CLOSE\";\n  constructor({reason}) {\n    this.reason = reason;\n  }\n  static parse(buffer) {\n    return new ClosePayload({\n      reason: buffer.view.getUint8(0),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(1);\n    buffer.view.setUint8(0, this.reason);\n    return buffer;\n  }\n}\n\nexport class InfoPayload {\n  static min_size = 2;\n  static type = 0x05;\n  static name = \"INFO\";\n  constructor({major_ver, minor_ver, extensions}) {\n    this.major_ver = major_ver;\n    this.minor_ver = minor_ver;\n    this.extensions = extensions;\n  }\n  static parse(buffer) {\n    return new InfoPayload({\n      major_ver: buffer.view.getUint8(0),\n      minor_ver: buffer.view.getUint8(1),\n      extensions: buffer.slice(2)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(2);\n    buffer.view.setUint8(0, this.major_ver);\n    buffer.view.setUint8(1, this.minor_ver);\n    return buffer.concat(this.extensions);\n  }\n}\n\nexport const packet_classes = {\n  0x01: ConnectPayload, \n  0x02: DataPayload, \n  0x03: ContinuePayload, \n  0x04: ClosePayload,\n  0x05: InfoPayload\n}\n\nexport const packet_types = {\n  CONNECT: 0x01,\n  DATA: 0x02,\n  CONTINUE: 0x03,\n  CLOSE: 0x04,\n  INFO: 0x05\n}\n\nexport const stream_types = {\n  TCP: 0x01,\n  UDP: 0x02\n}\n\nexport const close_reasons = {\n  //client/server close reasons\n  Unknown: 0x01,\n  Voluntary: 0x02,\n  NetworkError: 0x03,\n  IncompatibleExtensions: 0x04,\n\n  //server only close reasons\n  InvalidInfo: 0x41, \n  UnreachableHost: 0x42,\n  NoResponse: 0x43,\n  ConnRefused: 0x44,\n  TransferTimeout: 0x47,\n  HostBlocked: 0x48,\n  ConnThrottled: 0x49,\n\n  //client only close reasons\n  ClientError: 0x81,\n\n  //extension specific close reasons\n  AuthBadPassword: 0xc0,\n  AuthBadSignature: 0xc1,\n  AuthMissingCredentials: 0xc2\n}","import { WispBuffer } from \"./packet.mjs\";\n\nclass EmptyPayload {\n  constructor() {}\n  static parse() {\n    return new EmptyPayload();\n  }\n  serialize() {\n    return new WispBuffer(0);\n  }\n}\n\nexport class BaseExtension {\n  static id = 0x00;\n  static name = \"\";\n\n  static Server = EmptyPayload;\n  static Client = EmptyPayload;\n\n  constructor({server_config, client_config} = {}) {\n    this.id = this.constructor.id;\n    this.name = this.constructor.name;\n    if (server_config)\n      this.payload = new this.constructor.Server(server_config);\n    else if (client_config)\n      this.payload = new this.constructor.Client(client_config);\n  }\n  static parse(ext_class, buffer, role) {\n    let extension = new ext_class({});\n    if (role === \"client\")\n      extension.payload = ext_class.Client.parse(buffer.slice(5));\n    else if (role === \"server\")\n      extension.payload = ext_class.Server.parse(buffer.slice(5));\n    else \n      throw TypeError(\"invalid role\");\n    return extension;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    let payload_buffer = this.payload.serialize();\n    buffer.view.setInt8(0, this.constructor.id);\n    buffer.view.setUint32(1, payload_buffer.size, true);\n    return buffer.concat(payload_buffer);\n  }\n}\n\nexport class UDPExtension extends BaseExtension {\n  static id = 0x01;\n  static name = \"UDP\";\n}\n\nexport class PasswordAuthExtension extends BaseExtension {\n  static id = 0x02;\n  static name = \"Password Authentication\";\n\n  static Server = class {\n    constructor({required = 1}) {\n      this.required = required ? 1 : 0;\n    }\n    static parse(buffer) {\n      return new PasswordAuthExtension.Server({\n        required: buffer.view.getUint8(0)\n      });\n    }\n    serialize() {\n      let buffer = new WispBuffer(1);\n      buffer.view.setUint8(0, this.required);\n      return buffer;\n    }\n  }\n\n  static Client = class {\n    constructor({username, password}) {\n      this.username = username;\n      this.password = password;\n    }\n    static parse(buffer) {\n      let username_len = buffer.view.getUint8(0);\n      let password_len = buffer.view.getUint16(1, true);\n      let password_index = username_len + 3;\n      return new PasswordAuthExtension.Client({\n        username: buffer.slice(3, username_len).get_string(),\n        password: buffer.slice(password_index, password_len).get_string()\n      });\n    }\n    serialize() {\n      let username_buffer = new WispBuffer(this.username);\n      let password_buffer = new WispBuffer(this.password);\n      let buffer = new WispBuffer(3);\n      buffer.view.setUint8(0, username_buffer.size);\n      buffer.view.setUint16(1, password_buffer.size, true);\n      return buffer.concat(username_buffer).concat(password_buffer);\n    }\n  }\n}\n\nexport class MOTDExtension extends BaseExtension {\n  static id = 0x04;\n  static name = \"Server MOTD\";\n\n  static Server = class {\n    constructor({message}) {\n      this.message = message;\n    }\n    static parse(buffer) {\n      return new MOTDExtension.Server({\n        message: buffer.get_string()\n      });\n    }\n    serialize() {\n      return new WispBuffer(this.message);\n    }\n  }\n\n  static Client = EmptyPayload;\n}\n\nexport function parse_extensions(payload_buffer, valid_extensions, role) {\n  let index = 0;\n  let parsed_extensions = [];\n  while (payload_buffer.size) {\n    let ext_id = payload_buffer.view.getUint8(index);\n    let ext_len = payload_buffer.view.getUint32(index + 1, true);\n    let ext_payload = payload_buffer.slice(0, 5 + ext_len);\n    let ext_class;\n    for (let extension of valid_extensions) {\n      if (extension.id !== ext_id) \n        continue;\n      ext_class = extension.constructor;\n      break;\n    }\n    if (ext_class) {\n      let ext_parsed = BaseExtension.parse(ext_class, ext_payload, role);\n      parsed_extensions.push(ext_parsed);\n    }\n    payload_buffer = payload_buffer.slice(5 + ext_len);\n  }\n  return parsed_extensions;\n}\n\nexport function serialize_extensions(extensions) {{\n  let ext_buffer = new WispBuffer(0);\n  for (let extension of extensions) {\n    ext_buffer = ext_buffer.concat(extension.serialize());\n  }\n  return ext_buffer;\n}}\n\nexport const extensions_map = {\n  0x01: UDPExtension,\n  0x02: PasswordAuthExtension,\n  0x04: MOTDExtension\n}","import * as compat from \"../compat.mjs\";\n\nimport {\n  packet_classes,\n  packet_types,\n  stream_types,\n  WispBuffer, \n  WispPacket, \n  ConnectPayload, \n  DataPayload, \n  ClosePayload,\n  InfoPayload\n} from \"../packet.mjs\";\n\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nclass ClientStream {\n  constructor(hostname, port, websocket, buffer_size, stream_id, connection, stream_type) {\n    this.hostname = hostname;\n    this.port = port;\n    this.ws = websocket;\n    this.buffer_size = buffer_size;\n    this.stream_id = stream_id;\n    this.connection = connection;\n    this.stream_type = stream_type;\n    this.send_buffer = [];\n    this.open = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onmessage = () => {};\n  }\n\n  send(data) {\n    //note: udp shouldn't buffer anything\n    if (this.buffer_size > 0 || !this.open || this.stream_type === stream_types.UDP) {\n      //construct and send a DATA packet\n      let packet = new WispPacket({\n        type: packet_types.DATA,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(data)\n        })\n      });\n      this.ws.send(packet.serialize().bytes);\n      this.buffer_size--;\n    }\n    else { //server is slow, don't send data yet\n      this.send_buffer.push(data);\n    }\n  }\n\n  //handle receiving a CONTINUE packet\n  continue_received(buffer_size) {\n    this.buffer_size = buffer_size;\n    //send buffered data now\n    while (this.buffer_size > 0 && this.send_buffer.length > 0) {\n      this.send(this.send_buffer.shift());\n    }\n  }\n\n  //construct and send a CLOSE packet\n  close(reason = 0x01) {\n    if (!this.open) return;\n    let packet = new WispPacket({\n      type: packet_types.CLOSE,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    this.open = false;\n    delete this.connection.active_streams[this.stream_id];\n  }\n}\n\nexport class ClientConnection {\n  constructor(wisp_url, {wisp_version, wisp_extensions} = {}) {\n    if (!wisp_url.endsWith(\"/\")) {\n      throw new TypeError(\"wisp endpoints must end with a trailing forward slash\");\n    }\n\n    this.wisp_url = wisp_url;\n    this.wisp_version = wisp_version || 2;\n    this.wisp_extensions = wisp_extensions || null;\n\n    this.max_buffer_size = null;\n    this.active_streams = {};\n    this.connected = false;\n    this.connecting = false;\n    this.next_stream_id = 1;\n\n    this.server_exts = {};\n    this.client_exts = {};\n    this.info_received = false;\n    this.server_motd = null;\n    this.udp_enabled = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n\n    this.connect_ws();\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    this.wisp_extensions.push(new UDPExtension({client_config: {}}));\n    this.wisp_extensions.push(new MOTDExtension({client_config: {}}));\n  }\n\n  connect_ws() {\n    let subprotocol = this.wisp_version === 2 ? \"wisp-v2\" : undefined;\n    this.ws = new compat.WebSocket(this.wisp_url, subprotocol);\n    this.ws.binaryType = \"arraybuffer\";\n    this.connecting = true;\n\n    this.ws.onerror = () => {\n      if (this.wisp_version === 2) {\n        this.ws.onclose = null;\n        this.cleanup();\n        this.wisp_version = 1;\n        this.connect_ws();\n        return;\n      }\n      this.cleanup();\n      this.onerror();\n    };\n    this.ws.onclose = () => {\n      this.cleanup();\n      this.onclose();\n    };\n    this.ws.onmessage = (event) => {\n      this.on_ws_msg(event);\n      if (this.connected && this.connecting) {\n        this.connecting = false;\n        this.onopen();\n      }\n    };\n  }\n\n  close() {\n    this.ws.close();\n  }\n\n  create_stream(hostname, port, type=0x01) {\n    let stream_type = type;\n    if (typeof stream_type === \"string\") \n      stream_type = type === \"udp\" ? stream_types.UDP : stream_types.TCP;\n\n    if (stream_type == stream_types.UDP && !this.udp_enabled) {\n      throw new Error(\"udp is not enabled for this wisp connection\");\n    }\n\n    let stream_id = this.next_stream_id++;\n    let stream = new ClientStream(hostname, port, this.ws, this.max_buffer_size, stream_id, this, stream_type);\n    this.active_streams[stream_id] = stream;\n    stream.open = this.connected;\n\n    //construct CONNECT packet\n    let packet = new WispPacket({\n      type: packet_types.CONNECT,\n      stream_id: stream_id,\n      payload: new ConnectPayload({\n        stream_type: stream_type,\n        port: port,\n        hostname: hostname\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    return stream;\n  }\n\n  close_stream(stream, reason) {\n    stream.onclose(reason);\n    delete this.active_streams[stream.stream_id];\n  }\n\n  on_ws_msg(event) {\n    let buffer = new WispBuffer(new Uint8Array(event.data));\n    if (buffer.size < WispPacket.min_size) {\n      console.warn(`wisp client warning: received a packet which is too short`);\n      return;\n    }\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.active_streams[packet.stream_id];\n    if (packet.stream_id === 0 && this.connecting) {\n      if (packet.type === packet_types.CONTINUE) {\n        this.max_buffer_size = packet.payload.buffer_remaining;\n        this.connected = true;\n        if (!this.info_received) {\n          this.wisp_version = 1;\n        }\n      }\n      \n      if (packet.type === packet_types.INFO && this.wisp_version === 2) {\n        let server_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"server\");\n        for (let server_ext of server_extensions) {\n          for (let client_ext of this.wisp_extensions) {\n            if (server_ext.id === client_ext.id) {\n              this.server_exts[server_ext.id] = server_ext;\n              this.client_exts[client_ext.id] = client_ext;\n            }\n          }\n        }\n\n        this.info_received = true; \n        this.server_motd = this.server_exts[MOTDExtension.id]?.payload?.message;\n        this.udp_enabled = !!this.server_exts[UDPExtension.id];\n\n        let ext_buffer = serialize_extensions(this.wisp_extensions);\n        let info_packet = new WispPacket({\n          type: InfoPayload.type,\n          stream_id: 0,\n          payload: new InfoPayload({\n            major_ver: this.wisp_version,\n            minor_ver: 0,\n            extensions: ext_buffer\n          })\n        });\n        this.ws.send(info_packet.serialize().bytes);\n      }\n      return;\n    }\n\n    if (typeof stream === \"undefined\") {\n      console.warn(`wisp client warning: received a ${packet_classes[packet.type].name} packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === packet_types.DATA) {\n      stream.onmessage(packet.payload_bytes.bytes);\n    }\n\n    else if (packet.type === packet_types.CONTINUE) { //other CONTINUE packets\n      stream.continue_received(packet.payload.buffer_remaining);\n    }\n\n    else if (packet.type === packet_types.CLOSE) {\n      this.close_stream(stream, packet.payload.reason);\n    }\n\n    else {\n      console.warn(`wisp client warning: received an invalid packet of type ${packet.type}`);\n    }\n  }\n\n  cleanup() {\n    this.connected = false;\n    this.connecting = false;\n    for (let stream_id of Object.keys(this.active_streams)) {\n      this.close_stream(this.active_streams[stream_id], 0x03);\n    }\n  }\n}\n\n","import { global_this } from \"../compat.mjs\";\nimport { ClientConnection } from \"./connection.mjs\";\n\n//polyfill the DOM Websocket API so that applications using wsproxy can easily use wisp with minimal changes\n\nconst RealCloseEvent = (global_this.CloseEvent || Event);\nexport const _wisp_connections = {};\n\nexport class WispWebSocket extends EventTarget {\n  constructor(url, protocols=null, options = {}) {\n    super();\n    this.url = url;\n    this.protocols = protocols;\n    this.options = options;\n    this.binaryType = \"blob\";\n    this.stream = null;\n    this.connection = null;\n\n    //legacy event handlers\n    this.onopen = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n    this.onclose = () => {};\n\n    this.CONNECTING = 0;\n    this.OPEN = 1;\n    this.CLOSING = 2;\n    this.CLOSED = 3;\n    this._ready_state = this.CONNECTING;\n\n    //parse the wsproxy url\n    let url_split = this.url.split(\"/\");\n    let wsproxy_path = url_split.pop().split(\":\");\n    this.host = wsproxy_path[0];\n    this.port = parseInt(wsproxy_path[1]);\n    this.real_url = url_split.join(\"/\") + \"/\";\n\n    this.init_connection();\n  }\n\n  on_conn_close() {\n    this._ready_state = this.CLOSED;\n    if (_wisp_connections[this.real_url]) {\n      this.onerror(new Event(\"error\"));\n      this.dispatchEvent(new Event(\"error\"));\n    }\n    delete _wisp_connections[this.real_url];\n  }\n\n  init_connection() {\n    //create the stream\n    this.connection = _wisp_connections[this.real_url];\n\n    if (!this.connection) {\n      this.connection = new ClientConnection(this.real_url, this.options);\n      this.connection.onopen = () => {\n        this.init_stream();\n      };\n      this.connection.onclose = () => {\n        this.on_conn_close()\n      };\n      this.connection.onerror = () => {\n        this.on_conn_close()\n      };\n      _wisp_connections[this.real_url] = this.connection;\n    }\n    else if (!this.connection.connected) {\n      let old_onopen = this.connection.onopen;\n      this.connection.onopen = () => {\n        old_onopen();\n        this.init_stream();\n      };\n    }\n    else {\n      this.connection = _wisp_connections[this.real_url];\n      this.init_stream();\n    }\n  }\n\n  init_stream() {\n    this._ready_state = this.OPEN;\n    this.stream = this.connection.create_stream(this.host, this.port);\n\n    this.stream.onmessage = (raw_data) => {\n      let data;\n      if (this.binaryType == \"blob\") {\n        data = new Blob(raw_data);\n      }\n      else if (this.binaryType == \"arraybuffer\") {\n        data = raw_data.buffer;\n      }\n      else {\n        throw \"invalid binaryType string\";\n      }\n      let msg_event = new MessageEvent(\"message\", {data: data});\n      this.onmessage(msg_event);\n      this.dispatchEvent(msg_event);\n    };\n\n    this.stream.onclose = (reason) => {\n      this._ready_state = this.CLOSED;\n      let close_event = new RealCloseEvent(\"close\", {code: reason}); \n      this.onclose(close_event);\n      this.dispatchEvent(close_event);\n    };\n\n    let open_event = new Event(\"open\");\n    this.onopen(open_event);\n    this.dispatchEvent(open_event);\n  }\n\n  send(data) {\n    let data_array;\n\n    if (data instanceof Uint8Array) {\n      data_array = data;  \n    }\n    else if (typeof data === \"string\") {\n      data_array = new TextEncoder().encode(data);\n    }\n    else if (data instanceof Blob) {\n      data.arrayBuffer().then(array_buffer => {\n        this.send(array_buffer);\n      });\n      return;\n    }\n    else if (data instanceof ArrayBuffer) {\n      data_array = new Uint8Array(data);\n    }\n    //dataview objects or any other typedarray\n    else if (ArrayBuffer.isView(data)) {\n      data_array = new Uint8Array(data.buffer);\n    }\n    else {\n      throw \"invalid data type to be sent\";\n    }\n\n    if (!this.stream) {\n      throw \"websocket is not ready\";\n    }\n    this.stream.send(data_array);\n  }\n\n  close() {\n    this.stream.close(0x02);\n  }\n\n  get bufferedAmount() {\n    let total = 0;\n    for (let msg of this.stream.send_buffer) {\n      total += msg.length;\n    }\n    return total;\n  }\n\n  get extensions() {\n    return \"\";\n  }\n\n  get protocol() {\n    return \"binary\";\n  }\n\n  get readyState() {\n    return this._ready_state;\n  }\n}","export const DEBUG = 0;\nexport const INFO = 1;\nexport const WARN = 2;\nexport const ERROR = 3;\nexport const NONE = 4;\nexport let log_level = INFO;\n\nexport function get_timestamp() {\n  let [date, time] = new Date().toJSON().split(\"T\");\n  date = date.replaceAll(\"-\", \"/\");\n  time = time.split(\".\")[0];\n  return `[${date} - ${time}]`;\n}\n\nexport function set_level(level) {\n  log_level = level;\n}\n\nexport function debug(...messages) {\n  if (log_level > DEBUG) return;\n  console.debug(get_timestamp() + \" debug:\", ...messages);\n}\n\nexport function info(...messages) {\n  if (log_level > INFO) return;\n  console.info(get_timestamp() + \" info:\", ...messages);\n}\n\nexport function log(...messages) {\n  if (log_level > INFO) return;\n  console.log(get_timestamp() + \" log:\", ...messages);\n}\n\nexport function warn(...messages) {\n  if (log_level > WARN) return;\n  console.warn(get_timestamp() + \" warn:\", ...messages);\n}\n\nexport function error(...messages) {\n  if (log_level > ERROR) return;\n  console.error(get_timestamp() + \" error:\", ...messages);\n}\n\n","export const options = {\n  //destination hostname restrictions\n  hostname_blacklist: null,\n  hostname_whitelist: null,\n  port_blacklist: null,\n  port_whitelist: null,\n  allow_direct_ip: true,\n  allow_private_ips: false,\n  allow_loopback_ips: false,\n  \n  //client connection restrictions\n  client_ip_blacklist: null, //not implemented!\n  client_ip_whitelist: null, //not implemented!\n  stream_limit_per_host: -1,\n  stream_limit_total: -1,\n  allow_udp_streams: true,\n  allow_tcp_streams: true,\n\n  //dns options\n  dns_ttl: 120,\n  dns_method: \"lookup\",\n  dns_servers: null,\n  dns_result_order: \"verbatim\",\n\n  //misc options\n  parse_real_ip: true,\n  parse_real_ip_from: [\"127.0.0.1\"],\n\n  //wisp v2 options\n  wisp_version: 2,\n  wisp_motd: null\n}\n\n","//async websocket wrapper for both node and the browser\n\nimport * as compat from \"./compat.mjs\";\nimport { WispPacket } from \"./packet.mjs\";\n\nexport function get_conn_id() {\n  return compat.crypto.randomUUID().split(\"-\")[0];\n}\n\n//an async websocket wrapper\nexport class AsyncWebSocket {\n  send_buffer_size = 32*1024*1024;\n  \n  constructor(ws) {\n    this.ws = ws;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(1);\n  }\n\n  async connect() {\n    await new Promise((resolve, reject) => {\n      this.ws.onopen = () => {\n        this.connected = true;\n        resolve();\n      }\n      this.ws.onmessage = (event) => {\n        this.data_queue.put(event.data);\n      }\n      this.ws.onclose = () => {\n        if (!this.connected) reject();\n        else this.data_queue.close();\n      }\n      if (this.ws.readyState === this.ws.OPEN) {\n        this.connected = true;\n        resolve();\n      }\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    if (data instanceof WispPacket) {\n      data = data.serialize().bytes\n    }\n\n    this.ws.send(data);\n    if (this.ws.bufferedAmount <= this.send_buffer_size) {\n      return;\n    }\n\n    //if the send buffer is too full, throttle the upload\n    while (true) {\n      if (this.ws.bufferedAmount <= this.send_buffer_size / 2) {\n        break;\n      }\n      await new Promise((resolve) => {setTimeout(resolve, 10)});\n    }\n  }\n\n  close(code, reason) {\n    this.ws.close(code, reason);\n    this.data_queue.close();\n  }\n\n  get buffered_amount() {\n    return this.ws.bufferedAmount;\n  }\n}\n\n//an async fifo queue\nexport class AsyncQueue {\n  constructor(max_size) {\n    this.max_size = max_size;\n    this.queue = [];\n    this.put_callbacks = [];\n    this.get_callbacks = [];\n  }\n\n  put_now(data) {\n    this.queue.push(data);\n    this.get_callbacks.shift()?.();\n  }\n\n  async put(data) {\n    if (this.size <= this.max_size) {\n      this.put_now(data);\n      return;\n    }\n\n    //wait until there is a place to put the item\n    await new Promise((resolve) => {\n      this.put_callbacks.push(resolve);\n    });\n    this.put_now(data);\n  }\n\n  get_now() {\n    this.put_callbacks.shift()?.();\n    return this.queue.shift();\n  }\n\n  async get() {\n    if (this.size > 0) {\n      return this.get_now();\n    }\n\n    //wait until there is an item available in the queue\n    await new Promise((resolve) => {\n      this.get_callbacks.push(resolve);\n    });\n    return this.get_now();\n  }\n\n  close() {\n    this.queue = [];\n    let callback;\n    //resolve all pending operations\n    while (callback = this.get_callbacks.shift())\n      callback();\n    while (callback = this.put_callbacks.shift())\n      callback();\n  }\n\n  get size() {\n    return this.queue.length;\n  }\n}","import * as logging from \"../logging.mjs\";\nimport { AsyncQueue } from \"../websocket.mjs\";\nimport { options } from \"./options.mjs\";\nimport { net, dgram, dns } from \"../compat.mjs\";\n\n//wrappers for node networking apis\n//in the browser these can be redefined to allow for custom transports\n\nexport const is_node = (typeof process !== \"undefined\");\n\nconst dns_cache = new Map();\nlet dns_servers = null;\nlet resolver = null;\n\nexport function assert_on_node() {\n  if (!is_node) {\n    throw new Error(\"not running on node.js\");\n  }\n}\n\n//wrapper for node resolver methods\n//resolve4 and resolve6 need to be wrapped to work around a nodejs bug\nfunction resolve4(hostname) {\n  return resolver.resolve4(hostname);\n}\nfunction resolve6(hostname) {\n  return resolver.resolve6(hostname);\n}\nasync function resolve_with_fallback(resolve_first, resolve_after, hostname) {\n  try {\n    return (await resolve_first(hostname))[0];\n  }\n  catch {\n    return (await resolve_after(hostname))[0];\n  }\n}  \n\n//a wrapper for the actual dns lookup\nasync function perform_lookup(hostname) {\n  //resolve using system dns\n  if (options.dns_method === \"lookup\") {\n    let result = await dns.lookup(hostname, {order: options.dns_result_order}); \n    return result.address;\n  }\n\n  //resolve using dns.resolve4 / dns.resolve6, which bypasses the system dns\n  else if (options.dns_method === \"resolve\") {\n    //we need to make a new resolver at first run because setServers doesn't work otherwise\n    if (!resolver) resolver = new dns.Resolver();\n\n    //set custom dns servers if needed\n    if (options.dns_servers !== dns_servers) {\n      logging.debug(\"Setting custom DNS servers to: \" + options.dns_servers.join(\", \"));\n      resolver.setServers(options.dns_servers);\n      dns_servers = options.dns_servers;\n    }\n\n    if (options.dns_result_order === \"verbatim\" || options.dns_result_order === \"ipv6first\") \n      return await resolve_with_fallback(resolve6, resolve4, hostname);\n    else if (options.dns_result_order === \"ipv4first\")\n      return await resolve_with_fallback(resolve4, resolve6, hostname);\n    else\n      throw new Error(\"Invalid result order. options.dns_result_order must be either 'ipv6first', 'ipv4first', or 'verbatim'.\");\n  }\n\n  //use a custom function for dns resolution\n  else if (typeof options.dns_method === \"function\") {\n    return await options.dns_method(hostname);\n  }\n\n  throw new Error(\"Invalid DNS method. options.dns_method must either be 'lookup' or 'resolve'.\");\n}\n\n//perform a dns lookup and use the cache\nexport async function lookup_ip(hostname) {\n  if (!is_node) { //we cannot do the dns lookup on the browser\n    return hostname;\n  }\n\n  let ip_level = net.isIP(hostname);\n  if (ip_level === 4 || ip_level === 6) {\n    return hostname; //hostname is already an ip address\n  }\n\n  //remove stale entries from the cache\n  let now = Date.now();\n  for (let [entry_hostname, cache_entry] of dns_cache) {\n    let ttl = now - cache_entry.time;\n    if (ttl > options.dns_ttl) {\n      dns_cache.delete(entry_hostname);\n    }\n  }\n\n  //look in the cache first before using the system resolver\n  let cache_entry = dns_cache.get(hostname);\n  if (cache_entry) {\n    if (cache_entry.error) \n      throw cache_entry.error\n    return cache_entry.address;\n  }\n\n  //try to perform the actual dns lookup and store the result\n  let address;\n  try {\n    address = await perform_lookup(hostname);\n    logging.debug(`Domain resolved: ${hostname} -> ${address}`);\n    dns_cache.set(hostname, {time: Date.now(), address: address});\n  }\n  catch (e) {\n    dns_cache.set(hostname, {time: Date.now(), error: e});\n    throw e;\n  }\n\n  return address;\n}\n\n//async tcp and udp socket wrappers\nexport class NodeTCPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n    this.recv_buffer_size = 128;\n\n    this.socket = null;\n    this.paused = false;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    await new Promise((resolve, reject) => {\n      this.socket = new net.Socket();\n      this.socket.setNoDelay(true);\n      this.socket.on(\"connect\", () => {\n        this.connected = true;\n        resolve();\n      });\n      this.socket.on(\"data\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"close\", (error) => {\n        if (error && !this.connected) reject();\n        else this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.on(\"error\", (error) => {\n        logging.warn(`tcp stream to ${this.hostname} ended with error - ${error}`);\n      });\n      this.socket.on(\"end\", () => {\n        if (!this.socket) return;\n        this.socket.destroy();\n        this.socket = null;\n      });\n      this.socket.connect({\n        host: ip,\n        port: this.port\n      });\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    await new Promise((resolve) => {\n      this.socket.write(data, resolve);\n    });\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.end();\n    this.socket = null;\n  }\n\n  pause() {\n    if (this.data_queue.size >= this.data_queue.max_size) {\n      this.socket.pause();\n      this.paused = true;\n    }\n  }\n  resume() {\n    if (!this.socket) return;\n    if (this.paused) {\n      this.socket.resume();\n      this.paused = false;\n    }\n  }\n}\n\nexport class NodeUDPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n\n    this.connected = false;\n    this.recv_buffer_size = 128;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    let ip_level = net.isIP(ip);\n    await new Promise((resolve, reject) => {\n      this.socket = dgram.createSocket(ip_level === 6 ? \"udp6\" : \"udp4\");\n      this.socket.on(\"connect\", () => {\n        resolve();\n      });\n      this.socket.on(\"message\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"error\", () => {\n        if (!this.connected) reject();\n        this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.connect(this.port, ip);\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    this.socket.send(data);\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.close();\n    this.socket = null;\n  }\n\n  pause() {}\n  resume() {}\n}","import { close_reasons, stream_types } from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport * as net from \"./net.mjs\";\n\nimport ipaddr from \"ipaddr.js\";\n\nexport class AccessDeniedError extends Error {}\n\n//helper functions for the whitelist/blacklist logic\nfunction check_port_range(entry, port) {\n  return (entry === port) || (entry[0] <= port && entry[1] >= port)\n}\nfunction check_whitelist(entries, filter) {\n  let matched = false;\n  for (let entry of entries) {\n    if (filter(entry)) {\n      matched = true;\n      break\n    }\n  }\n  return !matched;\n}\nfunction check_blacklist(entries, filter) {\n  for (let entry of entries) {\n    if (filter(entry))\n      return true;\n    }\n  return false;\n}\n\nfunction check_ip_range(ip, range) {\n  return range.includes(ip.range());\n}\n\n//check if an ip is blocked\nexport function is_ip_blocked(ip_str) {\n  if (!ipaddr.isValid(ip_str)) \n    return false;\n  let ip = ipaddr.parse(ip_str);\n\n  let loopback_ranges = [\"loopback\", \"unspecified\"];\n  let private_ranges = [\"broadcast\", \"linkLocal\", \"carrierGradeNat\", \"private\", \"reserved\"];\n\n  if (!options.allow_loopback_ips && check_ip_range(ip, loopback_ranges)) \n    return true;\n  if (!options.allow_private_ips && check_ip_range(ip, private_ranges)) \n    return true;\n  return false;\n}\n\n//returns the close reason if the connection should be blocked\nexport async function is_stream_allowed(connection, type, hostname, port) {\n  //check if tcp or udp should be blocked\n  if (!options.allow_tcp_streams && type === stream_types.TCP)\n    return close_reasons.HostBlocked;\n  if (!options.allow_udp_streams && type === stream_types.UDP)\n    return close_reasons.HostBlocked;\n\n  //check the hostname whitelist/blacklist\n  if (options.hostname_whitelist) {\n    if (check_whitelist(options.hostname_whitelist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n  else if (options.hostname_blacklist) {\n    if (check_blacklist(options.hostname_blacklist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the port is blocked\n  if (options.port_whitelist) {\n    if (check_whitelist(options.port_whitelist, (entry) => check_port_range(entry, port))) \n      return close_reasons.HostBlocked;\n  }\n  else if (options.port_blacklist) {\n    if (check_blacklist(options.port_blacklist, (entry) => check_port_range(entry, port)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the destination ip is blocked\n  let ip_str = hostname;\n  if (ipaddr.isValid(hostname)) {\n    if (!options.allow_direct_ip)\n      return close_reasons.HostBlocked;\n  }\n  else {\n    try { //look up the ip to make sure that the resolved address is allowed\n      ip_str = await net.lookup_ip(hostname);\n    }\n    catch {}\n  }\n  if (is_ip_blocked(ip_str)) \n    return close_reasons.HostBlocked;\n\n  //don't check stream counts if there isn't an associated wisp connection (with wsproxy for example)\n  if (!connection) \n    return 0;\n\n  //check for stream count limits\n  if (options.stream_limit_total !== -1 && Object.keys(connection.streams).length >= options.stream_limit_total) \n    return close_reasons.ConnThrottled;\n  if (options.stream_limit_per_host !== -1) {\n    let streams_per_host = 0;\n    for (let stream of connection.streams) {\n      if (stream.socket.hostname === hostname) {\n        streams_per_host++;\n      }\n    }\n    if (streams_per_host >= options.stream_limit_per_host)\n      return close_reasons.ConnThrottled;\n  }\n\n  return 0;\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { AsyncQueue, AsyncWebSocket, get_conn_id } from \"../websocket.mjs\";\nimport { NodeTCPSocket, NodeUDPSocket } from \"./net.mjs\";\nimport { \n  WispBuffer,\n  WispPacket,\n  ContinuePayload,\n  ClosePayload,\n  ConnectPayload,\n  DataPayload,\n  InfoPayload,\n  stream_types,\n  close_reasons\n} from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nexport class HandshakeError extends Error {}\n\nexport class ServerStream {\n  static buffer_size = 128;\n\n  constructor(stream_id, conn, socket) {\n    this.stream_id = stream_id;\n    this.conn = conn;\n    this.socket = socket;    \n    this.send_buffer = new AsyncQueue(ServerStream.buffer_size);\n    this.packets_sent = 0;\n  }\n\n  async setup() {\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a tcp/udp to ws task encountered an error - ${error}`);\n      this.close();\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a ws to tcp/udp task encountered an error - ${error}`);\n      this.close();\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n\n      this.socket.pause();\n      let packet = new WispPacket({\n        type: DataPayload.type,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(new Uint8Array(data))\n        })\n      });\n      await this.conn.ws.send(packet);\n      this.socket.resume();\n    }\n    await this.conn.close_stream(this.stream_id, close_reasons.Voluntary);\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data = await this.send_buffer.get();\n      if (data == null) {\n        break; //stream closed\n      }\n      await this.socket.send(data);\n\n      this.packets_sent++;\n      if (this.packets_sent % (ServerStream.buffer_size / 2) !== 0) {\n        continue;\n      }\n      let packet = new WispPacket({\n        type: ContinuePayload.type,\n        stream_id: this.stream_id,\n        payload: new ContinuePayload({\n          buffer_remaining: ServerStream.buffer_size - this.send_buffer.size\n        })\n      });\n      this.conn.ws.send(packet);\n    }\n    await this.close();\n  }\n\n  async close(reason = null) {\n    this.send_buffer.close();\n    this.socket.close();\n    if (reason == null) return;\n\n    let packet = new WispPacket({\n      type: ClosePayload.type,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    await this.conn.ws.send(packet);\n  }\n\n  async put_data(data) {\n    await this.send_buffer.put(data);\n  }\n}\n\nexport class ServerConnection {\n  constructor(ws, path, {TCPSocket, UDPSocket, ping_interval, wisp_version, wisp_extensions} = {}) {\n    this.ws = new AsyncWebSocket(ws);\n    this.path = path;\n    this.TCPSocket = TCPSocket || NodeTCPSocket;\n    this.UDPSocket = UDPSocket || NodeUDPSocket;\n    this.ping_interval = ping_interval || 30;\n    this.wisp_version = wisp_version || options.wisp_version;\n    this.wisp_extensions = wisp_extensions || null;\n    \n    this.ping_task = null;\n    this.streams = {};\n    this.conn_id = get_conn_id();\n\n    this.server_exts = {};\n    this.client_exts = {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    if (options.allow_udp_streams) \n      this.wisp_extensions.push(new UDPExtension({server_config: {}}));\n    if (options.wisp_motd)\n      this.wisp_extensions.push(new MOTDExtension({server_config: {\n        message: options.wisp_motd\n      }}));\n  }\n\n  async setup() {\n    logging.info(`setting up new wisp v${this.wisp_version} connection with id ${this.conn_id}`);\n\n    await this.ws.connect();\n    if (this.wisp_version == 2) {\n      await this.setup_wisp_v2()\n    }\n\n    //send initial continue packet\n    let continue_packet = new WispPacket({\n      type: ContinuePayload.type,\n      stream_id: 0,\n      payload: new ContinuePayload({\n        buffer_remaining: ServerStream.buffer_size\n      })\n    });\n    this.ws.send(continue_packet);\n\n    if (typeof this.ws.ws.ping === \"function\") {\n      this.ping_task = setInterval(() => {\n        logging.debug(`(${this.conn_id}) sending websocket ping`);\n        this.ws.ws.ping();\n      }, this.ping_interval * 1000);  \n    }\n  }\n\n  async setup_wisp_v2() {\n    //send initial info packet for wisp v2\n    let ext_buffer = serialize_extensions(this.wisp_extensions);\n    let info_packet = new WispPacket({\n      type: InfoPayload.type,\n      stream_id: 0,\n      payload: new InfoPayload({\n        major_ver: this.wisp_version,\n        minor_ver: 0,\n        extensions: ext_buffer\n      })\n    });\n    this.ws.send(info_packet);\n\n    //wait for the client's info packet\n    let data = await this.ws.recv();\n    if (data == null) {\n      logging.warn(`(${this.conn_id}) handshake error: ws closed before handshake complete`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n    let buffer = new WispBuffer(new Uint8Array(data));\n    let packet = WispPacket.parse_all(buffer);\n\n    if (packet.type !== InfoPayload.type) {\n      logging.warn(`(${this.conn_id}) handshake error: unexpected packet of type ${packet.type}`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n\n    //figure out the common extensions\n    let client_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"client\");\n    for (let client_ext of client_extensions) {\n      for (let server_ext of this.wisp_extensions) {\n        if (server_ext.id === client_ext.id) {\n          this.server_exts[server_ext.id] = server_ext;\n          this.client_exts[client_ext.id] = client_ext;\n        }\n      }\n    }\n  }\n\n  create_stream(stream_id, type, hostname, port) {\n    let SocketImpl = type === stream_types.TCP ? this.TCPSocket : this.UDPSocket;\n    let socket = new SocketImpl(hostname, port);\n    let stream = new ServerStream(stream_id, this, socket);\n    this.streams[stream_id] = stream;\n\n    //start connecting to the destination server in the background\n    (async () => {\n      let close_reason = await filter.is_stream_allowed(this, type, hostname, port);\n      if (close_reason) {\n        logging.warn(`(${this.conn_id}) refusing to create a stream to ${hostname}:${port}`);\n        await this.close_stream(stream_id, close_reason, true);\n        return;\n      }\n      try {\n        await stream.setup();\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) creating a stream to ${hostname}:${port} failed - ${error}`);\n        await this.close_stream(stream_id, close_reasons.NetworkError);\n      }\n    })();\n  }\n\n  async close_stream(stream_id, reason = null, quiet = false) {\n    let stream = this.streams[stream_id];\n    if (stream == null) {\n      return;\n    }\n    if (reason && !quiet) {\n      logging.info(`(${this.conn_id}) closing stream to ${stream.socket.hostname} for reason ${reason}`);\n    }\n    await stream.close(reason);\n    delete this.streams[stream_id];\n  }\n\n  route_packet(buffer) {\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.streams[packet.stream_id];\n\n    if (stream == null && packet.type == DataPayload.type) {\n      logging.warn(`(${this.conn_id}) received a DATA packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === ConnectPayload.type) {\n      let type_info = packet.payload.stream_type === stream_types.TCP ? \"TCP\" : \"UDP\";\n      logging.info(`(${this.conn_id}) opening new ${type_info} stream to ${packet.payload.hostname}:${packet.payload.port}`);\n      this.create_stream(\n        packet.stream_id, \n        packet.payload.stream_type, \n        packet.payload.hostname.trim(), \n        packet.payload.port\n      )\n    }\n\n    else if (packet.type === DataPayload.type) {\n      stream.put_data(packet.payload.data.bytes);\n    }\n\n    else if (packet.type == ContinuePayload.type) {\n      logging.warn(`(${this.conn_id}) client sent a CONTINUE packet, this should never be possible`);\n    }\n\n    else if (packet.type == ClosePayload.type) {\n      this.close_stream(packet.stream_id, packet.reason);\n    }\n  }\n\n  async run() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      if (typeof data === \"string\") {\n        logging.warn(`(${this.conn_id}) routing a packet failed - unexpected ws text frame`);\n        continue;\n      }\n      \n      try {\n        //note: data is an arraybuffer so the uint8array constructor does not copy\n        this.route_packet(new WispBuffer(new Uint8Array(data)));\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) routing a packet failed - ${error}`);\n      }\n    }\n    \n    await this.cleanup();\n  }\n\n  async cleanup() {\n    //clean up all streams when the websocket is closed\n    for (let stream_id of Object.keys(this.streams)) {\n      await this.close_stream(stream_id);\n    }\n    clearInterval(this.ping_task);\n    logging.info(`(${this.conn_id}) wisp connection closed`);\n    this.ws.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { stream_types } from \"../packet.mjs\";\nimport { AsyncWebSocket } from \"../websocket.mjs\";\nimport { NodeTCPSocket } from \"./net.mjs\";\n\nexport class WSProxyConnection {\n  constructor(ws, path) {\n    let [hostname, port] = path.split(\"/\").pop().split(\":\");\n    this.hostname = hostname.trim();\n    this.port = parseInt(port);\n    this.ws = new AsyncWebSocket(ws);\n  }\n\n  async setup() {\n    await this.ws.connect();\n\n    //check that the destination host/ip is allowed\n    let err_code = await filter.is_stream_allowed(null, stream_types.TCP, this.hostname, this.port);\n    if (err_code !== 0) {\n      logging.info(`Refusing to create a wsproxy connection to ${this.hostname}:${this.port}`);\n      this.ws.close();\n      throw new filter.AccessDeniedError();\n    }\n\n    //connect to the tcp host after we are certain that it's safe to do so\n    this.socket = new NodeTCPSocket(this.hostname, this.port);\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`a tcp to ws task (wsproxy) encountered an error - ${error}`);\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`a ws to tcp task (wsproxy) encountered an error - ${error}`);\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n      this.socket.pause();\n      await this.ws.send(data);\n      this.socket.resume();\n    }\n    await this.ws.close();\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      await this.socket.send(data);\n    }\n    await this.socket.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as compat from \"../compat.mjs\";\n\nimport { options } from \"./options.mjs\";\nimport { AccessDeniedError } from \"./filter.mjs\";\nimport { ServerConnection, HandshakeError } from \"./connection.mjs\";\nimport { WSProxyConnection } from \"./wsproxy.mjs\";\nimport { is_node, assert_on_node } from \"./net.mjs\";\n\nlet ws_server = null;\nif (is_node) {\n  ws_server = new compat.WebSocketServer({ noServer: true });\n}\n\nexport function parse_real_ip(headers, client_ip) {\n  if (options.parse_real_ip && options.parse_real_ip_from.includes(client_ip)) {\n    if (headers[\"x-forwarded-for\"]) {\n      return headers[\"x-forwarded-for\"].split(\",\")[0].trim();\n    }\n    else if (headers[\"x-real-ip\"]) {\n      return headers[\"x-real-ip\"];\n    }\n  }\n  return client_ip;\n}\n\nexport function routeRequest(request, socket, head, conn_options={}) {\n  assert_on_node();\n  if (request.headers[\"sec-websocket-protocol\"] && options.wisp_version === 2)\n    conn_options.wisp_version = 2;\n  else \n    conn_options.wisp_version = 1;\n\n  if (request instanceof compat.http.IncomingMessage) {\n    ws_server.handleUpgrade(request, socket, head, (ws) => {\n      create_connection(ws, request.url, request, conn_options);\n    });\n  }\n  else if (request instanceof compat.WebSocket) {\n    create_connection(ws, \"/\", {}), conn_options;\n  }\n}\n\nasync function create_connection(ws, path, request, conn_options) {\n  ws.binaryType = \"arraybuffer\";\n  let client_ip = request.socket.address().address;\n  let real_ip = parse_real_ip(request.headers, client_ip);\n  let origin = request.headers[\"origin\"];\n  logging.info(`new connection on ${path} from ${real_ip} (origin: ${origin})`);\n  \n  try {\n    if (path.endsWith(\"/\")) {\n      let wisp_conn = new ServerConnection(ws, path, conn_options);\n      await wisp_conn.setup();\n      await wisp_conn.run();\n    }\n  \n    else {\n      let wsproxy = new WSProxyConnection(ws, path, conn_options);\n      await wsproxy.setup();\n    }\n  }\n\n  catch (error) {\n    ws.close();\n    if (error instanceof HandshakeError) return;\n    if (error instanceof AccessDeniedError) return;\n    logging.error(\"Uncaught server error:\\n\" + (error.stack || error));\n  }\n}"],"names":["root","ipv4Part","ipv4Regexes","fourOctet","RegExp","threeOctet","twoOctet","longValue","octalRegex","hexRegex","zoneIndex","ipv6Part","ipv6Regexes","deprecatedTransitional","transitional","expandIPv6","string","parts","indexOf","lastIndexOf","replacement","replacementCount","colonCount","lastColon","zoneId","match","substring","replace","substr","slice","length","ref","split","results","i","push","parseInt","matchCIDR","first","second","partSize","cidrBits","Error","shift","part","parseIntAuto","test","isNaN","padPart","ipaddr","IPv4","octets","octet","this","prototype","SpecialRanges","unspecified","broadcast","multicast","linkLocal","loopback","carrierGradeNat","reserved","as112","amt","kind","other","cidrRange","undefined","prefixLengthFromSubnetMask","cidr","stop","zerotable","zeros","range","subnetMatch","toByteArray","toIPv4MappedAddress","IPv6","parse","toString","toNormalizedString","join","broadcastAddressFromCIDR","parseCIDR","ipInterfaceOctets","subnetMaskOctets","subnetMaskFromPrefixLength","e","isIPv4","parser","isValid","isValidCIDR","isValidFourPartDecimal","isValidCIDRFourPartDecimal","networkAddressFromCIDR","maskLength","parsed","Object","defineProperty","value","reverse","prefix","j","filledOctetCount","Math","floor","pow","uniqueLocal","ipv4Mapped","discard","rfc6145","rfc6052","teredo","benchmarking","as112v6","deprecated","orchid2","droneRemoteIdProtocolEntityTags","isIPv4MappedAddress","bytes","toFixedLengthString","addr","call","suffix","toIPv4Address","high","low","toRFC5952String","regex","bestMatchIndex","bestMatchLength","exec","index","isIPv6","native","endsWith","fromByteArray","e2","process","address","rangeList","defaultName","rangeName","rangeSubnets","subnet","hasOwnProperty","Array","apply","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","key","o","enumerable","get","obj","prop","r","Symbol","toStringTag","global_this","globalThis","window","WebSocket","crypto","net","http","text_encoder","TextEncoder","encode_text","encode","bind","text_decoder","TextDecoder","decode_text","decode","WispBuffer","constructor","data","Uint8Array","from_array","console","trace","size","view","DataView","buffer","concat","new_buffer","set","bytes_slice","get_string","WispPacket","static","type","stream_id","payload","payload_bytes","getUint8","getUint32","parse_all","min_size","TypeError","packet","payload_class","packet_classes","serialize","setUint8","setUint32","ConnectPayload","stream_type","port","hostname","getUint16","setUint16","DataPayload","ContinuePayload","buffer_remaining","ClosePayload","reason","InfoPayload","major_ver","minor_ver","extensions","packet_types","CONNECT","DATA","CONTINUE","CLOSE","INFO","stream_types","TCP","UDP","close_reasons","Unknown","Voluntary","NetworkError","IncompatibleExtensions","InvalidInfo","UnreachableHost","NoResponse","ConnRefused","TransferTimeout","HostBlocked","ConnThrottled","ClientError","AuthBadPassword","AuthBadSignature","AuthMissingCredentials","EmptyPayload","BaseExtension","server_config","client_config","id","name","Server","Client","ext_class","role","extension","payload_buffer","setInt8","UDPExtension","PasswordAuthExtension","required","username","password","username_len","password_len","password_index","username_buffer","password_buffer","MOTDExtension","message","parse_extensions","valid_extensions","parsed_extensions","ext_id","ext_len","ext_payload","ext_parsed","serialize_extensions","ext_buffer","extensions_map","ClientStream","websocket","buffer_size","connection","ws","send_buffer","open","onopen","onclose","onmessage","send","continue_received","close","active_streams","ClientConnection","wisp_url","wisp_version","wisp_extensions","max_buffer_size","connected","connecting","next_stream_id","server_exts","client_exts","info_received","server_motd","udp_enabled","onerror","add_extensions","connect_ws","subprotocol","binaryType","cleanup","event","on_ws_msg","create_stream","stream","close_stream","warn","server_extensions","server_ext","client_ext","info_packet","keys","RealCloseEvent","CloseEvent","Event","_wisp_connections","WispWebSocket","EventTarget","url","protocols","options","super","CONNECTING","OPEN","CLOSING","CLOSED","_ready_state","url_split","wsproxy_path","pop","host","real_url","init_connection","on_conn_close","dispatchEvent","init_stream","old_onopen","raw_data","Blob","msg_event","MessageEvent","close_event","code","open_event","data_array","arrayBuffer","then","array_buffer","ArrayBuffer","isView","bufferedAmount","total","msg","protocol","readyState","ERROR","log_level","get_timestamp","date","time","Date","toJSON","replaceAll","debug","messages","info","error","hostname_blacklist","hostname_whitelist","port_blacklist","port_whitelist","allow_direct_ip","allow_private_ips","allow_loopback_ips","client_ip_blacklist","client_ip_whitelist","stream_limit_per_host","stream_limit_total","allow_udp_streams","allow_tcp_streams","dns_ttl","dns_method","dns_servers","dns_result_order","parse_real_ip","parse_real_ip_from","wisp_motd","AsyncWebSocket","send_buffer_size","data_queue","AsyncQueue","connect","Promise","resolve","reject","put","recv","setTimeout","buffered_amount","max_size","queue","put_callbacks","get_callbacks","put_now","get_now","callback","is_node","dns_cache","Map","resolver","assert_on_node","resolve4","resolve6","async","resolve_with_fallback","resolve_first","resolve_after","lookup_ip","ip_level","isIP","now","entry_hostname","cache_entry","delete","lookup","order","Resolver","setServers","perform_lookup","NodeTCPSocket","recv_buffer_size","socket","paused","ip","Socket","setNoDelay","on","destroy","write","end","pause","resume","NodeUDPSocket","createSocket","AccessDeniedError","check_port_range","entry","check_whitelist","entries","filter","matched","check_blacklist","check_ip_range","includes","is_stream_allowed","ip_str","is_ip_blocked","streams","streams_per_host","HandshakeError","ServerStream","conn","packets_sent","setup","tcp_to_ws","catch","conn_id","ws_to_tcp","put_data","ServerConnection","path","TCPSocket","UDPSocket","ping_interval","ping_task","randomUUID","setup_wisp_v2","continue_packet","ping","setInterval","client_extensions","close_reason","quiet","route_packet","type_info","trim","run","clearInterval","WSProxyConnection","ws_server","headers","client_ip","routeRequest","request","head","conn_options","IncomingMessage","handleUpgrade","create_connection","wisp_conn","wsproxy","stack","noServer"],"ignoreList":[],"sourceRoot":""}