{"version":3,"file":"wisp-server-legacy.js","mappings":"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","sources":["webpack://wisp_server/./node_modules/ipaddr.js/lib/ipaddr.js","webpack://wisp_server/webpack/bootstrap","webpack://wisp_server/webpack/runtime/define property getters","webpack://wisp_server/webpack/runtime/hasOwnProperty shorthand","webpack://wisp_server/webpack/runtime/make namespace object","webpack://wisp_server/./src/logging.mjs","webpack://wisp_server/./src/packet.mjs","webpack://wisp_server/./src/server/options.mjs","webpack://wisp_server/./src/compat_browser.mjs","webpack://wisp_server/./src/websocket.mjs","webpack://wisp_server/./src/server/net.mjs","webpack://wisp_server/./src/server/filter.mjs","webpack://wisp_server/./src/extensions.mjs","webpack://wisp_server/./src/server/connection.mjs","webpack://wisp_server/./src/server/wsproxy.mjs","webpack://wisp_server/./src/server/http.mjs"],"sourcesContent":["(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 18, 0, 0]), 15],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ],\n            // RFC7534, RFC7535\n            as112: [\n                [new IPv4([192, 175, 48, 0]), 24],\n                [new IPv4([192, 31, 196, 0]), 24],\n            ],\n            // RFC7450\n            amt: [\n                [new IPv4([192, 52, 193, 0]), 24],\n            ],\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv4 address in CIDR notation.\n    ipaddr.IPv4.isValidCIDR = function (string) {\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address with CIDR prefix.\n    ipaddr.IPv4.isValidCIDRFourPartDecimal = function (string) {\n        const match = string.match(/^(.+)\\/(\\d+)$/);\n\n        if (!ipaddr.IPv4.isValidCIDR(string) || !match) {\n            return false;\n        }\n\n        return ipaddr.IPv4.isValidFourPartDecimal(match[1]);\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6666\n            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC5180\n            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n            // RFC7450\n            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n            as112v6: [\n                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],\n                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],\n            ],\n            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],\n            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],\n            reserved: [\n                // RFC3849\n                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],\n                // RFC2928\n                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],\n            ],\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // Calls toRFC5952String under the hood.\n        IPv6.prototype.toString = function () {\n            return this.toRFC5952String();\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv6 address in CIDR notation.\n    ipaddr.IPv6.isValidCIDR = function (string) {\n\n        // See note in IPv6.isValid\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = match[1]\n            if (!match[1].endsWith('::')) {\n                addr = addr.slice(0, -1)\n            }\n            addr = expandIPv6(addr + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n    // Checks if the address is valid IP address in CIDR notation\n    ipaddr.isValidCIDR = function (string) {\n        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const DEBUG = 0;\nexport const INFO = 1;\nexport const WARN = 2;\nexport const ERROR = 3;\nexport const NONE = 4;\nexport let log_level = INFO;\n\nexport function get_timestamp() {\n  let [date, time] = new Date().toJSON().split(\"T\");\n  date = date.replaceAll(\"-\", \"/\");\n  time = time.split(\".\")[0];\n  return `[${date} - ${time}]`;\n}\n\nexport function set_level(level) {\n  log_level = level;\n}\n\nexport function debug(...messages) {\n  if (log_level > DEBUG) return;\n  console.debug(get_timestamp() + \" debug:\", ...messages);\n}\n\nexport function info(...messages) {\n  if (log_level > INFO) return;\n  console.info(get_timestamp() + \" info:\", ...messages);\n}\n\nexport function log(...messages) {\n  if (log_level > INFO) return;\n  console.log(get_timestamp() + \" log:\", ...messages);\n}\n\nexport function warn(...messages) {\n  if (log_level > WARN) return;\n  console.warn(get_timestamp() + \" warn:\", ...messages);\n}\n\nexport function error(...messages) {\n  if (log_level > ERROR) return;\n  console.error(get_timestamp() + \" error:\", ...messages);\n}\n\n","//shared packet parsing / serialization code\n\nconst text_encoder = new TextEncoder();\nconst encode_text = text_encoder.encode.bind(text_encoder);\nconst text_decoder = new TextDecoder();\nconst decode_text = text_decoder.decode.bind(text_decoder);\n\nexport class WispBuffer {\n  constructor(data) {\n    if (data instanceof Uint8Array) {\n      this.from_array(data);\n    }\n    else if (typeof data === \"number\") {\n      this.from_array(new Uint8Array(data));\n    }\n    else if (typeof data === \"string\") {\n      this.from_array(encode_text(data));\n    }\n    else {\n      console.trace();\n      throw \"invalid data type passed to wisp buffer constructor\";\n    }\n  }\n\n  from_array(bytes) {\n    this.size = bytes.length;\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer); \n  }\n\n  concat(buffer) {\n    let new_buffer = new WispBuffer(this.size + buffer.size);\n    new_buffer.bytes.set(this.bytes, 0);\n    new_buffer.bytes.set(buffer.bytes, this.size);\n    return new_buffer;\n  }\n\n  slice(index, size) {\n    let bytes_slice = this.bytes.slice(index, size);\n    return new WispBuffer(bytes_slice);\n  }\n\n  get_string() {\n    return text_decoder.decode(this.bytes);\n  }\n}\n\nexport class WispPacket {\n  static min_size = 5;\n  constructor({type, stream_id, payload, payload_bytes }) {\n    this.type = type;\n    this.stream_id = stream_id;\n    this.payload_bytes = payload_bytes;\n    this.payload = payload;\n  }\n  static parse(buffer) {\n    return new WispPacket({\n      type: buffer.view.getUint8(0),\n      stream_id: buffer.view.getUint32(1, true),\n      payload_bytes: buffer.slice(5)\n    });\n  }\n  static parse_all(buffer) {\n    if (buffer.size < WispPacket.min_size) {\n      throw TypeError(\"packet too small\");\n    }\n    let packet = WispPacket.parse(buffer);\n    let payload_class = packet_classes[packet.type];\n    if (typeof payload_class === \"undefined\") {\n      throw TypeError(\"invalid packet type\");\n    }\n    if (packet.payload_bytes.size < payload_class.size) {\n      throw TypeError(\"payload too small\");\n    }\n    packet.payload = payload_class.parse(packet.payload_bytes);\n    return packet;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    buffer.view.setUint8(0, this.type);\n    buffer.view.setUint32(1, this.stream_id, true);\n    buffer = buffer.concat(this.payload.serialize());\n    return buffer;\n  }\n}\n\nexport class ConnectPayload {\n  static min_size = 3;\n  static type = 0x01;\n  static name = \"CONNECT\";\n  constructor({stream_type, port, hostname}) {\n    this.stream_type = stream_type;\n    this.port = port;\n    this.hostname = hostname;\n  }\n  static parse(buffer) {\n    return new ConnectPayload({\n      stream_type: buffer.view.getUint8(0),\n      port: buffer.view.getUint16(1, true),\n      hostname: decode_text(buffer.slice(3).bytes)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(3);\n    buffer.view.setUint8(0, this.stream_type);\n    buffer.view.setUint16(1, this.port, true);\n    buffer = buffer.concat(new WispBuffer(this.hostname));\n    return buffer;\n  }\n}\n\nexport class DataPayload {\n  static min_size = 0;\n  static type = 0x02;\n  static name = \"DATA\";\n  constructor({data}) {\n    this.data = data;\n  }\n  static parse(buffer) {\n    return new DataPayload({\n      data: buffer\n    });\n  }\n  serialize() {\n    return this.data;\n  }\n}\n\nexport class ContinuePayload {\n  static type = 0x03;\n  static name = \"CONTINUE\";\n  constructor({buffer_remaining}) {\n    this.buffer_remaining = buffer_remaining;\n  }\n  static parse(buffer) {\n    return new ContinuePayload({\n      buffer_remaining: buffer.view.getUint32(0, true),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(4);\n    buffer.view.setUint32(0, this.buffer_remaining, true);\n    return buffer;\n  }\n}\n\nexport class ClosePayload {\n  static min_size = 1;\n  static type = 0x04;\n  static name = \"CLOSE\";\n  constructor({reason}) {\n    this.reason = reason;\n  }\n  static parse(buffer) {\n    return new ClosePayload({\n      reason: buffer.view.getUint8(0),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(1);\n    buffer.view.setUint8(0, this.reason);\n    return buffer;\n  }\n}\n\nexport class InfoPayload {\n  static min_size = 2;\n  static type = 0x05;\n  static name = \"INFO\";\n  constructor({major_ver, minor_ver, extensions}) {\n    this.major_ver = major_ver;\n    this.minor_ver = minor_ver;\n    this.extensions = extensions;\n  }\n  static parse(buffer) {\n    return new InfoPayload({\n      major_ver: buffer.view.getUint8(0),\n      minor_ver: buffer.view.getUint8(1),\n      extensions: buffer.slice(2)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(2);\n    buffer.view.setUint8(0, this.major_ver);\n    buffer.view.setUint8(1, this.minor_ver);\n    return buffer.concat(this.extensions);\n  }\n}\n\nexport const packet_classes = {\n  0x01: ConnectPayload, \n  0x02: DataPayload, \n  0x03: ContinuePayload, \n  0x04: ClosePayload,\n  0x05: InfoPayload\n}\n\nexport const packet_types = {\n  CONNECT: 0x01,\n  DATA: 0x02,\n  CONTINUE: 0x03,\n  CLOSE: 0x04,\n  INFO: 0x05\n}\n\nexport const stream_types = {\n  TCP: 0x01,\n  UDP: 0x02\n}\n\nexport const close_reasons = {\n  //client/server close reasons\n  Unknown: 0x01,\n  Voluntary: 0x02,\n  NetworkError: 0x03,\n  IncompatibleExtensions: 0x04,\n\n  //server only close reasons\n  InvalidInfo: 0x41, \n  UnreachableHost: 0x42,\n  NoResponse: 0x43,\n  ConnRefused: 0x44,\n  TransferTimeout: 0x47,\n  HostBlocked: 0x48,\n  ConnThrottled: 0x49,\n\n  //client only close reasons\n  ClientError: 0x81,\n\n  //extension specific close reasons\n  AuthBadPassword: 0xc0,\n  AuthBadSignature: 0xc1,\n  AuthMissingCredentials: 0xc2\n}","export const options = {\n  //destination hostname restrictions\n  hostname_blacklist: null,\n  hostname_whitelist: null,\n  port_blacklist: null,\n  port_whitelist: null,\n  allow_direct_ip: true,\n  allow_private_ips: false,\n  allow_loopback_ips: false,\n  \n  //client connection restrictions\n  client_ip_blacklist: null, //not implemented!\n  client_ip_whitelist: null, //not implemented!\n  stream_limit_per_host: -1,\n  stream_limit_total: -1,\n  allow_udp_streams: true,\n  allow_tcp_streams: true,\n\n  //dns options\n  dns_ttl: 120,\n  dns_method: \"lookup\",\n  dns_servers: null,\n  dns_result_order: \"verbatim\",\n\n  //misc options\n  parse_real_ip: true,\n  parse_real_ip_from: [\"127.0.0.1\"],\n\n  //wisp v2 options\n  wisp_version: 2,\n  wisp_motd: null\n}\n\n","//the node modules referenced by other parts of the code do not exist on the web\n//some of them can be replaced by the standard browser apis, others have to be ignored\n\n//compatibility for old browsers where globalThis doesn't exist\nexport const global_this = typeof globalThis === \"undefined\" ? window : globalThis;\n\nexport const WebSocket = global_this.WebSocket;\nexport const crypto = global_this.crypto;\nexport const WebSocketServer = null;\nexport const net = null;\nexport const dgram = null;\nexport const dns = null;\nexport const http = null;","//async websocket wrapper for both node and the browser\n\nimport * as compat from \"./compat.mjs\";\nimport { WispPacket } from \"./packet.mjs\";\n\nexport function get_conn_id() {\n  return compat.crypto.randomUUID().split(\"-\")[0];\n}\n\n//an async websocket wrapper\nexport class AsyncWebSocket {\n  send_buffer_size = 32*1024*1024;\n  \n  constructor(ws) {\n    this.ws = ws;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(1);\n  }\n\n  async connect() {\n    await new Promise((resolve, reject) => {\n      this.ws.onopen = () => {\n        this.connected = true;\n        resolve();\n      }\n      this.ws.onmessage = (event) => {\n        this.data_queue.put(event.data);\n      }\n      this.ws.onclose = () => {\n        if (!this.connected) reject();\n        else this.data_queue.close();\n      }\n      if (this.ws.readyState === this.ws.OPEN) {\n        this.connected = true;\n        resolve();\n      }\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    if (data instanceof WispPacket) {\n      data = data.serialize().bytes\n    }\n\n    this.ws.send(data);\n    if (this.ws.bufferedAmount <= this.send_buffer_size) {\n      return;\n    }\n\n    //if the send buffer is too full, throttle the upload\n    while (true) {\n      if (this.ws.bufferedAmount <= this.send_buffer_size / 2) {\n        break;\n      }\n      await new Promise((resolve) => {setTimeout(resolve, 10)});\n    }\n  }\n\n  close(code, reason) {\n    this.ws.close(code, reason);\n    this.data_queue.close();\n  }\n\n  get buffered_amount() {\n    return this.ws.bufferedAmount;\n  }\n}\n\n//an async fifo queue\nexport class AsyncQueue {\n  constructor(max_size) {\n    this.max_size = max_size;\n    this.queue = [];\n    this.put_callbacks = [];\n    this.get_callbacks = [];\n  }\n\n  put_now(data) {\n    this.queue.push(data);\n    this.get_callbacks.shift()?.();\n  }\n\n  async put(data) {\n    if (this.size <= this.max_size) {\n      this.put_now(data);\n      return;\n    }\n\n    //wait until there is a place to put the item\n    await new Promise((resolve) => {\n      this.put_callbacks.push(resolve);\n    });\n    this.put_now(data);\n  }\n\n  get_now() {\n    this.put_callbacks.shift()?.();\n    return this.queue.shift();\n  }\n\n  async get() {\n    if (this.size > 0) {\n      return this.get_now();\n    }\n\n    //wait until there is an item available in the queue\n    await new Promise((resolve) => {\n      this.get_callbacks.push(resolve);\n    });\n    return this.get_now();\n  }\n\n  close() {\n    this.queue = [];\n    let callback;\n    //resolve all pending operations\n    while (callback = this.get_callbacks.shift())\n      callback();\n    while (callback = this.put_callbacks.shift())\n      callback();\n  }\n\n  get size() {\n    return this.queue.length;\n  }\n}","import * as logging from \"../logging.mjs\";\nimport { AsyncQueue } from \"../websocket.mjs\";\nimport { options } from \"./options.mjs\";\nimport { net, dgram, dns } from \"../compat.mjs\";\n\n//wrappers for node networking apis\n//in the browser these can be redefined to allow for custom transports\n\nexport const is_node = (typeof process !== \"undefined\");\n\nconst dns_cache = new Map();\nlet dns_servers = null;\nlet resolver = null;\n\nexport function assert_on_node() {\n  if (!is_node) {\n    throw new Error(\"not running on node.js\");\n  }\n}\n\n//wrapper for node resolver methods\n//resolve4 and resolve6 need to be wrapped to work around a nodejs bug\nfunction resolve4(hostname) {\n  return resolver.resolve4(hostname);\n}\nfunction resolve6(hostname) {\n  return resolver.resolve6(hostname);\n}\nasync function resolve_with_fallback(resolve_first, resolve_after, hostname) {\n  try {\n    return (await resolve_first(hostname))[0];\n  }\n  catch {\n    return (await resolve_after(hostname))[0];\n  }\n}  \n\n//a wrapper for the actual dns lookup\nasync function perform_lookup(hostname) {\n  //resolve using system dns\n  if (options.dns_method === \"lookup\") {\n    let result = await dns.lookup(hostname, {order: options.dns_result_order}); \n    return result.address;\n  }\n\n  //resolve using dns.resolve4 / dns.resolve6, which bypasses the system dns\n  else if (options.dns_method === \"resolve\") {\n    //we need to make a new resolver at first run because setServers doesn't work otherwise\n    if (!resolver) resolver = new dns.Resolver();\n\n    //set custom dns servers if needed\n    if (options.dns_servers !== dns_servers) {\n      logging.debug(\"Setting custom DNS servers to: \" + options.dns_servers.join(\", \"));\n      resolver.setServers(options.dns_servers);\n      dns_servers = options.dns_servers;\n    }\n\n    if (options.dns_result_order === \"verbatim\" || options.dns_result_order === \"ipv6first\") \n      return await resolve_with_fallback(resolve6, resolve4, hostname);\n    else if (options.dns_result_order === \"ipv4first\")\n      return await resolve_with_fallback(resolve4, resolve6, hostname);\n    else\n      throw new Error(\"Invalid result order. options.dns_result_order must be either 'ipv6first', 'ipv4first', or 'verbatim'.\");\n  }\n\n  //use a custom function for dns resolution\n  else if (typeof options.dns_method === \"function\") {\n    return await options.dns_method(hostname);\n  }\n\n  throw new Error(\"Invalid DNS method. options.dns_method must either be 'lookup' or 'resolve'.\");\n}\n\n//perform a dns lookup and use the cache\nexport async function lookup_ip(hostname) {\n  if (!is_node) { //we cannot do the dns lookup on the browser\n    return hostname;\n  }\n\n  let ip_level = net.isIP(hostname);\n  if (ip_level === 4 || ip_level === 6) {\n    return hostname; //hostname is already an ip address\n  }\n\n  //remove stale entries from the cache\n  let now = Date.now();\n  for (let [entry_hostname, cache_entry] of dns_cache) {\n    let ttl = now - cache_entry.time;\n    if (ttl > options.dns_ttl) {\n      dns_cache.delete(entry_hostname);\n    }\n  }\n\n  //look in the cache first before using the system resolver\n  let cache_entry = dns_cache.get(hostname);\n  if (cache_entry) {\n    if (cache_entry.error) \n      throw cache_entry.error\n    return cache_entry.address;\n  }\n\n  //try to perform the actual dns lookup and store the result\n  let address;\n  try {\n    address = await perform_lookup(hostname);\n    logging.debug(`Domain resolved: ${hostname} -> ${address}`);\n    dns_cache.set(hostname, {time: Date.now(), address: address});\n  }\n  catch (e) {\n    dns_cache.set(hostname, {time: Date.now(), error: e});\n    throw e;\n  }\n\n  return address;\n}\n\n//async tcp and udp socket wrappers\nexport class NodeTCPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n    this.recv_buffer_size = 128;\n\n    this.socket = null;\n    this.paused = false;\n    this.connected = false;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    await new Promise((resolve, reject) => {\n      this.socket = new net.Socket();\n      this.socket.setNoDelay(true);\n      this.socket.on(\"connect\", () => {\n        this.connected = true;\n        resolve();\n      });\n      this.socket.on(\"data\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"close\", (error) => {\n        if (error && !this.connected) reject();\n        else this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.on(\"error\", (error) => {\n        logging.warn(`tcp stream to ${this.hostname} ended with error - ${error}`);\n      });\n      this.socket.on(\"end\", () => {\n        if (!this.socket) return;\n        this.socket.destroy();\n        this.socket = null;\n      });\n      this.socket.connect({\n        host: ip,\n        port: this.port\n      });\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    await new Promise((resolve) => {\n      this.socket.write(data, resolve);\n    });\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.end();\n    this.socket = null;\n  }\n\n  pause() {\n    if (this.data_queue.size >= this.data_queue.max_size) {\n      this.socket.pause();\n      this.paused = true;\n    }\n  }\n  resume() {\n    if (!this.socket) return;\n    if (this.paused) {\n      this.socket.resume();\n      this.paused = false;\n    }\n  }\n}\n\nexport class NodeUDPSocket {\n  constructor(hostname, port) {\n    assert_on_node();\n    this.hostname = hostname;\n    this.port = port;\n\n    this.connected = false;\n    this.recv_buffer_size = 128;\n    this.data_queue = new AsyncQueue(this.recv_buffer_size);\n  }\n\n  async connect() {\n    let ip = await lookup_ip(this.hostname);\n    let ip_level = net.isIP(ip);\n    await new Promise((resolve, reject) => {\n      this.socket = dgram.createSocket(ip_level === 6 ? \"udp6\" : \"udp4\");\n      this.socket.on(\"connect\", () => {\n        resolve();\n      });\n      this.socket.on(\"message\", (data) => {\n        this.data_queue.put(data);\n      });\n      this.socket.on(\"error\", () => {\n        if (!this.connected) reject();\n        this.data_queue.close();\n        this.socket = null;\n      });\n      this.socket.connect(this.port, ip);\n    });\n  }\n\n  async recv() {\n    return await this.data_queue.get();\n  }\n\n  async send(data) {\n    this.socket.send(data);\n  }\n\n  async close() {\n    if (!this.socket) return;\n    this.socket.close();\n    this.socket = null;\n  }\n\n  pause() {}\n  resume() {}\n}","import { close_reasons, stream_types } from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport * as net from \"./net.mjs\";\n\nimport ipaddr from \"ipaddr.js\";\n\nexport class AccessDeniedError extends Error {}\n\n//helper functions for the whitelist/blacklist logic\nfunction check_port_range(entry, port) {\n  return (entry === port) || (entry[0] <= port && entry[1] >= port)\n}\nfunction check_whitelist(entries, filter) {\n  let matched = false;\n  for (let entry of entries) {\n    if (filter(entry)) {\n      matched = true;\n      break\n    }\n  }\n  return !matched;\n}\nfunction check_blacklist(entries, filter) {\n  for (let entry of entries) {\n    if (filter(entry))\n      return true;\n    }\n  return false;\n}\n\nfunction check_ip_range(ip, range) {\n  return range.includes(ip.range());\n}\n\n//check if an ip is blocked\nexport function is_ip_blocked(ip_str) {\n  if (!ipaddr.isValid(ip_str)) \n    return false;\n  let ip = ipaddr.parse(ip_str);\n\n  let loopback_ranges = [\"loopback\", \"unspecified\"];\n  let private_ranges = [\"broadcast\", \"linkLocal\", \"carrierGradeNat\", \"private\", \"reserved\"];\n\n  if (!options.allow_loopback_ips && check_ip_range(ip, loopback_ranges)) \n    return true;\n  if (!options.allow_private_ips && check_ip_range(ip, private_ranges)) \n    return true;\n  return false;\n}\n\n//returns the close reason if the connection should be blocked\nexport async function is_stream_allowed(connection, type, hostname, port) {\n  //check if tcp or udp should be blocked\n  if (!options.allow_tcp_streams && type === stream_types.TCP)\n    return close_reasons.HostBlocked;\n  if (!options.allow_udp_streams && type === stream_types.UDP)\n    return close_reasons.HostBlocked;\n\n  //check the hostname whitelist/blacklist\n  if (options.hostname_whitelist) {\n    if (check_whitelist(options.hostname_whitelist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n  else if (options.hostname_blacklist) {\n    if (check_blacklist(options.hostname_blacklist, (entry) => entry.test(hostname)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the port is blocked\n  if (options.port_whitelist) {\n    if (check_whitelist(options.port_whitelist, (entry) => check_port_range(entry, port))) \n      return close_reasons.HostBlocked;\n  }\n  else if (options.port_blacklist) {\n    if (check_blacklist(options.port_blacklist, (entry) => check_port_range(entry, port)))\n      return close_reasons.HostBlocked;\n  }\n\n  //check if the destination ip is blocked\n  let ip_str = hostname;\n  if (ipaddr.isValid(hostname)) {\n    if (!options.allow_direct_ip)\n      return close_reasons.HostBlocked;\n  }\n  else {\n    try { //look up the ip to make sure that the resolved address is allowed\n      ip_str = await net.lookup_ip(hostname);\n    }\n    catch {}\n  }\n  if (is_ip_blocked(ip_str)) \n    return close_reasons.HostBlocked;\n\n  //don't check stream counts if there isn't an associated wisp connection (with wsproxy for example)\n  if (!connection) \n    return 0;\n\n  //check for stream count limits\n  if (options.stream_limit_total !== -1 && Object.keys(connection.streams).length >= options.stream_limit_total) \n    return close_reasons.ConnThrottled;\n  if (options.stream_limit_per_host !== -1) {\n    let streams_per_host = 0;\n    for (let stream of connection.streams) {\n      if (stream.socket.hostname === hostname) {\n        streams_per_host++;\n      }\n    }\n    if (streams_per_host >= options.stream_limit_per_host)\n      return close_reasons.ConnThrottled;\n  }\n\n  return 0;\n}","import { WispBuffer } from \"./packet.mjs\";\n\nclass EmptyPayload {\n  constructor() {}\n  static parse() {\n    return new EmptyPayload();\n  }\n  serialize() {\n    return new WispBuffer(0);\n  }\n}\n\nexport class BaseExtension {\n  static id = 0x00;\n  static name = \"\";\n\n  static Server = EmptyPayload;\n  static Client = EmptyPayload;\n\n  constructor({server_config, client_config} = {}) {\n    this.id = this.constructor.id;\n    this.name = this.constructor.name;\n    if (server_config)\n      this.payload = new this.constructor.Server(server_config);\n    else if (client_config)\n      this.payload = new this.constructor.Client(client_config);\n  }\n  static parse(ext_class, buffer, role) {\n    let extension = new ext_class({});\n    if (role === \"client\")\n      extension.payload = ext_class.Client.parse(buffer.slice(5));\n    else if (role === \"server\")\n      extension.payload = ext_class.Server.parse(buffer.slice(5));\n    else \n      throw TypeError(\"invalid role\");\n    return extension;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    let payload_buffer = this.payload.serialize();\n    buffer.view.setInt8(0, this.constructor.id);\n    buffer.view.setUint32(1, payload_buffer.size, true);\n    return buffer.concat(payload_buffer);\n  }\n}\n\nexport class UDPExtension extends BaseExtension {\n  static id = 0x01;\n  static name = \"UDP\";\n}\n\nexport class PasswordAuthExtension extends BaseExtension {\n  static id = 0x02;\n  static name = \"Password Authentication\";\n\n  static Server = class {\n    constructor({required = 1}) {\n      this.required = required ? 1 : 0;\n    }\n    static parse(buffer) {\n      return new PasswordAuthExtension.Server({\n        required: buffer.view.getUint8(0)\n      });\n    }\n    serialize() {\n      let buffer = new WispBuffer(1);\n      buffer.view.setUint8(0, this.required);\n      return buffer;\n    }\n  }\n\n  static Client = class {\n    constructor({username, password}) {\n      this.username = username;\n      this.password = password;\n    }\n    static parse(buffer) {\n      let username_len = buffer.view.getUint8(0);\n      let password_len = buffer.view.getUint16(1, true);\n      let password_index = username_len + 3;\n      return new PasswordAuthExtension.Client({\n        username: buffer.slice(3, username_len).get_string(),\n        password: buffer.slice(password_index, password_len).get_string()\n      });\n    }\n    serialize() {\n      let username_buffer = new WispBuffer(this.username);\n      let password_buffer = new WispBuffer(this.password);\n      let buffer = new WispBuffer(3);\n      buffer.view.setUint8(0, username_buffer.size);\n      buffer.view.setUint16(1, password_buffer.size, true);\n      return buffer.concat(username_buffer).concat(password_buffer);\n    }\n  }\n}\n\nexport class MOTDExtension extends BaseExtension {\n  static id = 0x04;\n  static name = \"Server MOTD\";\n\n  static Server = class {\n    constructor({message}) {\n      this.message = message;\n    }\n    static parse(buffer) {\n      return new MOTDExtension.Server({\n        message: buffer.get_string()\n      });\n    }\n    serialize() {\n      return new WispBuffer(this.message);\n    }\n  }\n\n  static Client = EmptyPayload;\n}\n\nexport function parse_extensions(payload_buffer, valid_extensions, role) {\n  let index = 0;\n  let parsed_extensions = [];\n  while (payload_buffer.size) {\n    let ext_id = payload_buffer.view.getUint8(index);\n    let ext_len = payload_buffer.view.getUint32(index + 1, true);\n    let ext_payload = payload_buffer.slice(0, 5 + ext_len);\n    let ext_class;\n    for (let extension of valid_extensions) {\n      if (extension.id !== ext_id) \n        continue;\n      ext_class = extension.constructor;\n      break;\n    }\n    if (ext_class) {\n      let ext_parsed = BaseExtension.parse(ext_class, ext_payload, role);\n      parsed_extensions.push(ext_parsed);\n    }\n    payload_buffer = payload_buffer.slice(5 + ext_len);\n  }\n  return parsed_extensions;\n}\n\nexport function serialize_extensions(extensions) {{\n  let ext_buffer = new WispBuffer(0);\n  for (let extension of extensions) {\n    ext_buffer = ext_buffer.concat(extension.serialize());\n  }\n  return ext_buffer;\n}}\n\nexport const extensions_map = {\n  0x01: UDPExtension,\n  0x02: PasswordAuthExtension,\n  0x04: MOTDExtension\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { AsyncQueue, AsyncWebSocket, get_conn_id } from \"../websocket.mjs\";\nimport { NodeTCPSocket, NodeUDPSocket } from \"./net.mjs\";\nimport { \n  WispBuffer,\n  WispPacket,\n  ContinuePayload,\n  ClosePayload,\n  ConnectPayload,\n  DataPayload,\n  InfoPayload,\n  stream_types,\n  close_reasons\n} from \"../packet.mjs\";\nimport { options } from \"./options.mjs\";\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nexport class HandshakeError extends Error {}\n\nexport class ServerStream {\n  static buffer_size = 128;\n\n  constructor(stream_id, conn, socket) {\n    this.stream_id = stream_id;\n    this.conn = conn;\n    this.socket = socket;    \n    this.send_buffer = new AsyncQueue(ServerStream.buffer_size);\n    this.packets_sent = 0;\n  }\n\n  async setup() {\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a tcp/udp to ws task encountered an error - ${error}`);\n      this.close();\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`(${this.conn.conn_id}) a ws to tcp/udp task encountered an error - ${error}`);\n      this.close();\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n\n      this.socket.pause();\n      let packet = new WispPacket({\n        type: DataPayload.type,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(new Uint8Array(data))\n        })\n      });\n      await this.conn.ws.send(packet);\n      this.socket.resume();\n    }\n    await this.conn.close_stream(this.stream_id, close_reasons.Voluntary);\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data = await this.send_buffer.get();\n      if (data == null) {\n        break; //stream closed\n      }\n      await this.socket.send(data);\n\n      this.packets_sent++;\n      if (this.packets_sent % (ServerStream.buffer_size / 2) !== 0) {\n        continue;\n      }\n      let packet = new WispPacket({\n        type: ContinuePayload.type,\n        stream_id: this.stream_id,\n        payload: new ContinuePayload({\n          buffer_remaining: ServerStream.buffer_size - this.send_buffer.size\n        })\n      });\n      this.conn.ws.send(packet);\n    }\n    await this.close();\n  }\n\n  async close(reason = null) {\n    this.send_buffer.close();\n    this.socket.close();\n    if (reason == null) return;\n\n    let packet = new WispPacket({\n      type: ClosePayload.type,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    await this.conn.ws.send(packet);\n  }\n\n  async put_data(data) {\n    await this.send_buffer.put(data);\n  }\n}\n\nexport class ServerConnection {\n  constructor(ws, path, {TCPSocket, UDPSocket, ping_interval, wisp_version, wisp_extensions} = {}) {\n    this.ws = new AsyncWebSocket(ws);\n    this.path = path;\n    this.TCPSocket = TCPSocket || NodeTCPSocket;\n    this.UDPSocket = UDPSocket || NodeUDPSocket;\n    this.ping_interval = ping_interval || 30;\n    this.wisp_version = wisp_version || options.wisp_version;\n    this.wisp_extensions = wisp_extensions || null;\n    \n    this.ping_task = null;\n    this.streams = {};\n    this.conn_id = get_conn_id();\n\n    this.server_exts = {};\n    this.client_exts = {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    if (options.allow_udp_streams) \n      this.wisp_extensions.push(new UDPExtension({server_config: {}}));\n    if (options.wisp_motd)\n      this.wisp_extensions.push(new MOTDExtension({server_config: {\n        message: options.wisp_motd\n      }}));\n  }\n\n  async setup() {\n    logging.info(`setting up new wisp v${this.wisp_version} connection with id ${this.conn_id}`);\n\n    await this.ws.connect();\n    if (this.wisp_version == 2) {\n      await this.setup_wisp_v2()\n    }\n\n    //send initial continue packet\n    let continue_packet = new WispPacket({\n      type: ContinuePayload.type,\n      stream_id: 0,\n      payload: new ContinuePayload({\n        buffer_remaining: ServerStream.buffer_size\n      })\n    });\n    this.ws.send(continue_packet);\n\n    if (typeof this.ws.ws.ping === \"function\") {\n      this.ping_task = setInterval(() => {\n        logging.debug(`(${this.conn_id}) sending websocket ping`);\n        this.ws.ws.ping();\n      }, this.ping_interval * 1000);  \n    }\n  }\n\n  async setup_wisp_v2() {\n    //send initial info packet for wisp v2\n    let ext_buffer = serialize_extensions(this.wisp_extensions);\n    let info_packet = new WispPacket({\n      type: InfoPayload.type,\n      stream_id: 0,\n      payload: new InfoPayload({\n        major_ver: this.wisp_version,\n        minor_ver: 0,\n        extensions: ext_buffer\n      })\n    });\n    this.ws.send(info_packet);\n\n    //wait for the client's info packet\n    let data = await this.ws.recv();\n    if (data == null) {\n      logging.warn(`(${this.conn_id}) handshake error: ws closed before handshake complete`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n    let buffer = new WispBuffer(new Uint8Array(data));\n    let packet = WispPacket.parse_all(buffer);\n\n    if (packet.type !== InfoPayload.type) {\n      logging.warn(`(${this.conn_id}) handshake error: unexpected packet of type ${packet.type}`);\n      await this.cleanup();\n      throw new HandshakeError();\n    }\n\n    //figure out the common extensions\n    let client_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"client\");\n    for (let client_ext of client_extensions) {\n      for (let server_ext of this.wisp_extensions) {\n        if (server_ext.id === client_ext.id) {\n          this.server_exts[server_ext.id] = server_ext;\n          this.client_exts[client_ext.id] = client_ext;\n        }\n      }\n    }\n  }\n\n  create_stream(stream_id, type, hostname, port) {\n    let SocketImpl = type === stream_types.TCP ? this.TCPSocket : this.UDPSocket;\n    let socket = new SocketImpl(hostname, port);\n    let stream = new ServerStream(stream_id, this, socket);\n    this.streams[stream_id] = stream;\n\n    //start connecting to the destination server in the background\n    (async () => {\n      let close_reason = await filter.is_stream_allowed(this, type, hostname, port);\n      if (close_reason) {\n        logging.warn(`(${this.conn_id}) refusing to create a stream to ${hostname}:${port}`);\n        await this.close_stream(stream_id, close_reason, true);\n        return;\n      }\n      try {\n        await stream.setup();\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) creating a stream to ${hostname}:${port} failed - ${error}`);\n        await this.close_stream(stream_id, close_reasons.NetworkError);\n      }\n    })();\n  }\n\n  async close_stream(stream_id, reason = null, quiet = false) {\n    let stream = this.streams[stream_id];\n    if (stream == null) {\n      return;\n    }\n    if (reason && !quiet) {\n      logging.info(`(${this.conn_id}) closing stream to ${stream.socket.hostname} for reason ${reason}`);\n    }\n    await stream.close(reason);\n    delete this.streams[stream_id];\n  }\n\n  route_packet(buffer) {\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.streams[packet.stream_id];\n\n    if (stream == null && packet.type == DataPayload.type) {\n      logging.warn(`(${this.conn_id}) received a DATA packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === ConnectPayload.type) {\n      let type_info = packet.payload.stream_type === stream_types.TCP ? \"TCP\" : \"UDP\";\n      logging.info(`(${this.conn_id}) opening new ${type_info} stream to ${packet.payload.hostname}:${packet.payload.port}`);\n      this.create_stream(\n        packet.stream_id, \n        packet.payload.stream_type, \n        packet.payload.hostname.trim(), \n        packet.payload.port\n      )\n    }\n\n    else if (packet.type === DataPayload.type) {\n      stream.put_data(packet.payload.data.bytes);\n    }\n\n    else if (packet.type == ContinuePayload.type) {\n      logging.warn(`(${this.conn_id}) client sent a CONTINUE packet, this should never be possible`);\n    }\n\n    else if (packet.type == ClosePayload.type) {\n      this.close_stream(packet.stream_id, packet.reason);\n    }\n  }\n\n  async run() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      if (typeof data === \"string\") {\n        logging.warn(`(${this.conn_id}) routing a packet failed - unexpected ws text frame`);\n        continue;\n      }\n      \n      try {\n        //note: data is an arraybuffer so the uint8array constructor does not copy\n        this.route_packet(new WispBuffer(new Uint8Array(data)));\n      }\n      catch (error) {\n        logging.warn(`(${this.conn_id}) routing a packet failed - ${error}`);\n      }\n    }\n    \n    await this.cleanup();\n  }\n\n  async cleanup() {\n    //clean up all streams when the websocket is closed\n    for (let stream_id of Object.keys(this.streams)) {\n      await this.close_stream(stream_id);\n    }\n    clearInterval(this.ping_task);\n    logging.info(`(${this.conn_id}) wisp connection closed`);\n    this.ws.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as filter from \"./filter.mjs\";\nimport { stream_types } from \"../packet.mjs\";\nimport { AsyncWebSocket } from \"../websocket.mjs\";\nimport { NodeTCPSocket } from \"./net.mjs\";\n\nexport class WSProxyConnection {\n  constructor(ws, path) {\n    let [hostname, port] = path.split(\"/\").pop().split(\":\");\n    this.hostname = hostname.trim();\n    this.port = parseInt(port);\n    this.ws = new AsyncWebSocket(ws);\n  }\n\n  async setup() {\n    await this.ws.connect();\n\n    //check that the destination host/ip is allowed\n    let err_code = await filter.is_stream_allowed(null, stream_types.TCP, this.hostname, this.port);\n    if (err_code !== 0) {\n      logging.info(`Refusing to create a wsproxy connection to ${this.hostname}:${this.port}`);\n      this.ws.close();\n      throw new filter.AccessDeniedError();\n    }\n\n    //connect to the tcp host after we are certain that it's safe to do so\n    this.socket = new NodeTCPSocket(this.hostname, this.port);\n    await this.socket.connect();\n\n    //start the proxy tasks in the background\n    this.tcp_to_ws().catch((error) => {\n      logging.error(`a tcp to ws task (wsproxy) encountered an error - ${error}`);\n    });\n    this.ws_to_tcp().catch((error) => {\n      logging.error(`a ws to tcp task (wsproxy) encountered an error - ${error}`);\n    });\n  }\n\n  async tcp_to_ws() {\n    while (true) {\n      let data = await this.socket.recv();\n      if (data == null) {\n        break;\n      }\n      this.socket.pause();\n      await this.ws.send(data);\n      this.socket.resume();\n    }\n    await this.ws.close();\n  }\n\n  async ws_to_tcp() {\n    while (true) {\n      let data;\n      data = await this.ws.recv();\n      if (data == null) {\n        break; //websocket closed\n      }\n      await this.socket.send(data);\n    }\n    await this.socket.close();\n  }\n}","import * as logging from \"../logging.mjs\";\nimport * as compat from \"../compat.mjs\";\n\nimport { options } from \"./options.mjs\";\nimport { AccessDeniedError } from \"./filter.mjs\";\nimport { ServerConnection, HandshakeError } from \"./connection.mjs\";\nimport { WSProxyConnection } from \"./wsproxy.mjs\";\nimport { is_node, assert_on_node } from \"./net.mjs\";\n\nlet ws_server = null;\nif (is_node) {\n  ws_server = new compat.WebSocketServer({ noServer: true });\n}\n\nexport function parse_real_ip(headers, client_ip) {\n  if (options.parse_real_ip && options.parse_real_ip_from.includes(client_ip)) {\n    if (headers[\"x-forwarded-for\"]) {\n      return headers[\"x-forwarded-for\"].split(\",\")[0].trim();\n    }\n    else if (headers[\"x-real-ip\"]) {\n      return headers[\"x-real-ip\"];\n    }\n  }\n  return client_ip;\n}\n\nexport function routeRequest(request, socket, head, conn_options={}) {\n  assert_on_node();\n  if (request.headers[\"sec-websocket-protocol\"] && options.wisp_version === 2)\n    conn_options.wisp_version = 2;\n  else \n    conn_options.wisp_version = 1;\n\n  if (request instanceof compat.http.IncomingMessage) {\n    ws_server.handleUpgrade(request, socket, head, (ws) => {\n      create_connection(ws, request.url, request, conn_options);\n    });\n  }\n  else if (request instanceof compat.WebSocket) {\n    create_connection(ws, \"/\", {}), conn_options;\n  }\n}\n\nasync function create_connection(ws, path, request, conn_options) {\n  ws.binaryType = \"arraybuffer\";\n  let client_ip = request.socket.address().address;\n  let real_ip = parse_real_ip(request.headers, client_ip);\n  let origin = request.headers[\"origin\"];\n  logging.info(`new connection on ${path} from ${real_ip} (origin: ${origin})`);\n  \n  try {\n    if (path.endsWith(\"/\")) {\n      let wisp_conn = new ServerConnection(ws, path, conn_options);\n      await wisp_conn.setup();\n      await wisp_conn.run();\n    }\n  \n    else {\n      let wsproxy = new WSProxyConnection(ws, path, conn_options);\n      await wsproxy.setup();\n    }\n  }\n\n  catch (error) {\n    ws.close();\n    if (error instanceof HandshakeError) return;\n    if (error instanceof AccessDeniedError) return;\n    logging.error(\"Uncaught server error:\\n\" + (error.stack || error));\n  }\n}"],"names":["root","ipv4Part","ipv4Regexes","fourOctet","RegExp","threeOctet","twoOctet","longValue","octalRegex","hexRegex","zoneIndex","ipv6Part","ipv6Regexes","deprecatedTransitional","transitional","expandIPv6","string","parts","indexOf","lastIndexOf","replacement","replacementCount","colonCount","lastColon","zoneId","match","substring","replace","substr","slice","length","ref","split","results","i","push","parseInt","matchCIDR","first","second","partSize","cidrBits","Error","shift","part","parseIntAuto","test","isNaN","padPart","ipaddr","IPv4","octets","octet","this","prototype","SpecialRanges","unspecified","broadcast","multicast","linkLocal","loopback","carrierGradeNat","reserved","as112","amt","kind","other","cidrRange","undefined","prefixLengthFromSubnetMask","cidr","stop","zerotable","zeros","range","subnetMatch","toByteArray","toIPv4MappedAddress","IPv6","parse","toString","toNormalizedString","join","broadcastAddressFromCIDR","parseCIDR","ipInterfaceOctets","subnetMaskOctets","subnetMaskFromPrefixLength","e","isIPv4","parser","isValid","isValidCIDR","isValidFourPartDecimal","isValidCIDRFourPartDecimal","networkAddressFromCIDR","maskLength","parsed","Object","defineProperty","value","reverse","prefix","j","filledOctetCount","Math","floor","pow","uniqueLocal","ipv4Mapped","discard","rfc6145","rfc6052","teredo","benchmarking","as112v6","deprecated","orchid2","droneRemoteIdProtocolEntityTags","isIPv4MappedAddress","bytes","toFixedLengthString","addr","call","suffix","toIPv4Address","high","low","toRFC5952String","regex","bestMatchIndex","bestMatchLength","exec","index","isIPv6","native","endsWith","fromByteArray","e2","process","address","rangeList","defaultName","rangeName","rangeSubnets","subnet","hasOwnProperty","Array","apply","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","key","o","enumerable","get","obj","prop","r","Symbol","toStringTag","DEBUG","INFO","WARN","ERROR","NONE","log_level","get_timestamp","date","time","Date","toJSON","replaceAll","set_level","level","debug","_len","arguments","messages","_key","console","info","_len2","_key2","log","_len3","_key3","warn","_len4","_key4","error","_len5","_key5","text_encoder","TextEncoder","encode_text","encode","bind","text_decoder","TextDecoder","decode_text","decode","WispBuffer","constructor","data","Uint8Array","from_array","trace","size","view","DataView","buffer","concat","new_buffer","set","bytes_slice","get_string","WispPacket","_ref","type","stream_id","payload","payload_bytes","getUint8","getUint32","parse_all","min_size","TypeError","packet","payload_class","packet_classes","serialize","setUint8","setUint32","_defineProperty","ConnectPayload","_ref2","stream_type","port","hostname","getUint16","setUint16","DataPayload","_ref3","ContinuePayload","_ref4","buffer_remaining","ClosePayload","_ref5","reason","InfoPayload","_ref6","major_ver","minor_ver","extensions","packet_types","CONNECT","DATA","CONTINUE","CLOSE","stream_types","TCP","UDP","close_reasons","Unknown","Voluntary","NetworkError","IncompatibleExtensions","InvalidInfo","UnreachableHost","NoResponse","ConnRefused","TransferTimeout","HostBlocked","ConnThrottled","ClientError","AuthBadPassword","AuthBadSignature","AuthMissingCredentials","options","hostname_blacklist","hostname_whitelist","port_blacklist","port_whitelist","allow_direct_ip","allow_private_ips","allow_loopback_ips","client_ip_blacklist","client_ip_whitelist","stream_limit_per_host","stream_limit_total","allow_udp_streams","allow_tcp_streams","dns_ttl","dns_method","dns_servers","dns_result_order","parse_real_ip","parse_real_ip_from","wisp_version","wisp_motd","global_this","globalThis","window","WebSocket","crypto","net","http","AsyncWebSocket","ws","connected","data_queue","AsyncQueue","connect","Promise","resolve","reject","onopen","onmessage","event","put","onclose","close","readyState","OPEN","recv","send","bufferedAmount","send_buffer_size","setTimeout","code","buffered_amount","max_size","queue","put_callbacks","get_callbacks","put_now","_this$get_callbacks$s","get_now","_this$put_callbacks$s","callback","is_node","dns_cache","Map","resolver","assert_on_node","resolve4","resolve6","async","resolve_with_fallback","resolve_first","resolve_after","_unused","lookup_ip","ip_level","isIP","now","entry_hostname","cache_entry","delete","lookup","order","Resolver","logging","setServers","perform_lookup","NodeTCPSocket","recv_buffer_size","socket","paused","ip","Socket","setNoDelay","on","destroy","host","write","end","pause","resume","NodeUDPSocket","createSocket","AccessDeniedError","check_port_range","entry","check_whitelist","entries","filter","matched","check_blacklist","check_ip_range","includes","is_stream_allowed","connection","ip_str","is_ip_blocked","keys","streams","streams_per_host","stream","EmptyPayload","BaseExtension","server_config","client_config","id","name","Server","Client","ext_class","role","extension","payload_buffer","setInt8","UDPExtension","PasswordAuthExtension","_PasswordAuthExtension","required","username","password","username_len","password_len","password_index","username_buffer","password_buffer","MOTDExtension","parse_extensions","valid_extensions","parsed_extensions","ext_id","ext_len","ext_payload","ext_parsed","serialize_extensions","ext_buffer","_MOTDExtension","message","extensions_map","HandshakeError","ServerStream","conn","send_buffer","buffer_size","packets_sent","setup","tcp_to_ws","catch","conn_id","ws_to_tcp","close_stream","put_data","ServerConnection","path","TCPSocket","UDPSocket","ping_interval","wisp_extensions","ping_task","compat","randomUUID","server_exts","client_exts","add_extensions","setup_wisp_v2","continue_packet","ping","setInterval","info_packet","cleanup","client_extensions","client_ext","server_ext","create_stream","close_reason","quiet","route_packet","type_info","trim","run","clearInterval","WSProxyConnection","pop","ws_server","headers","client_ip","routeRequest","request","head","conn_options","IncomingMessage","handleUpgrade","create_connection","url","binaryType","wisp_conn","wsproxy","stack","noServer"],"ignoreList":[],"sourceRoot":""}