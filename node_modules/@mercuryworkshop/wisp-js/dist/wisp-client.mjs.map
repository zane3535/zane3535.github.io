{"version":3,"file":"wisp-client.mjs","mappings":"AACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFV,EAAyBC,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,M,2fCDhD,MAAMC,EAAoC,oBAAfC,WAA6BC,OAASD,WAE3DE,EAAYH,EAAYG,UCJ/BC,GDKgBJ,EAAYK,OCLb,IAAIC,aACnBC,EAAcH,EAAaI,OAAOC,KAAKL,GACvCM,EAAe,IAAIC,YACnBC,EAAcF,EAAaG,OAAOJ,KAAKC,GAEtC,MAAMI,EACX,WAAAC,CAAYC,GACV,GAAIA,aAAgBC,WAClBC,KAAKC,WAAWH,QAEb,GAAoB,iBAATA,EACdE,KAAKC,WAAW,IAAIF,WAAWD,QAE5B,IAAoB,iBAATA,EAKd,MADAI,QAAQC,QACF,sDAJNH,KAAKC,WAAWZ,EAAYS,GAK9B,CACF,CAEA,UAAAG,CAAWG,GACTJ,KAAKK,KAAOD,EAAME,OAClBN,KAAKI,MAAQA,EACbJ,KAAKO,KAAO,IAAIC,SAASJ,EAAMK,OACjC,CAEA,MAAAC,CAAOD,GACL,IAAIE,EAAa,IAAIf,EAAWI,KAAKK,KAAOI,EAAOJ,MAGnD,OAFAM,EAAWP,MAAMQ,IAAIZ,KAAKI,MAAO,GACjCO,EAAWP,MAAMQ,IAAIH,EAAOL,MAAOJ,KAAKK,MACjCM,CACT,CAEA,KAAAE,CAAMC,EAAOT,GACX,IAAIU,EAAcf,KAAKI,MAAMS,MAAMC,EAAOT,GAC1C,OAAO,IAAIT,EAAWmB,EACxB,CAEA,UAAAC,GACE,OAAOxB,EAAaG,OAAOK,KAAKI,MAClC,EAGK,MAAMa,EACXC,gBAAkB,EAClB,WAAArB,EAAY,KAACsB,EAAI,UAAEC,EAAS,QAAEC,EAAO,cAAEC,IACrCtB,KAAKmB,KAAOA,EACZnB,KAAKoB,UAAYA,EACjBpB,KAAKsB,cAAgBA,EACrBtB,KAAKqB,QAAUA,CACjB,CACA,YAAOE,CAAMd,GACX,OAAO,IAAIQ,EAAW,CACpBE,KAAMV,EAAOF,KAAKiB,SAAS,GAC3BJ,UAAWX,EAAOF,KAAKkB,UAAU,GAAG,GACpCH,cAAeb,EAAOI,MAAM,IAEhC,CACA,gBAAOa,CAAUjB,GACf,GAAIA,EAAOJ,KAAOY,EAAWU,SAC3B,MAAMC,UAAU,oBAElB,IAAIC,EAASZ,EAAWM,MAAMd,GAC1BqB,EAAgBC,EAAeF,EAAOV,MAC1C,QAA6B,IAAlBW,EACT,MAAMF,UAAU,uBAElB,GAAIC,EAAOP,cAAcjB,KAAOyB,EAAczB,KAC5C,MAAMuB,UAAU,qBAGlB,OADAC,EAAOR,QAAUS,EAAcP,MAAMM,EAAOP,eACrCO,CACT,CACA,SAAAG,GACE,IAAIvB,EAAS,IAAIb,EAAW,GAI5B,OAHAa,EAAOF,KAAK0B,SAAS,EAAGjC,KAAKmB,MAC7BV,EAAOF,KAAK2B,UAAU,EAAGlC,KAAKoB,WAAW,GACzCX,EAASA,EAAOC,OAAOV,KAAKqB,QAAQW,aAC7BvB,CACT,EAGK,MAAM0B,EACXjB,gBAAkB,EAClBA,YAAc,EACdA,YAAc,UACd,WAAArB,EAAY,YAACuC,EAAW,KAAEC,EAAI,SAAEC,IAC9BtC,KAAKoC,YAAcA,EACnBpC,KAAKqC,KAAOA,EACZrC,KAAKsC,SAAWA,CAClB,CACA,YAAOf,CAAMd,GACX,OAAO,IAAI0B,EAAe,CACxBC,YAAa3B,EAAOF,KAAKiB,SAAS,GAClCa,KAAM5B,EAAOF,KAAKgC,UAAU,GAAG,GAC/BD,SAAU5C,EAAYe,EAAOI,MAAM,GAAGT,QAE1C,CACA,SAAA4B,GACE,IAAIvB,EAAS,IAAIb,EAAW,GAI5B,OAHAa,EAAOF,KAAK0B,SAAS,EAAGjC,KAAKoC,aAC7B3B,EAAOF,KAAKiC,UAAU,EAAGxC,KAAKqC,MAAM,GACpC5B,EAASA,EAAOC,OAAO,IAAId,EAAWI,KAAKsC,WACpC7B,CACT,EAGK,MAAMgC,EACXvB,gBAAkB,EAClBA,YAAc,EACdA,YAAc,OACd,WAAArB,EAAY,KAACC,IACXE,KAAKF,KAAOA,CACd,CACA,YAAOyB,CAAMd,GACX,OAAO,IAAIgC,EAAY,CACrB3C,KAAMW,GAEV,CACA,SAAAuB,GACE,OAAOhC,KAAKF,IACd,EAGK,MAAM4C,EACXxB,YAAc,EACdA,YAAc,WACd,WAAArB,EAAY,iBAAC8C,IACX3C,KAAK2C,iBAAmBA,CAC1B,CACA,YAAOpB,CAAMd,GACX,OAAO,IAAIiC,EAAgB,CACzBC,iBAAkBlC,EAAOF,KAAKkB,UAAU,GAAG,IAE/C,CACA,SAAAO,GACE,IAAIvB,EAAS,IAAIb,EAAW,GAE5B,OADAa,EAAOF,KAAK2B,UAAU,EAAGlC,KAAK2C,kBAAkB,GACzClC,CACT,EAGK,MAAMmC,EACX1B,gBAAkB,EAClBA,YAAc,EACdA,YAAc,QACd,WAAArB,EAAY,OAACgD,IACX7C,KAAK6C,OAASA,CAChB,CACA,YAAOtB,CAAMd,GACX,OAAO,IAAImC,EAAa,CACtBC,OAAQpC,EAAOF,KAAKiB,SAAS,IAEjC,CACA,SAAAQ,GACE,IAAIvB,EAAS,IAAIb,EAAW,GAE5B,OADAa,EAAOF,KAAK0B,SAAS,EAAGjC,KAAK6C,QACtBpC,CACT,EAGK,MAAMqC,EACX5B,gBAAkB,EAClBA,YAAc,EACdA,YAAc,OACd,WAAArB,EAAY,UAACkD,EAAS,UAAEC,EAAS,WAAEC,IACjCjD,KAAK+C,UAAYA,EACjB/C,KAAKgD,UAAYA,EACjBhD,KAAKiD,WAAaA,CACpB,CACA,YAAO1B,CAAMd,GACX,OAAO,IAAIqC,EAAY,CACrBC,UAAWtC,EAAOF,KAAKiB,SAAS,GAChCwB,UAAWvC,EAAOF,KAAKiB,SAAS,GAChCyB,WAAYxC,EAAOI,MAAM,IAE7B,CACA,SAAAmB,GACE,IAAIvB,EAAS,IAAIb,EAAW,GAG5B,OAFAa,EAAOF,KAAK0B,SAAS,EAAGjC,KAAK+C,WAC7BtC,EAAOF,KAAK0B,SAAS,EAAGjC,KAAKgD,WACtBvC,EAAOC,OAAOV,KAAKiD,WAC5B,EAGK,MAAMlB,EAAiB,CAC5B,EAAMI,EACN,EAAMM,EACN,EAAMC,EACN,EAAME,EACN,EAAME,GAGKI,EAAe,CAC1BC,QAAS,EACTC,KAAM,EACNC,SAAU,EACVC,MAAO,EACPC,KAAM,GAGKC,EAAe,CAC1BC,IAAK,EACLC,IAAK,GAGMC,EAAgB,CAE3BC,QAAS,EACTC,UAAW,EACXC,aAAc,EACdC,uBAAwB,EAGxBC,YAAa,GACbC,gBAAiB,GACjBC,WAAY,GACZC,YAAa,GACbC,gBAAiB,GACjBC,YAAa,GACbC,cAAe,GAGfC,YAAa,IAGbC,gBAAiB,IACjBC,iBAAkB,IAClBC,uBAAwB,KCtO1B,MAAMC,EACJ,WAAA9E,GAAe,CACf,YAAO0B,GACL,OAAO,IAAIoD,CACb,CACA,SAAA3C,GACE,OAAO,IAAIpC,EAAW,EACxB,EAGK,MAAMgF,EACX1D,UAAY,EACZA,YAAc,GAEdA,cAAgByD,EAChBzD,cAAgByD,EAEhB,WAAA9E,EAAY,cAACgF,EAAa,cAAEC,GAAiB,CAAC,GAC5C9E,KAAK+E,GAAK/E,KAAKH,YAAYkF,GAC3B/E,KAAKgF,KAAOhF,KAAKH,YAAYmF,KACzBH,EACF7E,KAAKqB,QAAU,IAAIrB,KAAKH,YAAYoF,OAAOJ,GACpCC,IACP9E,KAAKqB,QAAU,IAAIrB,KAAKH,YAAYqF,OAAOJ,GAC/C,CACA,YAAOvD,CAAM4D,EAAW1E,EAAQ2E,GAC9B,IAAIC,EAAY,IAAIF,EAAU,CAAC,GAC/B,GAAa,WAATC,EACFC,EAAUhE,QAAU8D,EAAUD,OAAO3D,MAAMd,EAAOI,MAAM,QACrD,IAAa,WAATuE,EAGP,MAAMxD,UAAU,gBAFhByD,EAAUhE,QAAU8D,EAAUF,OAAO1D,MAAMd,EAAOI,MAAM,GAEzB,CACjC,OAAOwE,CACT,CACA,SAAArD,GACE,IAAIvB,EAAS,IAAIb,EAAW,GACxB0F,EAAiBtF,KAAKqB,QAAQW,YAGlC,OAFAvB,EAAOF,KAAKgF,QAAQ,EAAGvF,KAAKH,YAAYkF,IACxCtE,EAAOF,KAAK2B,UAAU,EAAGoD,EAAejF,MAAM,GACvCI,EAAOC,OAAO4E,EACvB,EAGK,MAAME,UAAqBZ,EAChC1D,UAAY,EACZA,YAAc,MAGT,MAAMuE,UAA8Bb,EACzC1D,UAAY,EACZA,YAAc,0BAEdA,cAAgB,MACd,WAAArB,EAAY,SAAC6F,EAAW,IACtB1F,KAAK0F,SAAWA,EAAW,EAAI,CACjC,CACA,YAAOnE,CAAMd,GACX,OAAO,IAAIgF,EAAsBR,OAAO,CACtCS,SAAUjF,EAAOF,KAAKiB,SAAS,IAEnC,CACA,SAAAQ,GACE,IAAIvB,EAAS,IAAIb,EAAW,GAE5B,OADAa,EAAOF,KAAK0B,SAAS,EAAGjC,KAAK0F,UACtBjF,CACT,GAGFS,cAAgB,MACd,WAAArB,EAAY,SAAC8F,EAAQ,SAAEC,IACrB5F,KAAK2F,SAAWA,EAChB3F,KAAK4F,SAAWA,CAClB,CACA,YAAOrE,CAAMd,GACX,IAAIoF,EAAepF,EAAOF,KAAKiB,SAAS,GACpCsE,EAAerF,EAAOF,KAAKgC,UAAU,GAAG,GACxCwD,EAAiBF,EAAe,EACpC,OAAO,IAAIJ,EAAsBP,OAAO,CACtCS,SAAUlF,EAAOI,MAAM,EAAGgF,GAAc7E,aACxC4E,SAAUnF,EAAOI,MAAMkF,EAAgBD,GAAc9E,cAEzD,CACA,SAAAgB,GACE,IAAIgE,EAAkB,IAAIpG,EAAWI,KAAK2F,UACtCM,EAAkB,IAAIrG,EAAWI,KAAK4F,UACtCnF,EAAS,IAAIb,EAAW,GAG5B,OAFAa,EAAOF,KAAK0B,SAAS,EAAG+D,EAAgB3F,MACxCI,EAAOF,KAAKiC,UAAU,EAAGyD,EAAgB5F,MAAM,GACxCI,EAAOC,OAAOsF,GAAiBtF,OAAOuF,EAC/C,GAIG,MAAMC,UAAsBtB,EACjC1D,UAAY,EACZA,YAAc,cAEdA,cAAgB,MACd,WAAArB,EAAY,QAACsG,IACXnG,KAAKmG,QAAUA,CACjB,CACA,YAAO5E,CAAMd,GACX,OAAO,IAAIyF,EAAcjB,OAAO,CAC9BkB,QAAS1F,EAAOO,cAEpB,CACA,SAAAgB,GACE,OAAO,IAAIpC,EAAWI,KAAKmG,QAC7B,GAGFjF,cAAgByD,EAGX,SAASyB,EAAiBd,EAAgBe,EAAkBjB,GACjE,IACIkB,EAAoB,GACxB,KAAOhB,EAAejF,MAAM,CAC1B,IAGI8E,EAHAoB,EAASjB,EAAe/E,KAAKiB,SAHvB,GAINgF,EAAUlB,EAAe/E,KAAKkB,UAAUX,GAAW,GACnD2F,EAAcnB,EAAezE,MAAM,EAAG,EAAI2F,GAE9C,IAAK,IAAInB,KAAagB,EACpB,GAAIhB,EAAUN,KAAOwB,EAArB,CAEApB,EAAYE,EAAUxF,YACtB,KAFU,CAIZ,GAAIsF,EAAW,CACb,IAAIuB,EAAa9B,EAAcrD,MAAM4D,EAAWsB,EAAarB,GAC7DkB,EAAkBK,KAAKD,EACzB,CACApB,EAAiBA,EAAezE,MAAM,EAAI2F,EAC5C,CACA,OAAOF,CACT,CAEO,SAASM,EAAqB3D,GAAa,CAChD,IAAI4D,EAAa,IAAIjH,EAAW,GAChC,IAAK,IAAIyF,KAAapC,EACpB4D,EAAaA,EAAWnG,OAAO2E,EAAUrD,aAE3C,OAAO6E,CACT,CAAC,CAEM,MAAMC,EAAiB,CAC5B,EAAMtB,EACN,EAAMC,EACN,EAAMS,GCvIR,MAAMa,EACJ,WAAAlH,CAAYyC,EAAUD,EAAM2E,EAAWC,EAAa7F,EAAW8F,EAAY9E,GACzEpC,KAAKsC,SAAWA,EAChBtC,KAAKqC,KAAOA,EACZrC,KAAKmH,GAAKH,EACVhH,KAAKiH,YAAcA,EACnBjH,KAAKoB,UAAYA,EACjBpB,KAAKkH,WAAaA,EAClBlH,KAAKoC,YAAcA,EACnBpC,KAAKoH,YAAc,GACnBpH,KAAKqH,MAAO,EAEZrH,KAAKsH,OAAS,OACdtH,KAAKuH,QAAU,OACfvH,KAAKwH,UAAY,MACnB,CAEA,IAAAC,CAAK3H,GAEH,GAAIE,KAAKiH,YAAc,IAAMjH,KAAKqH,MAAQrH,KAAKoC,cAAgBoB,EAAaE,IAAK,CAE/E,IAAI7B,EAAS,IAAIZ,EAAW,CAC1BE,KAAM+B,EAAaE,KACnBhC,UAAWpB,KAAKoB,UAChBC,QAAS,IAAIoB,EAAY,CACvB3C,KAAM,IAAIF,EAAWE,OAGzBE,KAAKmH,GAAGM,KAAK5F,EAAOG,YAAY5B,OAChCJ,KAAKiH,aACP,MAEEjH,KAAKoH,YAAYT,KAAK7G,EAE1B,CAGA,iBAAA4H,CAAkBT,GAGhB,IAFAjH,KAAKiH,YAAcA,EAEZjH,KAAKiH,YAAc,GAAKjH,KAAKoH,YAAY9G,OAAS,GACvDN,KAAKyH,KAAKzH,KAAKoH,YAAYO,QAE/B,CAGA,KAAAC,CAAM/E,EAAS,GACb,IAAK7C,KAAKqH,KAAM,OAChB,IAAIxF,EAAS,IAAIZ,EAAW,CAC1BE,KAAM+B,EAAaI,MACnBlC,UAAWpB,KAAKoB,UAChBC,QAAS,IAAIuB,EAAa,CACxBC,OAAQA,MAGZ7C,KAAKmH,GAAGM,KAAK5F,EAAOG,YAAY5B,OAChCJ,KAAKqH,MAAO,SACLrH,KAAKkH,WAAWW,eAAe7H,KAAKoB,UAC7C,EAGK,MAAM0G,EACX,WAAAjI,CAAYkI,GAAU,aAACC,EAAY,gBAAEC,GAAmB,CAAC,GACvD,IAAKF,EAASG,SAAS,KACrB,MAAM,IAAItG,UAAU,yDAGtB5B,KAAK+H,SAAWA,EAChB/H,KAAKgI,aAAeA,GAAgB,EACpChI,KAAKiI,gBAAkBA,GAAmB,KAE1CjI,KAAKmI,gBAAkB,KACvBnI,KAAK6H,eAAiB,CAAC,EACvB7H,KAAKoI,WAAY,EACjBpI,KAAKqI,YAAa,EAClBrI,KAAKsI,eAAiB,EAEtBtI,KAAKuI,YAAc,CAAC,EACpBvI,KAAKwI,YAAc,CAAC,EACpBxI,KAAKyI,eAAgB,EACrBzI,KAAK0I,YAAc,KACnB1I,KAAK2I,aAAc,EAEnB3I,KAAKsH,OAAS,OACdtH,KAAKuH,QAAU,OACfvH,KAAK4I,QAAU,OACf5I,KAAKwH,UAAY,OAES,IAAtBxH,KAAKgI,cAA+C,OAAzBhI,KAAKiI,iBAClCjI,KAAK6I,iBAGP7I,KAAK8I,YACP,CAEA,cAAAD,GACE7I,KAAKiI,gBAAkB,GACvBjI,KAAKiI,gBAAgBtB,KAAK,IAAInB,EAAa,CAACV,cAAe,CAAC,KAC5D9E,KAAKiI,gBAAgBtB,KAAK,IAAIT,EAAc,CAACpB,cAAe,CAAC,IAC/D,CAEA,UAAAgE,GACE,IAAIC,EAAoC,IAAtB/I,KAAKgI,aAAqB,eAAYgB,EACxDhJ,KAAKmH,GAAK,IAAI,EAAiBnH,KAAK+H,SAAUgB,GAC9C/I,KAAKmH,GAAG8B,WAAa,cACrBjJ,KAAKqI,YAAa,EAElBrI,KAAKmH,GAAGyB,QAAU,KAChB,GAA0B,IAAtB5I,KAAKgI,aAKP,OAJAhI,KAAKmH,GAAGI,QAAU,KAClBvH,KAAKkJ,UACLlJ,KAAKgI,aAAe,OACpBhI,KAAK8I,aAGP9I,KAAKkJ,UACLlJ,KAAK4I,WAEP5I,KAAKmH,GAAGI,QAAU,KAChBvH,KAAKkJ,UACLlJ,KAAKuH,WAEPvH,KAAKmH,GAAGK,UAAa2B,IACnBnJ,KAAKoJ,UAAUD,GACXnJ,KAAKoI,WAAapI,KAAKqI,aACzBrI,KAAKqI,YAAa,EAClBrI,KAAKsH,UAGX,CAEA,KAAAM,GACE5H,KAAKmH,GAAGS,OACV,CAEA,aAAAyB,CAAc/G,EAAUD,EAAMlB,EAAK,GACjC,IAAIiB,EAAcjB,EAIlB,GAH2B,iBAAhBiB,IACTA,EAAuB,QAATjB,EAAiBqC,EAAaE,IAAMF,EAAaC,KAE7DrB,GAAeoB,EAAaE,MAAQ1D,KAAK2I,YAC3C,MAAM,IAAIW,MAAM,+CAGlB,IAAIlI,EAAYpB,KAAKsI,iBACjBiB,EAAS,IAAIxC,EAAazE,EAAUD,EAAMrC,KAAKmH,GAAInH,KAAKmI,gBAAiB/G,EAAWpB,KAAMoC,GAC9FpC,KAAK6H,eAAezG,GAAamI,EACjCA,EAAOlC,KAAOrH,KAAKoI,UAGnB,IAAIvG,EAAS,IAAIZ,EAAW,CAC1BE,KAAM+B,EAAaC,QACnB/B,UAAWA,EACXC,QAAS,IAAIc,EAAe,CAC1BC,YAAaA,EACbC,KAAMA,EACNC,SAAUA,MAId,OADAtC,KAAKmH,GAAGM,KAAK5F,EAAOG,YAAY5B,OACzBmJ,CACT,CAEA,YAAAC,CAAaD,EAAQ1G,GACnB0G,EAAOhC,QAAQ1E,UACR7C,KAAK6H,eAAe0B,EAAOnI,UACpC,CAEA,SAAAgI,CAAUD,GACR,IAAI1I,EAAS,IAAIb,EAAW,IAAIG,WAAWoJ,EAAMrJ,OACjD,GAAIW,EAAOJ,KAAOY,EAAWU,SAE3B,YADAzB,QAAQuJ,KAAK,6DAGf,IAAI5H,EAASZ,EAAWS,UAAUjB,GAC9B8I,EAASvJ,KAAK6H,eAAehG,EAAOT,WACxC,GAAyB,IAArBS,EAAOT,WAAmBpB,KAAKqI,YASjC,GARIxG,EAAOV,OAAS+B,EAAaG,WAC/BrD,KAAKmI,gBAAkBtG,EAAOR,QAAQsB,iBACtC3C,KAAKoI,WAAY,EACZpI,KAAKyI,gBACRzI,KAAKgI,aAAe,IAIpBnG,EAAOV,OAAS+B,EAAaK,MAA8B,IAAtBvD,KAAKgI,aAAoB,CAChE,IAAI0B,EAAoBtD,EAAiBvE,EAAOR,QAAQ4B,WAAYjD,KAAKiI,gBAAiB,UAC1F,IAAK,IAAI0B,KAAcD,EACrB,IAAK,IAAIE,KAAc5J,KAAKiI,gBACtB0B,EAAW5E,KAAO6E,EAAW7E,KAC/B/E,KAAKuI,YAAYoB,EAAW5E,IAAM4E,EAClC3J,KAAKwI,YAAYoB,EAAW7E,IAAM6E,GAKxC5J,KAAKyI,eAAgB,EACrBzI,KAAK0I,YAAc1I,KAAKuI,YAAYrC,EAAcnB,KAAK1D,SAAS8E,QAChEnG,KAAK2I,cAAgB3I,KAAKuI,YAAY/C,EAAaT,IAEnD,IAAI8B,EAAaD,EAAqB5G,KAAKiI,iBACvC4B,EAAc,IAAI5I,EAAW,CAC/BE,KAAM2B,EAAY3B,KAClBC,UAAW,EACXC,QAAS,IAAIyB,EAAY,CACvBC,UAAW/C,KAAKgI,aAChBhF,UAAW,EACXC,WAAY4D,MAGhB7G,KAAKmH,GAAGM,KAAKoC,EAAY7H,YAAY5B,MACvC,YAIoB,IAAXmJ,EAKP1H,EAAOV,OAAS+B,EAAaE,KAC/BmG,EAAO/B,UAAU3F,EAAOP,cAAclB,OAG/ByB,EAAOV,OAAS+B,EAAaG,SACpCkG,EAAO7B,kBAAkB7F,EAAOR,QAAQsB,kBAGjCd,EAAOV,OAAS+B,EAAaI,MACpCtD,KAAKwJ,aAAaD,EAAQ1H,EAAOR,QAAQwB,QAIzC3C,QAAQuJ,KAAK,2DAA2D5H,EAAOV,QAjB/EjB,QAAQuJ,KAAK,mCAAmC1H,EAAeF,EAAOV,MAAM6D,+CAmBhF,CAEA,OAAAkE,GACElJ,KAAKoI,WAAY,EACjBpI,KAAKqI,YAAa,EAClB,IAAK,IAAIjH,KAAalD,OAAO4L,KAAK9J,KAAK6H,gBACrC7H,KAAKwJ,aAAaxJ,KAAK6H,eAAezG,GAAY,EAEtD,EC9PF,MAAM2I,EAAkBjL,EAAYkL,YAAcC,MACrCC,EAAoB,CAAC,EAE3B,MAAMC,UAAsBC,YACjC,WAAAvK,CAAYwK,EAAKC,EAAU,KAAMC,EAAU,CAAC,GAC1CC,QACAxK,KAAKqK,IAAMA,EACXrK,KAAKsK,UAAYA,EACjBtK,KAAKuK,QAAUA,EACfvK,KAAKiJ,WAAa,OAClBjJ,KAAKuJ,OAAS,KACdvJ,KAAKkH,WAAa,KAGlBlH,KAAKsH,OAAS,OACdtH,KAAK4I,QAAU,OACf5I,KAAKwH,UAAY,OACjBxH,KAAKuH,QAAU,OAEfvH,KAAKyK,WAAa,EAClBzK,KAAK0K,KAAO,EACZ1K,KAAK2K,QAAU,EACf3K,KAAK4K,OAAS,EACd5K,KAAK6K,aAAe7K,KAAKyK,WAGzB,IAAIK,EAAY9K,KAAKqK,IAAIU,MAAM,KAC3BC,EAAeF,EAAUG,MAAMF,MAAM,KACzC/K,KAAKkL,KAAOF,EAAa,GACzBhL,KAAKqC,KAAO8I,SAASH,EAAa,IAClChL,KAAKoL,SAAWN,EAAUO,KAAK,KAAO,IAEtCrL,KAAKsL,iBACP,CAEA,aAAAC,GACEvL,KAAK6K,aAAe7K,KAAK4K,OACrBV,EAAkBlK,KAAKoL,YACzBpL,KAAK4I,QAAQ,IAAIqB,MAAM,UACvBjK,KAAKwL,cAAc,IAAIvB,MAAM,kBAExBC,EAAkBlK,KAAKoL,SAChC,CAEA,eAAAE,GAIE,GAFAtL,KAAKkH,WAAagD,EAAkBlK,KAAKoL,UAEpCpL,KAAKkH,WAaL,GAAKlH,KAAKkH,WAAWkB,UAQxBpI,KAAKkH,WAAagD,EAAkBlK,KAAKoL,UACzCpL,KAAKyL,kBAT8B,CACnC,IAAIC,EAAa1L,KAAKkH,WAAWI,OACjCtH,KAAKkH,WAAWI,OAAS,KACvBoE,IACA1L,KAAKyL,cAET,MAlBEzL,KAAKkH,WAAa,IAAIY,EAAiB9H,KAAKoL,SAAUpL,KAAKuK,SAC3DvK,KAAKkH,WAAWI,OAAS,KACvBtH,KAAKyL,eAEPzL,KAAKkH,WAAWK,QAAU,KACxBvH,KAAKuL,iBAEPvL,KAAKkH,WAAW0B,QAAU,KACxB5I,KAAKuL,iBAEPrB,EAAkBlK,KAAKoL,UAAYpL,KAAKkH,UAa5C,CAEA,WAAAuE,GACEzL,KAAK6K,aAAe7K,KAAK0K,KACzB1K,KAAKuJ,OAASvJ,KAAKkH,WAAWmC,cAAcrJ,KAAKkL,KAAMlL,KAAKqC,MAE5DrC,KAAKuJ,OAAO/B,UAAamE,IACvB,IAAI7L,EACJ,GAAuB,QAAnBE,KAAKiJ,WACPnJ,EAAO,IAAI8L,KAAKD,OAEb,IAAuB,eAAnB3L,KAAKiJ,WAIZ,KAAM,4BAHNnJ,EAAO6L,EAASlL,MAIlB,CACA,IAAIoL,EAAY,IAAIC,aAAa,UAAW,CAAChM,KAAMA,IACnDE,KAAKwH,UAAUqE,GACf7L,KAAKwL,cAAcK,IAGrB7L,KAAKuJ,OAAOhC,QAAW1E,IACrB7C,KAAK6K,aAAe7K,KAAK4K,OACzB,IAAImB,EAAc,IAAIhC,EAAe,QAAS,CAACiC,KAAMnJ,IACrD7C,KAAKuH,QAAQwE,GACb/L,KAAKwL,cAAcO,IAGrB,IAAIE,EAAa,IAAIhC,MAAM,QAC3BjK,KAAKsH,OAAO2E,GACZjM,KAAKwL,cAAcS,EACrB,CAEA,IAAAxE,CAAK3H,GACH,IAAIoM,EAEJ,GAAIpM,aAAgBC,WAClBmM,EAAapM,OAEV,GAAoB,iBAATA,EACdoM,GAAa,IAAI9M,aAAcE,OAAOQ,OAEnC,IAAIA,aAAgB8L,KAIvB,YAHA9L,EAAKqM,cAAcC,KAAKC,IACtBrM,KAAKyH,KAAK4E,KAIT,GAAIvM,aAAgBwM,YACvBJ,EAAa,IAAInM,WAAWD,OAGzB,KAAIwM,YAAYC,OAAOzM,GAI1B,KAAM,+BAHNoM,EAAa,IAAInM,WAAWD,EAAKW,OAInC,EAEA,IAAKT,KAAKuJ,OACR,KAAM,yBAERvJ,KAAKuJ,OAAO9B,KAAKyE,EACnB,CAEA,KAAAtE,GACE5H,KAAKuJ,OAAO3B,MAAM,EACpB,CAEA,kBAAI4E,GACF,IAAIC,EAAQ,EACZ,IAAK,IAAIC,KAAO1M,KAAKuJ,OAAOnC,YAC1BqF,GAASC,EAAIpM,OAEf,OAAOmM,CACT,CAEA,cAAIxJ,GACF,MAAO,EACT,CAEA,YAAI0J,GACF,MAAO,QACT,CAEA,cAAIC,GACF,OAAO5M,KAAK6K,YACd,S","sources":["webpack://@mercuryworkshop/wisp-js/webpack/bootstrap","webpack://@mercuryworkshop/wisp-js/webpack/runtime/define property getters","webpack://@mercuryworkshop/wisp-js/webpack/runtime/hasOwnProperty shorthand","webpack://@mercuryworkshop/wisp-js/webpack/runtime/make namespace object","webpack://@mercuryworkshop/wisp-js/./src/compat_browser.mjs","webpack://@mercuryworkshop/wisp-js/./src/packet.mjs","webpack://@mercuryworkshop/wisp-js/./src/extensions.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/connection.mjs","webpack://@mercuryworkshop/wisp-js/./src/client/polyfill.mjs"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","//the node modules referenced by other parts of the code do not exist on the web\n//some of them can be replaced by the standard browser apis, others have to be ignored\n\n//compatibility for old browsers where globalThis doesn't exist\nexport const global_this = typeof globalThis === \"undefined\" ? window : globalThis;\n\nexport const WebSocket = global_this.WebSocket;\nexport const crypto = global_this.crypto;\nexport const WebSocketServer = null;\nexport const net = null;\nexport const dgram = null;\nexport const dns = null;\nexport const http = null;","//shared packet parsing / serialization code\n\nconst text_encoder = new TextEncoder();\nconst encode_text = text_encoder.encode.bind(text_encoder);\nconst text_decoder = new TextDecoder();\nconst decode_text = text_decoder.decode.bind(text_decoder);\n\nexport class WispBuffer {\n  constructor(data) {\n    if (data instanceof Uint8Array) {\n      this.from_array(data);\n    }\n    else if (typeof data === \"number\") {\n      this.from_array(new Uint8Array(data));\n    }\n    else if (typeof data === \"string\") {\n      this.from_array(encode_text(data));\n    }\n    else {\n      console.trace();\n      throw \"invalid data type passed to wisp buffer constructor\";\n    }\n  }\n\n  from_array(bytes) {\n    this.size = bytes.length;\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer); \n  }\n\n  concat(buffer) {\n    let new_buffer = new WispBuffer(this.size + buffer.size);\n    new_buffer.bytes.set(this.bytes, 0);\n    new_buffer.bytes.set(buffer.bytes, this.size);\n    return new_buffer;\n  }\n\n  slice(index, size) {\n    let bytes_slice = this.bytes.slice(index, size);\n    return new WispBuffer(bytes_slice);\n  }\n\n  get_string() {\n    return text_decoder.decode(this.bytes);\n  }\n}\n\nexport class WispPacket {\n  static min_size = 5;\n  constructor({type, stream_id, payload, payload_bytes }) {\n    this.type = type;\n    this.stream_id = stream_id;\n    this.payload_bytes = payload_bytes;\n    this.payload = payload;\n  }\n  static parse(buffer) {\n    return new WispPacket({\n      type: buffer.view.getUint8(0),\n      stream_id: buffer.view.getUint32(1, true),\n      payload_bytes: buffer.slice(5)\n    });\n  }\n  static parse_all(buffer) {\n    if (buffer.size < WispPacket.min_size) {\n      throw TypeError(\"packet too small\");\n    }\n    let packet = WispPacket.parse(buffer);\n    let payload_class = packet_classes[packet.type];\n    if (typeof payload_class === \"undefined\") {\n      throw TypeError(\"invalid packet type\");\n    }\n    if (packet.payload_bytes.size < payload_class.size) {\n      throw TypeError(\"payload too small\");\n    }\n    packet.payload = payload_class.parse(packet.payload_bytes);\n    return packet;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    buffer.view.setUint8(0, this.type);\n    buffer.view.setUint32(1, this.stream_id, true);\n    buffer = buffer.concat(this.payload.serialize());\n    return buffer;\n  }\n}\n\nexport class ConnectPayload {\n  static min_size = 3;\n  static type = 0x01;\n  static name = \"CONNECT\";\n  constructor({stream_type, port, hostname}) {\n    this.stream_type = stream_type;\n    this.port = port;\n    this.hostname = hostname;\n  }\n  static parse(buffer) {\n    return new ConnectPayload({\n      stream_type: buffer.view.getUint8(0),\n      port: buffer.view.getUint16(1, true),\n      hostname: decode_text(buffer.slice(3).bytes)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(3);\n    buffer.view.setUint8(0, this.stream_type);\n    buffer.view.setUint16(1, this.port, true);\n    buffer = buffer.concat(new WispBuffer(this.hostname));\n    return buffer;\n  }\n}\n\nexport class DataPayload {\n  static min_size = 0;\n  static type = 0x02;\n  static name = \"DATA\";\n  constructor({data}) {\n    this.data = data;\n  }\n  static parse(buffer) {\n    return new DataPayload({\n      data: buffer\n    });\n  }\n  serialize() {\n    return this.data;\n  }\n}\n\nexport class ContinuePayload {\n  static type = 0x03;\n  static name = \"CONTINUE\";\n  constructor({buffer_remaining}) {\n    this.buffer_remaining = buffer_remaining;\n  }\n  static parse(buffer) {\n    return new ContinuePayload({\n      buffer_remaining: buffer.view.getUint32(0, true),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(4);\n    buffer.view.setUint32(0, this.buffer_remaining, true);\n    return buffer;\n  }\n}\n\nexport class ClosePayload {\n  static min_size = 1;\n  static type = 0x04;\n  static name = \"CLOSE\";\n  constructor({reason}) {\n    this.reason = reason;\n  }\n  static parse(buffer) {\n    return new ClosePayload({\n      reason: buffer.view.getUint8(0),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(1);\n    buffer.view.setUint8(0, this.reason);\n    return buffer;\n  }\n}\n\nexport class InfoPayload {\n  static min_size = 2;\n  static type = 0x05;\n  static name = \"INFO\";\n  constructor({major_ver, minor_ver, extensions}) {\n    this.major_ver = major_ver;\n    this.minor_ver = minor_ver;\n    this.extensions = extensions;\n  }\n  static parse(buffer) {\n    return new InfoPayload({\n      major_ver: buffer.view.getUint8(0),\n      minor_ver: buffer.view.getUint8(1),\n      extensions: buffer.slice(2)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(2);\n    buffer.view.setUint8(0, this.major_ver);\n    buffer.view.setUint8(1, this.minor_ver);\n    return buffer.concat(this.extensions);\n  }\n}\n\nexport const packet_classes = {\n  0x01: ConnectPayload, \n  0x02: DataPayload, \n  0x03: ContinuePayload, \n  0x04: ClosePayload,\n  0x05: InfoPayload\n}\n\nexport const packet_types = {\n  CONNECT: 0x01,\n  DATA: 0x02,\n  CONTINUE: 0x03,\n  CLOSE: 0x04,\n  INFO: 0x05\n}\n\nexport const stream_types = {\n  TCP: 0x01,\n  UDP: 0x02\n}\n\nexport const close_reasons = {\n  //client/server close reasons\n  Unknown: 0x01,\n  Voluntary: 0x02,\n  NetworkError: 0x03,\n  IncompatibleExtensions: 0x04,\n\n  //server only close reasons\n  InvalidInfo: 0x41, \n  UnreachableHost: 0x42,\n  NoResponse: 0x43,\n  ConnRefused: 0x44,\n  TransferTimeout: 0x47,\n  HostBlocked: 0x48,\n  ConnThrottled: 0x49,\n\n  //client only close reasons\n  ClientError: 0x81,\n\n  //extension specific close reasons\n  AuthBadPassword: 0xc0,\n  AuthBadSignature: 0xc1,\n  AuthMissingCredentials: 0xc2\n}","import { WispBuffer } from \"./packet.mjs\";\n\nclass EmptyPayload {\n  constructor() {}\n  static parse() {\n    return new EmptyPayload();\n  }\n  serialize() {\n    return new WispBuffer(0);\n  }\n}\n\nexport class BaseExtension {\n  static id = 0x00;\n  static name = \"\";\n\n  static Server = EmptyPayload;\n  static Client = EmptyPayload;\n\n  constructor({server_config, client_config} = {}) {\n    this.id = this.constructor.id;\n    this.name = this.constructor.name;\n    if (server_config)\n      this.payload = new this.constructor.Server(server_config);\n    else if (client_config)\n      this.payload = new this.constructor.Client(client_config);\n  }\n  static parse(ext_class, buffer, role) {\n    let extension = new ext_class({});\n    if (role === \"client\")\n      extension.payload = ext_class.Client.parse(buffer.slice(5));\n    else if (role === \"server\")\n      extension.payload = ext_class.Server.parse(buffer.slice(5));\n    else \n      throw TypeError(\"invalid role\");\n    return extension;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    let payload_buffer = this.payload.serialize();\n    buffer.view.setInt8(0, this.constructor.id);\n    buffer.view.setUint32(1, payload_buffer.size, true);\n    return buffer.concat(payload_buffer);\n  }\n}\n\nexport class UDPExtension extends BaseExtension {\n  static id = 0x01;\n  static name = \"UDP\";\n}\n\nexport class PasswordAuthExtension extends BaseExtension {\n  static id = 0x02;\n  static name = \"Password Authentication\";\n\n  static Server = class {\n    constructor({required = 1}) {\n      this.required = required ? 1 : 0;\n    }\n    static parse(buffer) {\n      return new PasswordAuthExtension.Server({\n        required: buffer.view.getUint8(0)\n      });\n    }\n    serialize() {\n      let buffer = new WispBuffer(1);\n      buffer.view.setUint8(0, this.required);\n      return buffer;\n    }\n  }\n\n  static Client = class {\n    constructor({username, password}) {\n      this.username = username;\n      this.password = password;\n    }\n    static parse(buffer) {\n      let username_len = buffer.view.getUint8(0);\n      let password_len = buffer.view.getUint16(1, true);\n      let password_index = username_len + 3;\n      return new PasswordAuthExtension.Client({\n        username: buffer.slice(3, username_len).get_string(),\n        password: buffer.slice(password_index, password_len).get_string()\n      });\n    }\n    serialize() {\n      let username_buffer = new WispBuffer(this.username);\n      let password_buffer = new WispBuffer(this.password);\n      let buffer = new WispBuffer(3);\n      buffer.view.setUint8(0, username_buffer.size);\n      buffer.view.setUint16(1, password_buffer.size, true);\n      return buffer.concat(username_buffer).concat(password_buffer);\n    }\n  }\n}\n\nexport class MOTDExtension extends BaseExtension {\n  static id = 0x04;\n  static name = \"Server MOTD\";\n\n  static Server = class {\n    constructor({message}) {\n      this.message = message;\n    }\n    static parse(buffer) {\n      return new MOTDExtension.Server({\n        message: buffer.get_string()\n      });\n    }\n    serialize() {\n      return new WispBuffer(this.message);\n    }\n  }\n\n  static Client = EmptyPayload;\n}\n\nexport function parse_extensions(payload_buffer, valid_extensions, role) {\n  let index = 0;\n  let parsed_extensions = [];\n  while (payload_buffer.size) {\n    let ext_id = payload_buffer.view.getUint8(index);\n    let ext_len = payload_buffer.view.getUint32(index + 1, true);\n    let ext_payload = payload_buffer.slice(0, 5 + ext_len);\n    let ext_class;\n    for (let extension of valid_extensions) {\n      if (extension.id !== ext_id) \n        continue;\n      ext_class = extension.constructor;\n      break;\n    }\n    if (ext_class) {\n      let ext_parsed = BaseExtension.parse(ext_class, ext_payload, role);\n      parsed_extensions.push(ext_parsed);\n    }\n    payload_buffer = payload_buffer.slice(5 + ext_len);\n  }\n  return parsed_extensions;\n}\n\nexport function serialize_extensions(extensions) {{\n  let ext_buffer = new WispBuffer(0);\n  for (let extension of extensions) {\n    ext_buffer = ext_buffer.concat(extension.serialize());\n  }\n  return ext_buffer;\n}}\n\nexport const extensions_map = {\n  0x01: UDPExtension,\n  0x02: PasswordAuthExtension,\n  0x04: MOTDExtension\n}","import * as compat from \"../compat.mjs\";\n\nimport {\n  packet_classes,\n  packet_types,\n  stream_types,\n  WispBuffer, \n  WispPacket, \n  ConnectPayload, \n  DataPayload, \n  ClosePayload,\n  InfoPayload\n} from \"../packet.mjs\";\n\nimport { MOTDExtension, UDPExtension, serialize_extensions, parse_extensions } from \"../extensions.mjs\";\n\nclass ClientStream {\n  constructor(hostname, port, websocket, buffer_size, stream_id, connection, stream_type) {\n    this.hostname = hostname;\n    this.port = port;\n    this.ws = websocket;\n    this.buffer_size = buffer_size;\n    this.stream_id = stream_id;\n    this.connection = connection;\n    this.stream_type = stream_type;\n    this.send_buffer = [];\n    this.open = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onmessage = () => {};\n  }\n\n  send(data) {\n    //note: udp shouldn't buffer anything\n    if (this.buffer_size > 0 || !this.open || this.stream_type === stream_types.UDP) {\n      //construct and send a DATA packet\n      let packet = new WispPacket({\n        type: packet_types.DATA,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(data)\n        })\n      });\n      this.ws.send(packet.serialize().bytes);\n      this.buffer_size--;\n    }\n    else { //server is slow, don't send data yet\n      this.send_buffer.push(data);\n    }\n  }\n\n  //handle receiving a CONTINUE packet\n  continue_received(buffer_size) {\n    this.buffer_size = buffer_size;\n    //send buffered data now\n    while (this.buffer_size > 0 && this.send_buffer.length > 0) {\n      this.send(this.send_buffer.shift());\n    }\n  }\n\n  //construct and send a CLOSE packet\n  close(reason = 0x01) {\n    if (!this.open) return;\n    let packet = new WispPacket({\n      type: packet_types.CLOSE,\n      stream_id: this.stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    this.open = false;\n    delete this.connection.active_streams[this.stream_id];\n  }\n}\n\nexport class ClientConnection {\n  constructor(wisp_url, {wisp_version, wisp_extensions} = {}) {\n    if (!wisp_url.endsWith(\"/\")) {\n      throw new TypeError(\"wisp endpoints must end with a trailing forward slash\");\n    }\n\n    this.wisp_url = wisp_url;\n    this.wisp_version = wisp_version || 2;\n    this.wisp_extensions = wisp_extensions || null;\n\n    this.max_buffer_size = null;\n    this.active_streams = {};\n    this.connected = false;\n    this.connecting = false;\n    this.next_stream_id = 1;\n\n    this.server_exts = {};\n    this.client_exts = {};\n    this.info_received = false;\n    this.server_motd = null;\n    this.udp_enabled = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n\n    if (this.wisp_version === 2 && this.wisp_extensions === null) {\n      this.add_extensions();\n    }\n\n    this.connect_ws();\n  }\n\n  add_extensions() {\n    this.wisp_extensions = [];\n    this.wisp_extensions.push(new UDPExtension({client_config: {}}));\n    this.wisp_extensions.push(new MOTDExtension({client_config: {}}));\n  }\n\n  connect_ws() {\n    let subprotocol = this.wisp_version === 2 ? \"wisp-v2\" : undefined;\n    this.ws = new compat.WebSocket(this.wisp_url, subprotocol);\n    this.ws.binaryType = \"arraybuffer\";\n    this.connecting = true;\n\n    this.ws.onerror = () => {\n      if (this.wisp_version === 2) {\n        this.ws.onclose = null;\n        this.cleanup();\n        this.wisp_version = 1;\n        this.connect_ws();\n        return;\n      }\n      this.cleanup();\n      this.onerror();\n    };\n    this.ws.onclose = () => {\n      this.cleanup();\n      this.onclose();\n    };\n    this.ws.onmessage = (event) => {\n      this.on_ws_msg(event);\n      if (this.connected && this.connecting) {\n        this.connecting = false;\n        this.onopen();\n      }\n    };\n  }\n\n  close() {\n    this.ws.close();\n  }\n\n  create_stream(hostname, port, type=0x01) {\n    let stream_type = type;\n    if (typeof stream_type === \"string\") \n      stream_type = type === \"udp\" ? stream_types.UDP : stream_types.TCP;\n\n    if (stream_type == stream_types.UDP && !this.udp_enabled) {\n      throw new Error(\"udp is not enabled for this wisp connection\");\n    }\n\n    let stream_id = this.next_stream_id++;\n    let stream = new ClientStream(hostname, port, this.ws, this.max_buffer_size, stream_id, this, stream_type);\n    this.active_streams[stream_id] = stream;\n    stream.open = this.connected;\n\n    //construct CONNECT packet\n    let packet = new WispPacket({\n      type: packet_types.CONNECT,\n      stream_id: stream_id,\n      payload: new ConnectPayload({\n        stream_type: stream_type,\n        port: port,\n        hostname: hostname\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    return stream;\n  }\n\n  close_stream(stream, reason) {\n    stream.onclose(reason);\n    delete this.active_streams[stream.stream_id];\n  }\n\n  on_ws_msg(event) {\n    let buffer = new WispBuffer(new Uint8Array(event.data));\n    if (buffer.size < WispPacket.min_size) {\n      console.warn(`wisp client warning: received a packet which is too short`);\n      return;\n    }\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.active_streams[packet.stream_id];\n    if (packet.stream_id === 0 && this.connecting) {\n      if (packet.type === packet_types.CONTINUE) {\n        this.max_buffer_size = packet.payload.buffer_remaining;\n        this.connected = true;\n        if (!this.info_received) {\n          this.wisp_version = 1;\n        }\n      }\n      \n      if (packet.type === packet_types.INFO && this.wisp_version === 2) {\n        let server_extensions = parse_extensions(packet.payload.extensions, this.wisp_extensions, \"server\");\n        for (let server_ext of server_extensions) {\n          for (let client_ext of this.wisp_extensions) {\n            if (server_ext.id === client_ext.id) {\n              this.server_exts[server_ext.id] = server_ext;\n              this.client_exts[client_ext.id] = client_ext;\n            }\n          }\n        }\n\n        this.info_received = true; \n        this.server_motd = this.server_exts[MOTDExtension.id]?.payload?.message;\n        this.udp_enabled = !!this.server_exts[UDPExtension.id];\n\n        let ext_buffer = serialize_extensions(this.wisp_extensions);\n        let info_packet = new WispPacket({\n          type: InfoPayload.type,\n          stream_id: 0,\n          payload: new InfoPayload({\n            major_ver: this.wisp_version,\n            minor_ver: 0,\n            extensions: ext_buffer\n          })\n        });\n        this.ws.send(info_packet.serialize().bytes);\n      }\n      return;\n    }\n\n    if (typeof stream === \"undefined\") {\n      console.warn(`wisp client warning: received a ${packet_classes[packet.type].name} packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === packet_types.DATA) {\n      stream.onmessage(packet.payload_bytes.bytes);\n    }\n\n    else if (packet.type === packet_types.CONTINUE) { //other CONTINUE packets\n      stream.continue_received(packet.payload.buffer_remaining);\n    }\n\n    else if (packet.type === packet_types.CLOSE) {\n      this.close_stream(stream, packet.payload.reason);\n    }\n\n    else {\n      console.warn(`wisp client warning: received an invalid packet of type ${packet.type}`);\n    }\n  }\n\n  cleanup() {\n    this.connected = false;\n    this.connecting = false;\n    for (let stream_id of Object.keys(this.active_streams)) {\n      this.close_stream(this.active_streams[stream_id], 0x03);\n    }\n  }\n}\n\n","import { global_this } from \"../compat.mjs\";\nimport { ClientConnection } from \"./connection.mjs\";\n\n//polyfill the DOM Websocket API so that applications using wsproxy can easily use wisp with minimal changes\n\nconst RealCloseEvent = (global_this.CloseEvent || Event);\nexport const _wisp_connections = {};\n\nexport class WispWebSocket extends EventTarget {\n  constructor(url, protocols=null, options = {}) {\n    super();\n    this.url = url;\n    this.protocols = protocols;\n    this.options = options;\n    this.binaryType = \"blob\";\n    this.stream = null;\n    this.connection = null;\n\n    //legacy event handlers\n    this.onopen = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n    this.onclose = () => {};\n\n    this.CONNECTING = 0;\n    this.OPEN = 1;\n    this.CLOSING = 2;\n    this.CLOSED = 3;\n    this._ready_state = this.CONNECTING;\n\n    //parse the wsproxy url\n    let url_split = this.url.split(\"/\");\n    let wsproxy_path = url_split.pop().split(\":\");\n    this.host = wsproxy_path[0];\n    this.port = parseInt(wsproxy_path[1]);\n    this.real_url = url_split.join(\"/\") + \"/\";\n\n    this.init_connection();\n  }\n\n  on_conn_close() {\n    this._ready_state = this.CLOSED;\n    if (_wisp_connections[this.real_url]) {\n      this.onerror(new Event(\"error\"));\n      this.dispatchEvent(new Event(\"error\"));\n    }\n    delete _wisp_connections[this.real_url];\n  }\n\n  init_connection() {\n    //create the stream\n    this.connection = _wisp_connections[this.real_url];\n\n    if (!this.connection) {\n      this.connection = new ClientConnection(this.real_url, this.options);\n      this.connection.onopen = () => {\n        this.init_stream();\n      };\n      this.connection.onclose = () => {\n        this.on_conn_close()\n      };\n      this.connection.onerror = () => {\n        this.on_conn_close()\n      };\n      _wisp_connections[this.real_url] = this.connection;\n    }\n    else if (!this.connection.connected) {\n      let old_onopen = this.connection.onopen;\n      this.connection.onopen = () => {\n        old_onopen();\n        this.init_stream();\n      };\n    }\n    else {\n      this.connection = _wisp_connections[this.real_url];\n      this.init_stream();\n    }\n  }\n\n  init_stream() {\n    this._ready_state = this.OPEN;\n    this.stream = this.connection.create_stream(this.host, this.port);\n\n    this.stream.onmessage = (raw_data) => {\n      let data;\n      if (this.binaryType == \"blob\") {\n        data = new Blob(raw_data);\n      }\n      else if (this.binaryType == \"arraybuffer\") {\n        data = raw_data.buffer;\n      }\n      else {\n        throw \"invalid binaryType string\";\n      }\n      let msg_event = new MessageEvent(\"message\", {data: data});\n      this.onmessage(msg_event);\n      this.dispatchEvent(msg_event);\n    };\n\n    this.stream.onclose = (reason) => {\n      this._ready_state = this.CLOSED;\n      let close_event = new RealCloseEvent(\"close\", {code: reason}); \n      this.onclose(close_event);\n      this.dispatchEvent(close_event);\n    };\n\n    let open_event = new Event(\"open\");\n    this.onopen(open_event);\n    this.dispatchEvent(open_event);\n  }\n\n  send(data) {\n    let data_array;\n\n    if (data instanceof Uint8Array) {\n      data_array = data;  \n    }\n    else if (typeof data === \"string\") {\n      data_array = new TextEncoder().encode(data);\n    }\n    else if (data instanceof Blob) {\n      data.arrayBuffer().then(array_buffer => {\n        this.send(array_buffer);\n      });\n      return;\n    }\n    else if (data instanceof ArrayBuffer) {\n      data_array = new Uint8Array(data);\n    }\n    //dataview objects or any other typedarray\n    else if (ArrayBuffer.isView(data)) {\n      data_array = new Uint8Array(data.buffer);\n    }\n    else {\n      throw \"invalid data type to be sent\";\n    }\n\n    if (!this.stream) {\n      throw \"websocket is not ready\";\n    }\n    this.stream.send(data_array);\n  }\n\n  close() {\n    this.stream.close(0x02);\n  }\n\n  get bufferedAmount() {\n    let total = 0;\n    for (let msg of this.stream.send_buffer) {\n      total += msg.length;\n    }\n    return total;\n  }\n\n  get extensions() {\n    return \"\";\n  }\n\n  get protocol() {\n    return \"binary\";\n  }\n\n  get readyState() {\n    return this._ready_state;\n  }\n}"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","global_this","globalThis","window","WebSocket","text_encoder","crypto","TextEncoder","encode_text","encode","bind","text_decoder","TextDecoder","decode_text","decode","WispBuffer","constructor","data","Uint8Array","this","from_array","console","trace","bytes","size","length","view","DataView","buffer","concat","new_buffer","set","slice","index","bytes_slice","get_string","WispPacket","static","type","stream_id","payload","payload_bytes","parse","getUint8","getUint32","parse_all","min_size","TypeError","packet","payload_class","packet_classes","serialize","setUint8","setUint32","ConnectPayload","stream_type","port","hostname","getUint16","setUint16","DataPayload","ContinuePayload","buffer_remaining","ClosePayload","reason","InfoPayload","major_ver","minor_ver","extensions","packet_types","CONNECT","DATA","CONTINUE","CLOSE","INFO","stream_types","TCP","UDP","close_reasons","Unknown","Voluntary","NetworkError","IncompatibleExtensions","InvalidInfo","UnreachableHost","NoResponse","ConnRefused","TransferTimeout","HostBlocked","ConnThrottled","ClientError","AuthBadPassword","AuthBadSignature","AuthMissingCredentials","EmptyPayload","BaseExtension","server_config","client_config","id","name","Server","Client","ext_class","role","extension","payload_buffer","setInt8","UDPExtension","PasswordAuthExtension","required","username","password","username_len","password_len","password_index","username_buffer","password_buffer","MOTDExtension","message","parse_extensions","valid_extensions","parsed_extensions","ext_id","ext_len","ext_payload","ext_parsed","push","serialize_extensions","ext_buffer","extensions_map","ClientStream","websocket","buffer_size","connection","ws","send_buffer","open","onopen","onclose","onmessage","send","continue_received","shift","close","active_streams","ClientConnection","wisp_url","wisp_version","wisp_extensions","endsWith","max_buffer_size","connected","connecting","next_stream_id","server_exts","client_exts","info_received","server_motd","udp_enabled","onerror","add_extensions","connect_ws","subprotocol","undefined","binaryType","cleanup","event","on_ws_msg","create_stream","Error","stream","close_stream","warn","server_extensions","server_ext","client_ext","info_packet","keys","RealCloseEvent","CloseEvent","Event","_wisp_connections","WispWebSocket","EventTarget","url","protocols","options","super","CONNECTING","OPEN","CLOSING","CLOSED","_ready_state","url_split","split","wsproxy_path","pop","host","parseInt","real_url","join","init_connection","on_conn_close","dispatchEvent","init_stream","old_onopen","raw_data","Blob","msg_event","MessageEvent","close_event","code","open_event","data_array","arrayBuffer","then","array_buffer","ArrayBuffer","isView","bufferedAmount","total","msg","protocol","readyState"],"ignoreList":[],"sourceRoot":""}